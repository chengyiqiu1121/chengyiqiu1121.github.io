
  <!DOCTYPE html>
  <html lang="en"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>
    window.icon_font = '4552607_ikzjpc9jicn';
  </script>
  
  
  <title>
    嵌入式操作系统-MicroCOS III |
    
    Hexo
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="​	在对操作系统的概念有一定的了解后，再进行嵌入式操作系统的学习。结合电子教材，和课上老师所讲内容，整理归纳出来的内容。 ​	在学习MicroCOS这门课时，一个比较好的点是，这门课偏于实操而不是概念，这是我在操作系统概念里没有体会到的。通过看书实验能看到很多具体的例子，而不是书上抽象的文字。 临界断代码这一章比较简单。主要介绍临界段代码的相关知识：什么是临界段代码？如何实现临界段代码？等等 临界">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式操作系统-MicroCOS III">
<meta property="og:url" content="http://example.com/2022/05/26/MicroCOS-III/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="​	在对操作系统的概念有一定的了解后，再进行嵌入式操作系统的学习。结合电子教材，和课上老师所讲内容，整理归纳出来的内容。 ​	在学习MicroCOS这门课时，一个比较好的点是，这门课偏于实操而不是概念，这是我在操作系统概念里没有体会到的。通过看书实验能看到很多具体的例子，而不是书上抽象的文字。 临界断代码这一章比较简单。主要介绍临界段代码的相关知识：什么是临界段代码？如何实现临界段代码？等等 临界">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-20-00-42.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-20-23-33.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-20-33-35.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526102822447.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526103032191.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526102401491.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526104007271.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526105949631.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526110343823.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526110700820.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526112027946.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526112133334.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526112824466.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/image-20220526112848088.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-26-16-54-51.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-26-17-06-56.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-26-17-59-41.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-26-17-58-54.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-26-18-00-34.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-13-41.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-19-10.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-19-24.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-21-05.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-48-32.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-48-45.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-55-44.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-21-57-00.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-22-07-03.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-20-25-01.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-20-36-07.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-29-11.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-37-45.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-41-10.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-47-37.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-51-20.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-21-59-02.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-22-15-55.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-22-33-41.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-22-34-34.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-22-42-48.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-29-22-43-04.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-11-24-33.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-11-27-52.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-11-42-06.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-19-27-42.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-19-30-41.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-19-41-32.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-20-01-51.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-20-13-45.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-18-53.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-47-53.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-50-04.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-52-43.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-54-05.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-30-23-59-43.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-05-21-26-44.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-05-21-42-38.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-05-22-04-03.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-05-22-06-15.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-06-23-15-09.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-06-23-23-15.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-06-23-39-30.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-13-22-53-55.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-13-23-21-21.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-13-23-34-55.png">
<meta property="og:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-06-16-23-08-44.png">
<meta property="article:published_time" content="2022-05-26T01:55:03.000Z">
<meta property="article:modified_time" content="2022-06-27T13:12:23.562Z">
<meta property="article:author" content="chengyiqiu">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/26/MicroCOS-III/2022-05-28-20-00-42.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 7.2.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/banner.jpg" alt="嵌入式操作系统-MicroCOS III">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>嵌入式操作系统-MicroCOS III</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-MicroCOS-III" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2022/05/26/MicroCOS-III/" class="article-date-link">
    <time datetime="2022-05-26T01:55:03.000Z" itemprop="datePublished">2022-05-26</time>
  </a>
</div>

      
  <div class="article-category wow slideInLeft">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​	在对操作系统的概念有一定的了解后，再进行嵌入式操作系统的学习。结合电子教材，和课上老师所讲内容，整理归纳出来的内容。</p>
<p>​	在学习MicroCOS这门课时，一个比较好的点是，这门课偏于实操而不是概念，这是我在操作系统概念里没有体会到的。通过看书实验能看到很多具体的例子，而不是书上抽象的文字。</p>
<h1 id="临界断代码"><a href="#临界断代码" class="headerlink" title="临界断代码"></a>临界断代码</h1><p>这一章比较简单。主要介绍临界段代码的相关知识：什么是临界段代码？如何实现临界段代码？等等</p>
<h2 id="临界段代码的定义"><a href="#临界段代码的定义" class="headerlink" title="临界段代码的定义"></a>临界段代码的定义</h2><p>临界段代码，又称临界区，是指必须完整连续运行，不可被中断的代码。访问内核数据结构的代码一般都不能被中断，所以是临界区。</p>
<p>像我们创建任务时，需要创建TCB，将TCB插入就绪队列，这就属于是临界段代码。<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-20-00-42.png"></p>
<p>我们有两种方法保护临界区代码不被中断：</p>
<ul>
<li>关中断</li>
<li>锁调度器</li>
</ul>
<p>有相应的宏：</p>
<p><strong>OS_CFG_ISR_POST_DEFFERRED_ED</strong>：OS配置ISR提交信号量延迟使能<br>PS：意思就是，如果在ISR中来要发送信号量，那么是否进行延迟发布，这个延处发布就是通过锁住调度器，将信号量缓存到ISR队列中去实现；也就是说en&#x3D;1进行延迟，反之，就不延迟信号量，而是直接关闭中断。</p>
<ul>
<li>0，采用关中断保护临界区</li>
<li>1，采用锁调度器保护临界区</li>
</ul>
<p><strong>OS_CRITICAL_ENTER（）</strong>：进入临界区前使用。<br><strong>OS_CRITICAL_EXIT()</strong>&#x2F;**OS_CRITICAL_EXIT_NO_SCHED()**：出临界区时使用</p>
<h2 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h2><p>简单讲下关中断是怎么实现的。</p>
<p>我们可以另宏<strong>OS_CFG_ISR_POST_DEFERRED_EN&#x3D;0</strong>，那么在进入临界区前，会关闭中断，出临界区时，会重新打开中断。</p>
<p>而宏**OS_CRITICAL_ENTER()<strong>，会调用另一个宏</strong>CPU_CRITICAL_ENTER()<strong>，最终调用宏</strong>CPU_SR_SAVE()**。所以直接解释CPU_SR_SAVE()即可：</p>
<p>CPU_SR_SAVE()使用汇编写的，会将当前中断的状态保留起来，然后关闭所有中断，将暂存的中断状态保留在调用函数的局部变量<strong>CPU_SR</strong>（被动态分配在任务栈上）中。</p>
<p>而OS_CRITICAL_EXIT()和OS_CRITICAL_EXIT_NO_SCHED()，同理都调用了另一个宏**CPU_CRITICAL_EXIT()<strong>，最终调用</strong>CPU_SR_RESTORE()**，顾名思义，就是根据CPU_SR，来恢复之前暂存的中断。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-28-20-23-33.png"></p>
<h2 id="测量关中断的时间"><a href="#测量关中断的时间" class="headerlink" title="测量关中断的时间"></a>测量关中断的时间</h2><p>使能<strong>CPU_CFG_INT_DIS_MEAS_EN&#x3D;1</strong>即可</p>
<h2 id="调度器上锁"><a href="#调度器上锁" class="headerlink" title="调度器上锁"></a>调度器上锁</h2><p>最简单的，使能宏<strong>OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1</strong>。然后进入临界段前锁调度器，出临界段时调度器解锁。</p>
<p>而<strong>OS_CRITIAL_ENTER()<strong>，递增全局变量</strong>OSSchedLockNestingCtr</strong>，如果该全局变量的值不为0，那么说明调度器上锁。</p>
<p>相反的<strong>OS_CRITICAL_EXIT()<strong>，则是递减全局变量</strong>OSSchedLockCtr</strong>，如果为0，会启动任务调度器。</p>
<p>类似的**OS_CRITICAL_EXIT_NO_SCHED()**，也会递减全局变量，但是为0时不会启动调度器。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-28-20-33-35.png"></p>
<h2 id="测量锁调度器的时间"><a href="#测量锁调度器的时间" class="headerlink" title="测量锁调度器的时间"></a>测量锁调度器的时间</h2><p>使能<strong>OS_CFG_SCHED_LOCK_TIME_MEAS_EN&#x3D;1</strong>即可。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>很多宏都是在os.cfg.h中，下面瞅瞅</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OS_CFG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* ---------------------------- MISCELLANEOUS -------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_APP_HOOKS_EN             1u   <span class="comment">/* Enable (1) or Disable (0) application specific hooks                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_ARG_CHK_EN               1u   <span class="comment">/* Enable (1) or Disable (0) argument checking                           */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_CALLED_FROM_ISR_CHK_EN   1u   <span class="comment">/* Enable (1) or Disable (0) check for called from ISR                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_DBG_EN                   1u   <span class="comment">/* Enable (1) debug code/variables                                       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_ISR_POST_DEFERRED_EN     1u   <span class="comment">/* Enable (1) or Disable (0) Deferred ISR posts Í¨¹ýµ÷¶ÈÆ÷ÉÏËøÀ´·ÃÎÊÁÙ½ç¶Î*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_OBJ_TYPE_CHK_EN          1u   <span class="comment">/* Enable (1) or Disable (0) object type checking                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TS_EN                    1u   <span class="comment">/* Enable (1) or Disable (0) time stamping                               */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_PEND_MULTI_EN            0u   <span class="comment">/* Enable (1) or Disable (0) code generation for multi-pend feature      */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_PRIO_MAX                64u   <span class="comment">/* Defines the maximum number of task priorities (see OS_PRIO data type) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SCHED_LOCK_TIME_MEAS_EN  1u   <span class="comment">/* Include code to measure scheduler lock time                           */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SCHED_ROUND_ROBIN_EN     1u   <span class="comment">/* Include code for Round-Robin scheduling                               */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_STK_SIZE_MIN            64u   <span class="comment">/* Minimum allowable task stack size                                     */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* ----------------------------- EVENT FLAGS --------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_FLAG_EN                  1u   <span class="comment">/* Enable (1) or Disable (0) code generation for EVENT FLAGS             */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_FLAG_DEL_EN              1u   <span class="comment">/*     Include code for OSFlagDel()                                      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_FLAG_MODE_CLR_EN         1u   <span class="comment">/*     Include code for Wait on Clear EVENT FLAGS                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_FLAG_PEND_ABORT_EN       1u   <span class="comment">/*     Include code for OSFlagPendAbort()                                */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* -------------------------- MEMORY MANAGEMENT ------------------------ */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_MEM_EN                   1u   <span class="comment">/* Enable (1) or Disable (0) code generation for MEMORY MANAGER          */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* --------------------- MUTUAL EXCLUSION SEMAPHORES ------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_MUTEX_EN                 1u   <span class="comment">/* Enable (1) or Disable (0) code generation for MUTEX                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_MUTEX_DEL_EN             1u   <span class="comment">/*     Include code for OSMutexDel()                                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_MUTEX_PEND_ABORT_EN      1u   <span class="comment">/*     Include code for OSMutexPendAbort()                               */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* --------------------------- MESSAGE QUEUES -------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_Q_EN                     1u   <span class="comment">/* Enable (1) or Disable (0) code generation for QUEUES                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_Q_DEL_EN                 1u   <span class="comment">/*     Include code for OSQDel()                                         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_Q_FLUSH_EN               1u   <span class="comment">/*     Include code for OSQFlush()                                       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_Q_PEND_ABORT_EN          1u   <span class="comment">/*     Include code for OSQPendAbort()                                   */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* ----------------------------- SEMAPHORES ---------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SEM_EN                   1u   <span class="comment">/* Enable (1) or Disable (0) code generation for SEMAPHORES              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SEM_DEL_EN               1u   <span class="comment">/*    Include code for OSSemDel()                                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SEM_PEND_ABORT_EN        1u   <span class="comment">/*    Include code for OSSemPendAbort()                                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_SEM_SET_EN               1u   <span class="comment">/*    Include code for OSSemSet()                                        */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* -------------------------- TASK MANAGEMENT -------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_STAT_TASK_EN             1u   <span class="comment">/* Enable (1) or Disable(0) the statistics task                          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_STAT_TASK_STK_CHK_EN     1u   <span class="comment">/* Check task stacks from statistic task                                 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_CHANGE_PRIO_EN      1u   <span class="comment">/* Include code for OSTaskChangePrio()                                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_DEL_EN              1u   <span class="comment">/* Include code for OSTaskDel()                                          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_Q_EN                1u   <span class="comment">/* Include code for OSTaskQXXXX()                                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_Q_PEND_ABORT_EN     1u   <span class="comment">/* Include code for OSTaskQPendAbort()                                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_PROFILE_EN          1u   <span class="comment">/* Include variables in OS_TCB for profiling                             */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_REG_TBL_SIZE        1u   <span class="comment">/* Number of task specific registers                                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_SEM_PEND_ABORT_EN   1u   <span class="comment">/* Include code for OSTaskSemPendAbort()                                 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TASK_SUSPEND_EN          1u   <span class="comment">/* Include code for OSTaskSuspend() and OSTaskResume()                   */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* -------------------------- TIME MANAGEMENT -------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TIME_DLY_HMSM_EN         1u   <span class="comment">/*     Include code for OSTimeDlyHMSM()                                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TIME_DLY_RESUME_EN       1u   <span class="comment">/*     Include code for OSTimeDlyResume()                                */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* ------------------- TASK LOCAL STORAGE MANAGEMENT ------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TLS_TBL_SIZE             0u   <span class="comment">/* Include code for Task Local Storage (TLS) registers                   */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                             <span class="comment">/* ------------------------- TIMER MANAGEMENT -------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TMR_EN                   1u   <span class="comment">/* Enable (1) or Disable (0) code generation for TIMERS                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_CFG_TMR_DEL_EN               1u   <span class="comment">/* Enable (1) or Disable (0) code generation for OSTmrDel()              */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在MicroCOS中，最小的调度单元不叫线程或者进程，而叫做任务，但可以理解为进程。任务是MicroCOS的CPU调度的最小单元。MicroCOS支持多任务，理论上支持无限的任务，但事实上被存储空间大小所限制。</p>
<p>任务的类型：</p>
<ul>
<li>无限循环型（endless loop）：一个while1死循环，其中，必须要有将自身挂起的操作，不然优先级比他低的任务都无法运行（优先级不同时采用的优先级调度法）</li>
<li>运行至完成型（run to end）：跑一遍就结束了</li>
</ul>
<p>一般都是endless loop类型的任务。</p>
<p>任务很像一个C函数，这是正常的，像Java中的线程的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="number">0x11</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>然后再看看任务的创建：</p>
<p>C函数创建：任务代码，任务的功能</p>
<p>这个图中有将自身挂起操作的列举。<br><img src="/2022/05/26/MicroCOS-III/image-20220526102822447.png" alt="image-20220526102822447"><br>这是实际中写的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led2_task</span><span class="params">(<span class="type">void</span> *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	OS_ERR err_pend, err_post, err_dly;</span><br><span class="line">	CPU_TS ts;</span><br><span class="line">	p_arg = p_arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LED2=!LED2;</span></span><br><span class="line">		<span class="comment">//OSTimeDlyHMSM(0,0,0,400,OS_OPT_TIME_HMSM_STRICT,&amp;err); //ÑÓdelay 400ms</span></span><br><span class="line">		OSSemPend(&amp;mySem, <span class="number">0</span>, OS_OPT_PEND_BLOCKING, &amp;ts, &amp;err_pend);</span><br><span class="line">		<span class="keyword">switch</span>(err_pend) &#123;</span><br><span class="line">			<span class="keyword">case</span> OS_ERR_NONE:</span><br><span class="line">				LED2 = !LED2;</span><br><span class="line">				OSSemPost(&amp;mySem, OS_OPT_POST_ALL, &amp;err_post);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		OSTimeDlyHMSM(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,OS_OPT_TIME_PERIODIC,&amp;err_dly);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>任务的创建：把任务由休眠态-&gt;就绪态，也就是从外存（code区）加载内存（ram区）</p>
<p>这是创建任务的函数，看看里面需要传入的参数。</p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526103032191.png" alt="image-20220526103032191"></p>
<p>这是实际创建任务的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreate((OS_TCB 	* )&amp;Led2TaskTCB,		</span><br><span class="line">			 (CPU_CHAR	* )<span class="string">&quot;led2 task&quot;</span>, 		</span><br><span class="line">                (OS_TASK_PTR )led2_task, 			</span><br><span class="line">                (<span class="type">void</span>		* )<span class="number">0</span>,					</span><br><span class="line">                (OS_PRIO	  )LED2_TASK_PRIO,     </span><br><span class="line">                (CPU_STK   * )&amp;LED2_TASK_STK[<span class="number">0</span>],	</span><br><span class="line">                (CPU_STK_SIZE)LED2_STK_SIZE/<span class="number">10</span>,	</span><br><span class="line">                (CPU_STK_SIZE)LED2_STK_SIZE,		</span><br><span class="line">                (OS_MSG_QTY  )<span class="number">0</span>,					</span><br><span class="line">                (OS_TICK	  )<span class="number">0</span>,					</span><br><span class="line">                (<span class="type">void</span>   	* )<span class="number">0</span>,					</span><br><span class="line">                (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,</span><br><span class="line">                (OS_ERR 	* )&amp;err);</span><br></pre></td></tr></table></figure>



<p>提一下<strong>可重入函数</strong>：</p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526102401491.png" alt="image-20220526102401491"></p>
<p>可重入就是能被中断的意思，像上面提到的**strtok()**函数，假设其是可重入的，如果调用一次后发生调度（时间片用完or更高优先级的任务来了），然后下一个任务也调用这个函数，那么第一次调度记住的指针就会被覆盖，出现了BUG，所以该函数是不可重入的。</p>
<p>接着聊任务，任务创建完毕后，它的TCB会被加入到任务就绪表中去，然后启动任务调度器，决定是否进行任务的切换（根据优先级）。</p>
<h2 id="任务优先级的分配"><a href="#任务优先级的分配" class="headerlink" title="任务优先级的分配"></a>任务优先级的分配</h2><p>主要讨论任务优先级该怎么分配。有一个单调执行率调度法（RMS，Rate Monitonic Scheduling）。其核心思想是：让执行频率最高的任务得到最高的优先级：其假设：</p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526104007271.png" alt="image-20220526104007271"></p>
<h2 id="栈空间大小确定"><a href="#栈空间大小确定" class="headerlink" title="栈空间大小确定"></a>栈空间大小确定</h2><p>任务栈空间大小的确定取决一下因素：</p>
<ul>
<li>CPU中的寄存器个数（包括FPU浮点运算单元）</li>
<li>函数嵌套层数</li>
<li>ISR嵌套层数</li>
</ul>
<p>当IRQ来时，保存当前任务的现场，然后执行对应的ISR代码（使用的堆栈还是任务堆栈）。如果ISR嵌套多层的话，那么会发生堆栈溢出，直接寄。</p>
<h2 id="任务栈溢出检测"><a href="#任务栈溢出检测" class="headerlink" title="任务栈溢出检测"></a>任务栈溢出检测</h2><h3 id="使用MPU-or-MMU"><a href="#使用MPU-or-MMU" class="headerlink" title="使用MPU or MMU"></a>使用MPU or MMU</h3><p>这个取决于CPU的种类，有的CPU中集成了MPU（存储保护单元）和MMU（存储管理单元），就能通过硬件来进行存储保护，也能防止堆栈溢出。</p>
<h3 id="堆栈指针溢出检测寄存器"><a href="#堆栈指针溢出检测寄存器" class="headerlink" title="堆栈指针溢出检测寄存器"></a>堆栈指针溢出检测寄存器</h3><p>有的CPU能够检测堆栈溢出。具体就是，有的CPU内部有一个堆栈指针溢出检测寄存器，其中有个值，当SP（堆栈指针）高于或低于（跟堆栈生长的方向有关）该寄存器的值时，就会出异常，报警告或者直接停止程序的运行。</p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526105949631.png" alt="image-20220526105949631"></p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526110343823.png" alt="image-20220526110343823"></p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526110700820.png" alt="image-20220526110700820"></p>
<p>当发生任务切换的时候，保护现场后，需要恢复下一个任务的现场，CPU的堆栈溢出检测寄存器使用的.stackLimitPtr也需要修改：</p>
<ul>
<li>首先修改.stackLimitPtr指向NULL，也就是0，一个永远不可能溢出的位置</li>
<li>然后改变CPU堆栈指针寄存器的值（SP）</li>
<li>最后修改硬件使用的指针.stackLimitPtr，使其等于当前任务TCB中的stackLimitPtr的值</li>
</ul>
<p>如果不这样做，先修改SP，会产生异常。所以先使得硬件使用的stackLimitPtr指向一个无效的，不可能溢出的值</p>
<h3 id="软件检测方法"><a href="#软件检测方法" class="headerlink" title="软件检测方法"></a>软件检测方法</h3><p>在硬件不提供堆栈溢出的检测时，可以使用软件的方法设置一个<strong>stackLimitPtr</strong>，使得SP不高于其值，在一个叫介入函数的地方设置</p>
<h3 id="计算空闲堆栈空间的数量"><a href="#计算空闲堆栈空间的数量" class="headerlink" title="计算空闲堆栈空间的数量"></a>计算空闲堆栈空间的数量</h3><p><img src="/2022/05/26/MicroCOS-III/image-20220526112027946.png" alt="image-20220526112027946"></p>
<h2 id="任务管理函数"><a href="#任务管理函数" class="headerlink" title="任务管理函数"></a>任务管理函数</h2><p><img src="/2022/05/26/MicroCOS-III/image-20220526112133334.png" alt="image-20220526112133334"></p>
<h2 id="任务管理的内部原理"><a href="#任务管理的内部原理" class="headerlink" title="任务管理的内部原理"></a>任务管理的内部原理</h2><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>两张状态图</p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526112824466.png" alt="image-20220526112824466"></p>
<p><img src="/2022/05/26/MicroCOS-III/image-20220526112848088.png" alt="image-20220526112848088"></p>
<h3 id="TCB"><a href="#TCB" class="headerlink" title="TCB"></a>TCB</h3><p>图太长了，直接copy代码过来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">os_tcb</span> &#123;</span></span><br><span class="line">    CPU_STK             *StkPtr;                            <span class="comment">/* Pointer to current top of stack                        */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>                *ExtPtr;                            <span class="comment">/* Pointer to user definable data for TCB extension       */</span></span><br><span class="line"></span><br><span class="line">    CPU_STK             *StkLimitPtr;                       <span class="comment">/* Pointer used to set stack &#x27;watermark&#x27; limit            */</span></span><br><span class="line"></span><br><span class="line">    OS_TCB              *NextPtr;                           <span class="comment">/* Pointer to next     TCB in the TCB list                */</span></span><br><span class="line">    OS_TCB              *PrevPtr;                           <span class="comment">/* Pointer to previous TCB in the TCB list                */</span></span><br><span class="line"></span><br><span class="line">    OS_TCB              *TickNextPtr;</span><br><span class="line">    OS_TCB              *TickPrevPtr;</span><br><span class="line"></span><br><span class="line">    OS_TICK_SPOKE       *TickSpokePtr;                      <span class="comment">/* Pointer to tick spoke if task is in the tick list      */</span></span><br><span class="line"></span><br><span class="line">    CPU_CHAR            *NamePtr;                           <span class="comment">/* Pointer to task name                                   */</span></span><br><span class="line"></span><br><span class="line">    CPU_STK             *StkBasePtr;                        <span class="comment">/* Pointer to base address of stack                       */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_CFG_TLS_TBL_SIZE) &amp;&amp; (OS_CFG_TLS_TBL_SIZE &gt; 0u)</span></span><br><span class="line">    OS_TLS               TLS_Tbl[OS_CFG_TLS_TBL_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OS_TASK_PTR          TaskEntryAddr;                     <span class="comment">/* Pointer to task entry point address                    */</span></span><br><span class="line">    <span class="type">void</span>                *TaskEntryArg;                      <span class="comment">/* Argument passed to task when it was created            */</span></span><br><span class="line"></span><br><span class="line">    OS_PEND_DATA        *PendDataTblPtr;                    <span class="comment">/* Pointer to list containing objects pended on           */</span></span><br><span class="line">    OS_STATE             PendOn;                            <span class="comment">/* Indicates what task is pending on                      */</span></span><br><span class="line">    OS_STATUS            PendStatus;                        <span class="comment">/* Pend status                                            */</span></span><br><span class="line"></span><br><span class="line">    OS_STATE             TaskState;                         <span class="comment">/* See OS_TASK_STATE_xxx                                  */</span></span><br><span class="line">    OS_PRIO              Prio;                              <span class="comment">/* Task priority (0 == highest)                           */</span></span><br><span class="line">    CPU_STK_SIZE         StkSize;                           <span class="comment">/* Size of task stack (in number of stack elements)       */</span></span><br><span class="line">    OS_OPT               Opt;                               <span class="comment">/* Task options as passed by OSTaskCreate()               */</span></span><br><span class="line"></span><br><span class="line">    OS_OBJ_QTY           PendDataTblEntries;                <span class="comment">/* Size of array of objects to pend on                    */</span></span><br><span class="line"></span><br><span class="line">    CPU_TS               TS;                                <span class="comment">/* Timestamp                                              */</span></span><br><span class="line"></span><br><span class="line">    OS_SEM_CTR           SemCtr;                            <span class="comment">/* Task specific semaphore counter                        */</span></span><br><span class="line"></span><br><span class="line">                                                            <span class="comment">/* DELAY / TIMEOUT                                        */</span></span><br><span class="line">    OS_TICK              TickCtrPrev;                       <span class="comment">/* Previous time when task was            ready           */</span></span><br><span class="line">    OS_TICK              TickCtrMatch;                      <span class="comment">/* Absolute time when task is going to be ready           */</span></span><br><span class="line">    OS_TICK              TickRemain;                        <span class="comment">/* Number of ticks remaining for a match (updated at ...  */</span></span><br><span class="line">                                                            <span class="comment">/* ... run-time by OS_StatTask()                          */</span></span><br><span class="line">    OS_TICK              TimeQuanta;</span><br><span class="line">    OS_TICK              TimeQuantaCtr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_MSG_EN &gt; 0u</span></span><br><span class="line">    <span class="type">void</span>                *MsgPtr;                            <span class="comment">/* Message received                                       */</span></span><br><span class="line">    OS_MSG_SIZE          MsgSize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_Q_EN &gt; 0u</span></span><br><span class="line">    OS_MSG_Q             MsgQ;                              <span class="comment">/* Message queue associated with task                     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_PROFILE_EN &gt; 0u</span></span><br><span class="line">    CPU_TS               MsgQPendTime;                      <span class="comment">/* Time it took for signal to be received                 */</span></span><br><span class="line">    CPU_TS               MsgQPendTimeMax;                   <span class="comment">/* Max amount of time it took for signal to be received   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_REG_TBL_SIZE &gt; 0u</span></span><br><span class="line">    OS_REG               RegTbl[OS_CFG_TASK_REG_TBL_SIZE];  <span class="comment">/* Task specific registers                                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_FLAG_EN &gt; 0u</span></span><br><span class="line">    OS_FLAGS             FlagsPend;                         <span class="comment">/* Event flag(s) to wait on                               */</span></span><br><span class="line">    OS_FLAGS             FlagsRdy;                          <span class="comment">/* Event flags that made task ready to run                */</span></span><br><span class="line">    OS_OPT               FlagsOpt;                          <span class="comment">/* Options (See OS_OPT_FLAG_xxx)                          */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_SUSPEND_EN &gt; 0u</span></span><br><span class="line">    OS_NESTING_CTR       SuspendCtr;                        <span class="comment">/* Nesting counter for OSTaskSuspend()                    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_PROFILE_EN &gt; 0u</span></span><br><span class="line">    OS_CPU_USAGE         CPUUsage;                          <span class="comment">/* CPU Usage of task (0.00-100.00%)                       */</span></span><br><span class="line">    OS_CPU_USAGE         CPUUsageMax;                       <span class="comment">/* CPU Usage of task (0.00-100.00%) - Peak                */</span></span><br><span class="line">    OS_CTX_SW_CTR        CtxSwCtr;                          <span class="comment">/* Number of time the task was switched in                */</span></span><br><span class="line">    CPU_TS               CyclesDelta;                       <span class="comment">/* value of OS_TS_GET() - .CyclesStart                    */</span></span><br><span class="line">    CPU_TS               CyclesStart;                       <span class="comment">/* Snapshot of cycle counter at start of task resumption  */</span></span><br><span class="line">    OS_CYCLES            CyclesTotal;                       <span class="comment">/* Total number of # of cycles the task has been running  */</span></span><br><span class="line">    OS_CYCLES            CyclesTotalPrev;                   <span class="comment">/* Snapshot of previous # of cycles                       */</span></span><br><span class="line"></span><br><span class="line">    CPU_TS               SemPendTime;                       <span class="comment">/* Time it took for signal to be received                 */</span></span><br><span class="line">    CPU_TS               SemPendTimeMax;                    <span class="comment">/* Max amount of time it took for signal to be received   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_STAT_TASK_STK_CHK_EN &gt; 0u</span></span><br><span class="line">    CPU_STK_SIZE         StkUsed;                           <span class="comment">/* Number of stack elements used from the stack           */</span></span><br><span class="line">    CPU_STK_SIZE         StkFree;                           <span class="comment">/* Number of stack elements free on   the stack           */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CPU_CFG_INT_DIS_MEAS_EN</span></span><br><span class="line">    CPU_TS               IntDisTimeMax;                     <span class="comment">/* Maximum interrupt disable time                         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_SCHED_LOCK_TIME_MEAS_EN &gt; 0u</span></span><br><span class="line">    CPU_TS               SchedLockTimeMax;                  <span class="comment">/* Maximum scheduler lock time                            */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">    OS_TCB              *DbgPrevPtr;</span><br><span class="line">    OS_TCB              *DbgNextPtr;</span><br><span class="line">    CPU_CHAR            *DbgNamePtr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体含义见注释</p>
<h2 id="系统内部任务"><a href="#系统内部任务" class="headerlink" title="系统内部任务"></a>系统内部任务</h2><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>又称闲逛任务，闲逛进程，IDLE，其任务代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_IdleTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                          <span class="comment">/* Prevent compiler warning for not using &#x27;p_arg&#x27;         */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        CPU_CRITICAL_ENTER();</span><br><span class="line">        OSIdleTaskCtr++;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_STAT_TASK_EN &gt; 0u</span></span><br><span class="line">        OSStatTaskCtr++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line"></span><br><span class="line">        OSIdleTaskHook();                                   <span class="comment">/* Call user definable HOOK                               */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个真正的无限循环，不会自身挂起，其存在的意义就是，当没有可以运行的任务时，就运行闲逛进程。闲逛进程的优先级最低，</p>
<p>当闲逛任务运行时，就会使OSIdleTaskCtr（这是i32类型）自增，该值增长越快，代表CPU处理我们写的任务的时候处理的越快；OSStatTaskCtr则是测量CPU利用率的。</p>
<p>OSIdleTaskHook是一个函数，可以让IDLE在空闲时做一些额外的任务，如将电源设置为低功耗模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSIdleTaskHook</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_APP_HOOKS_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)<span class="number">0</span>) &#123;</span><br><span class="line">        (*OS_AppIdleTaskHookPtr)();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时钟节拍任务"><a href="#时钟节拍任务" class="headerlink" title="时钟节拍任务"></a>时钟节拍任务</h3><p>时钟节拍任务的目的是什么：为操作系统提供一个周期性的时钟源，用于跟踪任务等待，任务延时，任务超时等情况。一般将其优先级设置成比我们最高优先级的任务低一点，下面看OS_TickTask的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreate((OS_TCB     *)&amp;OSTickTaskTCB,</span><br><span class="line">             (CPU_CHAR   *)((<span class="type">void</span> *)<span class="string">&quot;uC/OS-III Tick Task&quot;</span>),</span><br><span class="line">             (OS_TASK_PTR )OS_TickTask,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_PRIO     )OSCfg_TickTaskPrio,</span><br><span class="line">             (CPU_STK    *)OSCfg_TickTaskStkBasePtr,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_TickTaskStkLimit,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_TickTaskStkSize,</span><br><span class="line">             (OS_MSG_QTY  )<span class="number">0u</span>,</span><br><span class="line">             (OS_TICK     )<span class="number">0u</span>,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),</span><br><span class="line">             (OS_ERR     *)p_err);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_TickTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_ERR  err;</span><br><span class="line">    CPU_TS  ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                          <span class="comment">/* Prevent compiler warning                               */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        (<span class="type">void</span>)OSTaskSemPend((OS_TICK  )<span class="number">0</span>,</span><br><span class="line">                            (OS_OPT   )OS_OPT_PEND_BLOCKING,</span><br><span class="line">                            (CPU_TS  *)&amp;ts,</span><br><span class="line">                            (OS_ERR  *)&amp;err);               <span class="comment">/* Wait for signal from tick interrupt                    */</span></span><br><span class="line">        <span class="keyword">if</span> (err == OS_ERR_NONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OSRunning == OS_STATE_OS_RUNNING) &#123;</span><br><span class="line">                OS_TickListUpdate();                        <span class="comment">/* Update all tasks waiting for time                      */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们再去看优先级：<br><img src="/2022/05/26/MicroCOS-III/2022-05-26-16-54-51.png"><br>可以看到优先级设置为1，无符号数，在任务里面是最高优先级了。</p>
<p>然后再关注任务代码，其中，OS_TickTask是个endless loop，其在不停的等待一个信号量，这个信号由时钟节拍的ISR发出，如果没有错误，那么就更新所有在等待的任务，也就是OS_TickListUpdate()。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-26-17-06-56.png"></p>
<p>下面看看时钟节拍的ISR，如果允许中断，那么当接收到时钟节拍中断（硬件发出）时，会进入到时钟节拍的ISR中，然后再时钟节拍的ISR中，会调用一个OS_TimeTick函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSTimeTick</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_ERR  err;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ISR_POST_DEFERRED_EN &gt; 0u</span></span><br><span class="line">    CPU_TS  ts;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OSTimeTickHook();                                       <span class="comment">/* Call user definable hook                               */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ISR_POST_DEFERRED_EN &gt; 0u <span class="comment">/* 关调度器 */</span></span></span><br><span class="line"></span><br><span class="line">    ts = OS_TS_GET();                                       <span class="comment">/* Get timestamp                                          */</span></span><br><span class="line">    OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             <span class="comment">/* Post to ISR queue                                      */</span></span><br><span class="line">                (<span class="type">void</span>      *)&amp;OSRdyList[OSPrioCur],</span><br><span class="line">                (<span class="type">void</span>      *) <span class="number">0</span>,</span><br><span class="line">                (OS_MSG_SIZE) <span class="number">0u</span>,</span><br><span class="line">                (OS_FLAGS   ) <span class="number">0u</span>,</span><br><span class="line">                (OS_OPT     ) <span class="number">0u</span>,</span><br><span class="line">                (CPU_TS     ) ts,</span><br><span class="line">                (OS_ERR    *)&amp;err);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* 关中断 */</span></span></span><br><span class="line"></span><br><span class="line">   (<span class="type">void</span>)OSTaskSemPost((OS_TCB *)&amp;OSTickTaskTCB,            <span class="comment">/* Signal tick task                                       */</span></span><br><span class="line">                       (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                       (OS_ERR *)&amp;err);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_SCHED_ROUND_ROBIN_EN &gt; 0u <span class="comment">/* 开启时间片轮转 */</span></span></span><br><span class="line">    OS_SchedRoundRobin(&amp;OSRdyList[OSPrioCur]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TMR_EN &gt; 0u <span class="comment">/*定时器启用*/</span></span></span><br><span class="line">    OSTmrUpdateCtr--;</span><br><span class="line">    <span class="keyword">if</span> (OSTmrUpdateCtr == (OS_CTR)<span class="number">0u</span>) &#123;</span><br><span class="line">        OSTmrUpdateCtr = OSTmrUpdateCnt;</span><br><span class="line">        OSTaskSemPost((OS_TCB *)&amp;OSTmrTaskTCB,              <span class="comment">/* Signal timer task                                      */</span></span><br><span class="line">                      (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                      (OS_ERR *)&amp;err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，刚开始就可以调用一个Hook函数，也就是钩子函数（这是用户自己编写的，会在特定的事件到来之际，被调用执行），然后就是向一些任务发送信号量了。</p>
<p>分析一下上面代码的结构，有宏看不懂</p>
<p>下面搜索了下宏</p>
<ul>
<li><strong>OS_CFG_ISR_POST_DEFERRED_EN</strong>：为0时关中断，为1时锁定调度器。</li>
<li><strong>OS_CFG_SCHED_ROUND_ROBIN_EN</strong>：为1时可以使用时间片轮转</li>
<li><strong>OS_CFG_TMR_EN</strong>：为1时启用定时器</li>
</ul>
<p>于是可以分析代码了：</p>
<ul>
<li>对OS_CFG_ISR_POST_DEFERRED_EN的判断：<ul>
<li>若是0：关中断时，唤醒时钟节拍任务</li>
<li>若是1：锁调度器时，把信号量和信号量的接收者的指针暂存到一个队列中去</li>
</ul>
</li>
<li>对OS_CFG_SCHED_ROUND_ROBIN_EN的判断：<ul>
<li>1：进行时间片轮转</li>
</ul>
</li>
<li>对 OS_CFG_TMR_EN的判断：<ul>
<li>1：唤醒定时任务</li>
</ul>
</li>
</ul>
<h3 id="统计任务"><a href="#统计任务" class="headerlink" title="统计任务"></a>统计任务</h3><p>进行一些统计工作，如计算CPU的利用率和任务堆栈的利用率。要想使用统计任务，需要使能一个配置。</p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>定时任务也是可选的，需要使能配置才行。定时任务的目的是：向用户提供定时服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreate((OS_TCB     *)&amp;OSTmrTaskTCB,</span><br><span class="line">             (CPU_CHAR   *)((<span class="type">void</span> *)<span class="string">&quot;uC/OS-III Timer Task&quot;</span>),</span><br><span class="line">             (OS_TASK_PTR )OS_TmrTask,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_PRIO     )OSCfg_TmrTaskPrio,</span><br><span class="line">             (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,</span><br><span class="line">             (OS_MSG_QTY  )<span class="number">0</span>,</span><br><span class="line">             (OS_TICK     )<span class="number">0</span>,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),</span><br><span class="line">             (OS_ERR     *)p_err);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_TmrTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_BOOLEAN          done;</span><br><span class="line">    OS_ERR               err;</span><br><span class="line">    OS_TMR_CALLBACK_PTR  p_fnct;</span><br><span class="line">    OS_TMR_SPOKE        *p_spoke;</span><br><span class="line">    OS_TMR              *p_tmr;</span><br><span class="line">    OS_TMR              *p_tmr_next;</span><br><span class="line">    OS_TMR_SPOKE_IX      spoke;</span><br><span class="line">    CPU_TS               ts;</span><br><span class="line">    CPU_TS               ts_start;</span><br><span class="line">    CPU_TS               ts_end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                               <span class="comment">/* Not using &#x27;p_arg&#x27;, prevent compiler warning       */</span></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        (<span class="type">void</span>)OSTaskSemPend((OS_TICK )<span class="number">0</span>,                         <span class="comment">/* Wait for signal indicating time to update tmrs    */</span></span><br><span class="line">                            (OS_OPT  )OS_OPT_PEND_BLOCKING,</span><br><span class="line">                            (CPU_TS *)&amp;ts,</span><br><span class="line">                            (OS_ERR *)&amp;err);</span><br><span class="line"></span><br><span class="line">        OSSchedLock(&amp;err);</span><br><span class="line">        ts_start = OS_TS_GET();</span><br><span class="line">        OSTmrTickCtr++;                                          <span class="comment">/* Increment the current time                        */</span></span><br><span class="line">        spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);</span><br><span class="line">        p_spoke  = &amp;OSCfg_TmrWheel[spoke];</span><br><span class="line">        p_tmr    = p_spoke-&gt;FirstPtr;</span><br><span class="line">        done     = DEF_FALSE;</span><br><span class="line">        <span class="keyword">while</span> (done == DEF_FALSE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_tmr != (OS_TMR *)<span class="number">0</span>) &#123;</span><br><span class="line">                p_tmr_next = (OS_TMR *)p_tmr-&gt;NextPtr;           <span class="comment">/* Point to next tmr to update because current ...   */</span></span><br><span class="line">                                                                 <span class="comment">/* ... timer could get unlinked from the wheel.      */</span></span><br><span class="line">                <span class="keyword">if</span> (OSTmrTickCtr == p_tmr-&gt;Match) &#123;              <span class="comment">/* Process each timer that expires                   */</span></span><br><span class="line">                    OS_TmrUnlink(p_tmr);                         <span class="comment">/* Remove from current wheel spoke                   */</span></span><br><span class="line">                    <span class="keyword">if</span> (p_tmr-&gt;Opt == OS_OPT_TMR_PERIODIC) &#123;</span><br><span class="line">                        OS_TmrLink(p_tmr,</span><br><span class="line">                                   OS_OPT_LINK_PERIODIC);        <span class="comment">/* Recalculate new position of timer in wheel        */</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p_tmr-&gt;State = OS_TMR_STATE_COMPLETED;   <span class="comment">/* Indicate that the timer has completed             */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p_fnct = p_tmr-&gt;CallbackPtr;                 <span class="comment">/* Execute callback function if available            */</span></span><br><span class="line">                    <span class="keyword">if</span> (p_fnct != (OS_TMR_CALLBACK_PTR)<span class="number">0</span>) &#123;</span><br><span class="line">                        (*p_fnct)((<span class="type">void</span> *)p_tmr,</span><br><span class="line">                                  p_tmr-&gt;CallbackPtrArg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_tmr = p_tmr_next;                          <span class="comment">/* See if next timer matches                         */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    done  = DEF_TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                done = DEF_TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ts_end = OS_TS_GET() - ts_start;                         <span class="comment">/* Measure execution time of timer task              */</span></span><br><span class="line">        OSSchedUnlock(&amp;err);</span><br><span class="line">        <span class="keyword">if</span> (OSTmrTaskTimeMax &lt; ts_end) &#123;</span><br><span class="line">            OSTmrTaskTimeMax = ts_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务，也称定时器，是一个递减的计数器，递减到0时，就会调用用户的回调函数。</p>
<p>我们看代码，发现定时任务的任务函数里面，开始也会的等待一个信号量，他所等待的信号量和时钟节拍任务是一样的，但是信号量的频率好像略慢。</p>
<h3 id="中断服务管理任务"><a href="#中断服务管理任务" class="headerlink" title="中断服务管理任务"></a>中断服务管理任务</h3><p>中断管理任务，OS_IntQTask()，也是一个可选项（使能配置），其目的是：容易得知，进入临界段时，可以选择关中断或者锁调度器，这里就是后者。当锁调度器时，OS会创建一个OS_IntQTask任务，优先级最高，这玩意后面会处理一个队列。比如在ISR中进入临界段，锁调度器，然后使用post发送信号量，这个时候信号量不可达（因为要禁止调度，发信号量可能会唤醒别的任务），然后将信号量sem及目标加入一个特殊的队列中去，当所有的ISR结束后，会启动OS_IntQTask()，将信号量按照顺序发给对应的任务。</p>
<p>为什么要有这么一步操作呢？因为要求在中断中的时间要尽可能短，如果在中断中发信号量唤醒任务，那么需要做以下操作：</p>
<ul>
<li>将任务从等待列表中移除</li>
<li>将任务加入就序列表，进行等待</li>
<li>还有其它操作</li>
</ul>
<p>这就非常麻烦了，与我们要求中断时间尽可能短相悖。</p>
<p>所以，OS_IntQTask()比较重要，所以其优先级为最高任务优先级0，只低于中断。下面看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_IntQTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_BOOLEAN  done;</span><br><span class="line">    CPU_TS       ts_start;</span><br><span class="line">    CPU_TS       ts_end;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                          <span class="comment">/* Not using &#x27;p_arg&#x27;, prevent compiler warning            */</span></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        done = DEF_FALSE;</span><br><span class="line">        <span class="keyword">while</span> (done == DEF_FALSE) &#123;</span><br><span class="line">            CPU_CRITICAL_ENTER();</span><br><span class="line">            <span class="keyword">if</span> (OSIntQNbrEntries == (OS_OBJ_QTY)<span class="number">0u</span>) &#123;</span><br><span class="line">                OSRdyList[<span class="number">0</span>].NbrEntries = (OS_OBJ_QTY)<span class="number">0u</span>;   <span class="comment">/* Remove from ready list                                 */</span></span><br><span class="line">                OSRdyList[<span class="number">0</span>].HeadPtr    = (OS_TCB   *)<span class="number">0</span>;</span><br><span class="line">                OSRdyList[<span class="number">0</span>].TailPtr    = (OS_TCB   *)<span class="number">0</span>;</span><br><span class="line">                OS_PrioRemove(<span class="number">0u</span>);                          <span class="comment">/* Remove from the priority table                         */</span></span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">                OSSched();</span><br><span class="line">                done = DEF_TRUE;                            <span class="comment">/* No more entries in the queue, we are done              */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">                ts_start = OS_TS_GET();</span><br><span class="line">                OS_IntQRePost();</span><br><span class="line">                ts_end   = OS_TS_GET() - ts_start;          <span class="comment">/* Measure execution time of tick task                    */</span></span><br><span class="line">                <span class="keyword">if</span> (OSIntQTaskTimeMax &lt; ts_end) &#123;</span><br><span class="line">                    OSIntQTaskTimeMax = ts_end;</span><br><span class="line">                &#125;</span><br><span class="line">                CPU_CRITICAL_ENTER();</span><br><span class="line">                OSIntQOutPtr = OSIntQOutPtr-&gt;NextPtr;       <span class="comment">/* Point to next item in the ISR queue                    */</span></span><br><span class="line">                OSIntQNbrEntries--;</span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreate((OS_TCB     *)&amp;OSIntQTaskTCB,</span><br><span class="line">             (CPU_CHAR   *)((<span class="type">void</span> *)<span class="string">&quot;uC/OS-III ISR Queue Task&quot;</span>),</span><br><span class="line">             (OS_TASK_PTR )OS_IntQTask,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_PRIO     )<span class="number">0u</span>,                          <span class="comment">/* This task is ALWAYS at priority &#x27;0&#x27; (i.e. highest)     */</span></span><br><span class="line">             (CPU_STK    *)OSCfg_IntQTaskStkBasePtr,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_IntQTaskStkLimit,</span><br><span class="line">             (CPU_STK_SIZE)OSCfg_IntQTaskStkSize,</span><br><span class="line">             (OS_MSG_QTY  )<span class="number">0u</span>,</span><br><span class="line">             (OS_TICK     )<span class="number">0u</span>,</span><br><span class="line">             (<span class="type">void</span>       *)<span class="number">0</span>,</span><br><span class="line">             (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),</span><br><span class="line">             (OS_ERR     *)p_err);</span><br></pre></td></tr></table></figure>

<h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p>在阅读源码时，有个很基本的位置：关于信号量的，不能以下看懂，查书中信号量中的章节也无。遂Google一下：OSTaskSemPend</p>
<p>任务信号量，查到了两张很好的图：</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-26-17-59-41.png"></p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-26-17-58-54.png"></p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-26-18-00-34.png"></p>
<p>其功能分别是：任务信号量的发布，等待，终止。</p>
<h1 id="任务就绪表"><a href="#任务就绪表" class="headerlink" title="任务就绪表"></a>任务就绪表</h1><p> 所有已经等待就绪的任务，其TCB都会放到任务就绪表中去，任务就绪表类似于OS中的就绪队列。</p>
<p>任务就虚表，ready list，包含两个部分:</p>
<ul>
<li>就绪优先级位映射表（OSPrioTbl[]）：里面存着就绪任务的优先级排列，是一个1×(MaxProi-1)的位向量</li>
<li>就绪任务列表（OSReyList[]）：是一个1×(MaxProi-1)的指针数组，指针指向的是对应优先级的就绪任务。</li>
</ul>
<h2 id="就绪优先级位映射表"><a href="#就绪优先级位映射表" class="headerlink" title="就绪优先级位映射表"></a>就绪优先级位映射表</h2><p>这一节看着讲优先级，但是优先级位映射表更多点。我们看看优先级位映射表OSPrioTbl[]长什么样子。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-13-41.png"></p>
<p>上图的OSPrioTbl的元素的位宽是8位，也就是一个字节。每一位代表的都是对应优先级下是否有任务在就绪队列中。</p>
<p>位宽取决于一个叫CPU_DATA的数据元素，在实验代码中我找到了OSPrioTbl的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU_DATA   OSPrioTbl[OS_PRIO_TBL_SIZE];                     <span class="comment">/* Declare the array local to this file to allow for  ... */</span></span><br><span class="line">                                                            <span class="comment">/* ... optimization.  In other words, this allows the ... */</span></span><br><span class="line">                                                            <span class="comment">/* ... table to be located in fast memory                 */</span></span><br></pre></td></tr></table></figure>

<p>还有数据位宽为16为，32为的OSPrioTbl，如下：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-19-10.png"><br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-19-24.png"></p>
<p>是8位32位还是64位取决于CPU的类型。</p>
<p>介绍完优先级位映射表，再看看在其之上有哪些操作：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-21-05.png"></p>
<p>OS_PrioGetHighest()的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*                                           GET HIGHEST PRIORITY TASK WAITING</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Description: This function is called by other uC/OS-III services to determine the highest priority task</span></span><br><span class="line"><span class="comment">*              waiting on the event.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Arguments  : none</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Returns    : The priority of the Highest Priority Task (HPT) waiting for the event</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.</span></span><br><span class="line"><span class="comment">************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">OS_PRIO  <span class="title function_">OS_PrioGetHighest</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_DATA  *p_tbl;</span><br><span class="line">    OS_PRIO    prio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    prio  = (OS_PRIO)<span class="number">0</span>;</span><br><span class="line">    p_tbl = &amp;OSPrioTbl[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (*p_tbl == (CPU_DATA)<span class="number">0</span>) &#123;                         <span class="comment">/* Search the bitmap table for the highest priority       */</span></span><br><span class="line">        prio += DEF_INT_CPU_NBR_BITS;                       <span class="comment">/* Compute the step of each CPU_DATA entry                */</span></span><br><span class="line">        p_tbl++;</span><br><span class="line">    &#125;</span><br><span class="line">    prio += (OS_PRIO)CPU_CntLeadZeros(*p_tbl);              <span class="comment">/* Find the position of the first bit set at the entry    */</span></span><br><span class="line">    <span class="keyword">return</span> (prio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码分析，首先找到第一个不为0的OSPrioTbl元素，因为IDLE的存在，至少有一个是不为0的，所以总有一个最高优先级；然后，找到对应索引下的tbl，找前导零即可：</p>
<p>前导零的计算和CPU有关，可能和硬件有关，所以就不看细节了。</p>
<h2 id="就绪任务列表"><a href="#就绪任务列表" class="headerlink" title="就绪任务列表"></a>就绪任务列表</h2><p>首先看它的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">os_rdy_list</span>          <span class="title">OS_RDY_LIST</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_rdy_list</span> &#123;</span></span><br><span class="line">    OS_TCB              *HeadPtr;                           <span class="comment">/* Pointer to task that will run at selected priority     */</span></span><br><span class="line">    OS_TCB              *TailPtr;                           <span class="comment">/* Pointer to last task          at selected priority     */</span></span><br><span class="line">    OS_OBJ_QTY           NbrEntries;                        <span class="comment">/* Number of entries             at selected priority     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Entries表示的是对应优先级下有几个就绪的任务。</p>
<p>下面看看基于os_rdy_list的一些操作：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-48-32.png"><br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-48-45.png"></p>
<p>首先得到一个空的任务就序列表：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-55-44.png"></p>
<p>然后调用OSInit()进行初始化：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-21-57-00.png"><br>优先级从高到低依次是：</p>
<ul>
<li>中断服务管理任务</li>
<li>时钟节拍任务</li>
<li>定时器任务</li>
<li>统计任务</li>
<li>空闲任务</li>
</ul>
<p>向任务就绪列表中添加任务的过程如下：<br><img src="/2022/05/26/MicroCOS-III/2022-05-28-22-07-03.png"></p>
<h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>这一章的主要任务是看调度器的实现代码。</p>
<h2 id="可剥夺型调度"><a href="#可剥夺型调度" class="headerlink" title="可剥夺型调度"></a>可剥夺型调度</h2><p>当来一个中断时，任务先将自身挂起，然后进入到相应中断的ISR中，最后退出ISR，并调用相关的系统服务（？猜测是调度程序），最后运行优先级最高的任务。</p>
<p>其过程如下:<br><img src="/2022/05/26/MicroCOS-III/2022-05-29-20-25-01.png"></p>
<p>分析下上面这张图：<br>首先一个low priority的任务在跑，然后这时来了一个外设中断（假设是以太网适配器在接收数据帧，产生了一个中断）。这时进入到外设的ISR中，然后ISR完成相应的外设服务（？maybe响应一下，然后可以准备接收数据帧了），最后ISR向一个高优先级的服务该外设的任务发送信号量或者消息，唤醒任务，使其进入就绪态。然后退出ISR，调用系统服务（对应图中的（5），应该是发生了中断调度），然后服务外设的任务上处理机运行。最后外设服务任务完成后，再次调用系统服务（再次调度，任务调度，对应如中（9）），外设服务任务将自身挂起，等待下次为该外设服务。然后处理机回到了我们最开始的低优先级任务。</p>
<p>上面说的是直接发布，如果是延迟发布，略有不同。下面分析延时发布：</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-20-36-07.png"></p>
<p>延时发布是指在ISR总中通过关调度器的方式保护临界区。通过这种方式，在ISR中，我们发布信号量就是延迟发布，也就是把信号量缓存到一个ISR Queue中去，并且使得ISR hander task（中断服务任务）就绪，然后等到退出ISR后，再调用系统服务（对应（2），发生中断调度），然后由于ISR hander task优先级最高，所以他上处理机运行。然后再对被延迟的信号量进行发布并删除（注意这时是在任务态进行的，对应（5）），当ISR hander task运行完后，再调用系统服务进行调度。</p>
<h2 id="调度点"><a href="#调度点" class="headerlink" title="调度点"></a>调度点</h2><p>这一节列举了调度服务会发生的场合，做个简单的归纳</p>
<ul>
<li>任务发送信号量&#x2F;消息</li>
<li>延时函数</li>
<li>任务等待信号量</li>
<li>任务取消等待</li>
<li>创建任务</li>
<li>删除任务</li>
<li>删除内核对象</li>
<li>任务改变自身或其它的优先级</li>
<li>任务自己主动挂起</li>
<li>任务解除挂起</li>
<li>退出所有的ISR Nesting</li>
<li>给调度器解锁</li>
<li>任务放弃时间片</li>
<li>用户通过手动调用调度器</li>
</ul>
<p>具体API查书。</p>
<h2 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h2><ol>
<li>目的</li>
</ol>
<p>时间片轮转调度，当同一优先级的任务有多个时，允许这几个任务一次运行一段时间（也就是一个时间片），然后再轮到下一个。如果任务的时间片没用完，但是任务已经完成，那么可以调用yield来放弃剩余的时间片。</p>
<ol start="2">
<li>条件</li>
</ol>
<p>时间片轮转需要多个任务优先级相同时才发生。同时，需要通过配置一个宏来使能时间片轮转。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-29-11.png"></p>
<h2 id="调度的实现细节"><a href="#调度的实现细节" class="headerlink" title="调度的实现细节"></a>调度的实现细节</h2><p>调度属于一种系统服务。</p>
<p>通过两个函数实现，函数的使用情况分别是任务级和ISR中。</p>
<h3 id="OSSched"><a href="#OSSched" class="headerlink" title="OSSched()"></a>OSSched()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSSched</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* ISRs still nested?                                     */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* Yes ... only schedule when no nested ISRs              */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;        <span class="comment">/* Scheduler locked?                                      */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* Yes                                                    */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_INT_DIS();</span><br><span class="line">    OSPrioHighRdy   = OS_PrioGetHighest();                  <span class="comment">/* Find the highest priority ready                        */</span></span><br><span class="line">    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;</span><br><span class="line">    <span class="keyword">if</span> (OSTCBHighRdyPtr == OSTCBCurPtr) &#123;                   <span class="comment">/* Current task is still highest priority task?           */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes ... no need to context switch                      */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_PROFILE_EN &gt; 0u</span></span><br><span class="line">    OSTCBHighRdyPtr-&gt;CtxSwCtr++;                            <span class="comment">/* Inc. # of context switches to this task                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OSTaskCtxSwCtr++;                                       <span class="comment">/* Increment context switch counter                       */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_CFG_TLS_TBL_SIZE) &amp;&amp; (OS_CFG_TLS_TBL_SIZE &gt; 0u)</span></span><br><span class="line">    OS_TLS_TaskSw();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OS_TASK_SW();                                           <span class="comment">/* Perform a task level context switch                    */</span></span><br><span class="line">    CPU_INT_EN();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>教材上的截图：<br><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-37-45.png"></p>
<p>总的来说差不多：</p>
<ul>
<li>如果OSSched发生在中断或其嵌套中，return</li>
<li>如果调度器被锁，return</li>
<li>如果当前任务不是优先级最高的任务，切换</li>
</ul>
<h3 id="OSIntExit"><a href="#OSIntExit" class="headerlink" title="OSIntExit()"></a>OSIntExit()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSIntExit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSRunning != OS_STATE_OS_RUNNING) &#123;                 <span class="comment">/* Has the OS started?                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* No                                                     */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_INT_DIS();</span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr == (OS_NESTING_CTR)<span class="number">0</span>) &#123;             <span class="comment">/* Prevent OSIntNestingCtr from wrapping                  */</span></span><br><span class="line">        CPU_INT_EN();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OSIntNestingCtr--;</span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* ISRs still nested?                                     */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;        <span class="comment">/* Scheduler still locked?                                */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSPrioHighRdy   = OS_PrioGetHighest();                  <span class="comment">/* Find highest priority                                  */</span></span><br><span class="line">    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     <span class="comment">/* Get highest priority task ready-to-run                 */</span></span><br><span class="line">    <span class="keyword">if</span> (OSTCBHighRdyPtr == OSTCBCurPtr) &#123;                   <span class="comment">/* Current task still the highest priority?               */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_PROFILE_EN &gt; 0u</span></span><br><span class="line">    OSTCBHighRdyPtr-&gt;CtxSwCtr++;                            <span class="comment">/* Inc. # of context switches for this new task           */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OSTaskCtxSwCtr++;                                       <span class="comment">/* Keep track of the total number of ctx switches         */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_CFG_TLS_TBL_SIZE) &amp;&amp; (OS_CFG_TLS_TBL_SIZE &gt; 0u)</span></span><br><span class="line">    OS_TLS_TaskSw();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OSIntCtxSw();                                           <span class="comment">/* Perform interrupt level ctx switch                     */</span></span><br><span class="line">    CPU_INT_EN();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-41-10.png"></p>
<ul>
<li>若中断嵌套为0，表示在任务态，直接return</li>
<li>若中断嵌套大于1，直接return</li>
<li>如果当前任务不是优先级最高的任务，切换</li>
</ul>
<p>OSIntSched发生在最后一层中断嵌套，从ISR恢复到任务态的过程。</p>
<h3 id="OSSchedRoundRobin"><a href="#OSSchedRoundRobin" class="headerlink" title="OSSchedRoundRobin()"></a>OSSchedRoundRobin()</h3><p>当当前任务的时间片用完，并且同一优先级下有多个任务时，运行时间片轮转调度。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-47-37.png"><br><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-51-20.png"></p>
<h1 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h1><p>任务切换（context switch，也就是CPU运行环境切换）。</p>
<p>任务切换会带来系统开销，上下文切换，需要保存CPU当前的运行环境，也就是各个寄存器的值。每个寄存器都是32bit位宽的存储器。有三个特殊的，如下：</p>
<ul>
<li>R14_1：TSP，task stack pointer</li>
<li>R14_2：ISP，ISR stack pointer</li>
<li>R15：PC</li>
<li>SR：status register</li>
</ul>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-21-59-02.png"></p>
<p>这一章的概念中提及了中断堆栈和任务堆栈，其中ISR就是指向中断堆栈的栈顶的。当CPU发生中断时，会自动切换到中断堆栈中去。另外，中断堆栈和任务堆栈是可以互相访问的。</p>
<p>一个就绪的任务看上去就好像刚发生中断一样，其任务堆栈的栈顶看着全部都是寄存器（就算是刚创建的，进入就绪态的任务，也是这样的，是通过软件来进行堆栈的初始化的。）</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-29-22-15-55.png"></p>
<p>PC和SR是在发生中断时，是自动（硬件）保存的，也就是最先压入寄存器的，而另外几个都是软件方式压入的，而R14（SP，stack pointer）则不同，他不用压入堆栈，而是直接保存到TCB中去</p>
<p>下面讨论任务级的切换和中断级的切换的具体细节。</p>
<ul>
<li>任务及切换：OSCtxSw()</li>
<li>中断级切换：OSIntCtxSw()</li>
</ul>
<h2 id="OSCtxSw"><a href="#OSCtxSw" class="headerlink" title="OSCtxSw()"></a>OSCtxSw()</h2><p>通过汇编实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;********************************************************************************************************</span><br><span class="line">;                       PERFORM A CONTEXT SWITCH (From task level) - OSCtxSw()</span><br><span class="line">;</span><br><span class="line">; Note(s) : 1) OSCtxSw() is called when OS wants to perform a task context switch.  This function</span><br><span class="line">;              triggers the PendSV exception which is where the real work is done.</span><br><span class="line">;********************************************************************************************************</span><br><span class="line"></span><br><span class="line">OSCtxSw</span><br><span class="line">    LDR     R0, =NVIC_INT_CTRL                                  ; Trigger the PendSV exception (causes context switch)</span><br><span class="line">    LDR     R1, =NVIC_PENDSVSET</span><br><span class="line">    STR     R1, [R0]</span><br><span class="line">    BX      LR</span><br></pre></td></tr></table></figure>

<p>下面看看当发生任务切换时的过程。</p>
<p>首先是当操作系统知道有一个优先级更高的任务在就绪队列，然后这是这两个任务及CPU的状态：<br><img src="/2022/05/26/MicroCOS-III/2022-05-29-22-33-41.png"></p>
<p>然后进行任务切换后的图：<br><img src="/2022/05/26/MicroCOS-III/2022-05-29-22-34-34.png"></p>
<p>可以看到，在保存第一个任务的现场时，首先讲SR和PC压入任务堆栈，然后再压入R0~R13，最后将TCB中的.StkPtr指向R13，也就是我们任务堆栈的栈顶，这时任务1的上下文保护结束。</p>
<p>然后可以开始恢复高优先级的任务2了，首先根据TCB中的StkPtr，找到任务堆栈中的栈顶（因为任务堆栈是RAM中的一块随机的区域，只能通过TCB，才能知道堆栈的相关信息，并进行堆栈的恢复），然后开始弹出寄存器，进行恢复现场。</p>
<h2 id="OSIntCtxSw"><a href="#OSIntCtxSw" class="headerlink" title="OSIntCtxSw()"></a>OSIntCtxSw()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;********************************************************************************************************</span><br><span class="line">;                   PERFORM A CONTEXT SWITCH (From interrupt level) - OSIntCtxSw()</span><br><span class="line">;</span><br><span class="line">; Note(s) : 1) OSIntCtxSw() is called by OSIntExit() when it determines a context switch is needed as</span><br><span class="line">;              the result of an interrupt.  This function simply triggers a PendSV exception which will</span><br><span class="line">;              be handled when there are no more interrupts active and interrupts are enabled.</span><br><span class="line">;********************************************************************************************************</span><br><span class="line"></span><br><span class="line">OSIntCtxSw</span><br><span class="line">    LDR     R0, =NVIC_INT_CTRL                                  ; Trigger the PendSV exception (causes context switch)</span><br><span class="line">    LDR     R1, =NVIC_PENDSVSET</span><br><span class="line">    STR     R1, [R0]</span><br><span class="line">    BX      LR</span><br></pre></td></tr></table></figure>

<p>当OSIntExit()（按字面意思是OS中断退出，确实如此，但我们翻译为中断调度器），确定有一个更高优先级的任务就绪时，就会调用OSCtxSw()（os context switch）</p>
<p>下面看过程图：<br><img src="/2022/05/26/MicroCOS-III/2022-05-29-22-42-48.png"><br><img src="/2022/05/26/MicroCOS-III/2022-05-29-22-43-04.png"></p>
<p>由于低优先级任务在进入ISR前，已经保存了各个寄存器的状态，所以本次上下文切换，无需保存低优先级任务的现场，只需要恢复高优先级的现场即可。</p>
<h1 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h1><p>这一章讲中断，中断是一种硬件机制，对比之前无OS时的轮询，中断这种机制能够大大增加系统的实时性。当来一个中断时，系统需要响应这个中断，具体就是先保存当前任务的现场，然后进入到一个特殊的函数中去，响应中断，也就是所谓的ISR，如果还需进行一些额外的任务，那么就需要在退出ISR前，唤醒一个较高优先级的服务任务，然后在任务中去进行操作，这样能够减少中断的复杂性，把复杂的任务留给让你无。</p>
<p>中断的流程：<br><img src="/2022/05/26/MicroCOS-III/2022-05-30-11-24-33.png"></p>
<p>中断有几个性能指标：</p>
<ul>
<li>中断响应时间：中断被识别到CPU到开始执行ISR中的代码</li>
<li>中断恢复时间：ISR结束时，到开始下一个任务之间的gap（主要取决于系统服务，也就是调度器的执行效率），下一个任务可以是被中断的任务，也可以是被调度器选择的优先级更高的任务</li>
<li>中断等待时间：从进入ISR开始，到再次执行任务为止。</li>
</ul>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-30-11-27-52.png"></p>
<p>如上图，很多都是外设产生的中断，这个时候，ISR负责响应中断，和唤醒响应的外设服务任务。</p>
<p>并且，真正首先接收到硬件中断请求的是“中断控制器”，中断控制器负责接收不同优先级的中断请求，并将优先级最高的中断请求输出出去。</p>
<p>然后就是中断开关了，若用户禁止中断，那么CPU就接收不到中断了。</p>
<h2 id="典型的ISR"><a href="#典型的ISR" class="headerlink" title="典型的ISR"></a>典型的ISR</h2><p>由于ISR在开发板的Rom中，所以我们看不到源码，这里截取书上的伪代码分析：<br><img src="/2022/05/26/MicroCOS-III/2022-05-30-11-42-06.png"></p>
<p>进入中断前，调用了OSIntEnter，先进行一些健壮性的判断，然后再自增OSIntNestingCtr，嵌套层数加一。可以看到，最多只支持250层的嵌套。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSIntEnter</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (OSRunning != OS_STATE_OS_RUNNING) &#123;                 <span class="comment">/* Is OS running?                                         */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* No                                                     */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt;= (OS_NESTING_CTR)<span class="number">250u</span>) &#123;          <span class="comment">/* Have we nested past 250 levels?                        */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* Yes                                                    */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSIntNestingCtr++;                                      <span class="comment">/* Increment ISR nesting level                            */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而出中断前，也会调用对应的OSIntExit，也就是我们之前看过的“调度的实现细节”中的中断调度，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSIntExit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSRunning != OS_STATE_OS_RUNNING) &#123;                 <span class="comment">/* Has the OS started?                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;                                             <span class="comment">/* No                                                     */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_INT_DIS();</span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr == (OS_NESTING_CTR)<span class="number">0</span>) &#123;             <span class="comment">/* Prevent OSIntNestingCtr from wrapping                  */</span></span><br><span class="line">        CPU_INT_EN();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OSIntNestingCtr--;</span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* ISRs still nested?                                     */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;        <span class="comment">/* Scheduler still locked?                                */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSPrioHighRdy   = OS_PrioGetHighest();                  <span class="comment">/* Find highest priority                                  */</span></span><br><span class="line">    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     <span class="comment">/* Get highest priority task ready-to-run                 */</span></span><br><span class="line">    <span class="keyword">if</span> (OSTCBHighRdyPtr == OSTCBCurPtr) &#123;                   <span class="comment">/* Current task still the highest priority?               */</span></span><br><span class="line">        CPU_INT_EN();                                       <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_PROFILE_EN &gt; 0u</span></span><br><span class="line">    OSTCBHighRdyPtr-&gt;CtxSwCtr++;                            <span class="comment">/* Inc. # of context switches for this new task           */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OSTaskCtxSwCtr++;                                       <span class="comment">/* Keep track of the total number of ctx switches         */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_CFG_TLS_TBL_SIZE) &amp;&amp; (OS_CFG_TLS_TBL_SIZE &gt; 0u)</span></span><br><span class="line">    OS_TLS_TaskSw();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OSIntCtxSw();                                           <span class="comment">/* Perform interrupt level ctx switch                     */</span></span><br><span class="line">    CPU_INT_EN();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 下面分析下这个伪代码的整个执行流程：</p>
<ul>
<li>关中断</li>
<li>保护现场（注意，有的CPU支持中断堆栈，保护现场后就切换到中断堆栈，这样可以节省宝贵的任务堆栈空间。但MicroC&#x2F;OS不支持中断堆栈，所以ISR还是使用的任务的堆栈空间）。</li>
<li>然后中断嵌套层数自增，若是第一层嵌套，还需要修改当前任务的TCB的指针（把TSP保存到TCB中去，这步以后，当前任务的现场保护完毕）</li>
<li>再清除中断请求</li>
<li>开中断（若支持中断嵌套，需要打开这个）</li>
<li>然后可以调用用户自己写的中断处理程序（ISR hander），来完成一些用户自定的工作，要求是越精简越好</li>
<li>最后整个系统的中断服务程序就结束了，调用OSIntExit，来选择是否调度还是退到上一层的嵌套中</li>
<li>最后恢复现场</li>
<li>退出中断</li>
</ul>
<h2 id="无需内核参与的ISR"><a href="#无需内核参与的ISR" class="headerlink" title="无需内核参与的ISR"></a>无需内核参与的ISR</h2><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-19-27-42.png"></p>
<p>这是一个短的ISR，如果一个中断对应的ISR很短的话，需要处理的东西比较简单，可以考虑这样做，把其优先级设置的很高，这样就优先响应这个中断，并且中断的持续时间很短。</p>
<p>保留了：关中断，上下文切换，调用用户的ISR。</p>
<p>强调了一定不能开中断。</p>
<h2 id="多中断优先级的处理器"><a href="#多中断优先级的处理器" class="headerlink" title="多中断优先级的处理器"></a>多中断优先级的处理器</h2><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-19-30-41.png"></p>
<p>中断的优先级是数值越大越好，和任务的优先级相反。</p>
<p>比较特殊的是，中断优先级为0~11的全部关了（仅在此例中。）因为这些中断需要发消息信号量等操作，为了保护临界区，需要关掉这些中断。</p>
<h2 id="所有中断源共用中断服务程序"><a href="#所有中断源共用中断服务程序" class="headerlink" title="所有中断源共用中断服务程序"></a>所有中断源共用中断服务程序</h2><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-19-41-32.png"></p>
<p>大概就是写一个C函数，是一个while循环，作为所有中断源共用的中断服务程序。当中断控制器中有中断请求时（中断控制器能够对到来的中断进行排序），这个共用中断服务函数会得到这个中断请求设备的interrupt hander的入口地址（也就是向量表中的地址），或者是向量表的索引，然后执行interrupt handler。</p>
<p>一旦中断控制器中无中断时，循环结束。</p>
<p>这种机制有缺点，会使所有的interrupt的等待时间达到最长。</p>
<h2 id="每个中断源都有专门的中断服务程序"><a href="#每个中断源都有专门的中断服务程序" class="headerlink" title="每个中断源都有专门的中断服务程序"></a>每个中断源都有专门的中断服务程序</h2><p>每个interrupt对应一个中断服务程序。</p>
<p>当来interrupt时，根据预设的向量表，跳到对应的中断服务程序，再跳到ISR handler中去。</p>
<h2 id="直接发布和延迟发布"><a href="#直接发布和延迟发布" class="headerlink" title="直接发布和延迟发布"></a>直接发布和延迟发布</h2><h3 id="直接发布"><a href="#直接发布" class="headerlink" title="直接发布"></a>直接发布</h3><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-20-01-51.png"></p>
<p>是否直接发布取决于关中断的事件，若是关中断的事件过长，那么中断就长时间得不到响应。</p>
<p>具体流程如下：</p>
<ul>
<li>hardware devices产生中断（电信号）</li>
<li>中断控制器接收到中断信号，并且CPU是开中断，这时进入中断服务程序中</li>
<li>中断服务程序在做必要的检查，以及保护现场后，提供中断服务（use interrupt handler），这时会唤醒一个为hardware devices提供服务的任务</li>
<li>根据唤醒的任务的优先级来选择是否进行调度</li>
</ul>
<p>当宏OS_CFG_ISR_POST_DEFERRED_EN为0时，表示通过关中断保护临界区，这时使用的是直接发布，在ISR中就唤醒了任务（将TCB从挂起队列删除，从就绪队列添加等操作，麻烦！）</p>
<h3 id="延迟发布"><a href="#延迟发布" class="headerlink" title="延迟发布"></a>延迟发布</h3><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-20-13-45.png"></p>
<p>延迟发布是当调度器上锁时使用，也就是设置宏OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1时。</p>
<p>下面还是先分析具体过程：</p>
<ul>
<li>hardware devices产生中断信号</li>
<li>中断控制器接收到信号</li>
<li>进入中断服务程序</li>
<li>发现锁了调度器，所以是延迟发布，那么该ISR的提供的interrupt handler就不是通过发信号量唤醒外设服务任务了，而是调用系统的发布服务函数向interrupt queue缓存这两个东西：1.发布信号量的发布函数调用。2.发布函数调用中需要传入的相关参数。</li>
<li>然后ISR结束，结束前，会调用OSIntExit()，如果是最后一层nesting，那么就会进行一次调度，即退出中断前的调度。</li>
<li>然后是短暂的系统服务（还未知是干嘛）</li>
<li>接下来就是优先级最高的任务OSIntQTask得到处理机运行，分别调用interrupt queue中的发布函数调用，并传入相关参数，来进行发布信号量或者消息，来唤醒相关任务（<strong>PS：这里仍然需要关中断，以防止有ISR来同时对interrupt queue进行修改，这里就巧妙的在任务里面完成了对临界区的访问</strong>）。</li>
<li>最后OSIntQTask发布完毕后，进行一次调度。</li>
</ul>
<p>PS：书上在调度的具体实现里，将OSIntQTask翻译成中断服务管理任务，我觉得不太准确，还是翻译成“系统中断队列（管理）任务”比较符合它的功能</p>
<ul>
<li>优点：减小了中断延迟，响应和恢复的时间</li>
<li>缺点：增大了（外设服务）任务延时时间</li>
</ul>
<h2 id="两种发布的对比"><a href="#两种发布的对比" class="headerlink" title="两种发布的对比"></a>两种发布的对比</h2><p><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-18-53.png"></p>
<h2 id="时钟节拍"><a href="#时钟节拍" class="headerlink" title="时钟节拍"></a>时钟节拍</h2><p>时钟节拍是系统的心跳，时钟节拍频率越高，系统的额外开销越大。</p>
<p>一般而言需要给系统提供一个10~1000M的硬件定时器产生周期性的定时中断，作为所需要的时钟节拍。</p>
<p>时钟中断的ISR中必须调用一个OSTimeTick函数，直译过来就是“系统时钟节拍”函数</p>
<p>这在系统任务的时钟节拍任务里也有所提及，前面已经分析过了，这里就不做分析了。</p>
<p>但是我们看一下OS_IntQPost这个函数（中断队列发布）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_IntQPost</span> <span class="params">(OS_OBJ_TYPE   type,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span>         *p_obj,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span>         *p_void,</span></span><br><span class="line"><span class="params">                   OS_MSG_SIZE   msg_size,</span></span><br><span class="line"><span class="params">                   OS_FLAGS      flags,</span></span><br><span class="line"><span class="params">                   OS_OPT        opt,</span></span><br><span class="line"><span class="params">                   CPU_TS        ts,</span></span><br><span class="line"><span class="params">                   OS_ERR       *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (OSIntQNbrEntries &lt; OSCfg_IntQSize) &#123;                <span class="comment">/* Make sure we haven&#x27;t already filled the ISR queue      */</span></span><br><span class="line">        OSIntQNbrEntries++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OSIntQNbrEntriesMax &lt; OSIntQNbrEntries) &#123;</span><br><span class="line">            OSIntQNbrEntriesMax = OSIntQNbrEntries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OSIntQInPtr-&gt;Type       = type;                     <span class="comment">/* Save object type being posted                          */</span></span><br><span class="line">        OSIntQInPtr-&gt;ObjPtr     = p_obj;                    <span class="comment">/* Save pointer to object being posted                    */</span></span><br><span class="line">        OSIntQInPtr-&gt;MsgPtr     = p_void;                   <span class="comment">/* Save pointer to message if posting to a message queue  */</span></span><br><span class="line">        OSIntQInPtr-&gt;MsgSize    = msg_size;                 <span class="comment">/* Save the message size   if posting to a message queue  */</span></span><br><span class="line">        OSIntQInPtr-&gt;Flags      = flags;                    <span class="comment">/* Save the flags if posting to an event flag group       */</span></span><br><span class="line">        OSIntQInPtr-&gt;Opt        = opt;                      <span class="comment">/* Save post options                                      */</span></span><br><span class="line">        OSIntQInPtr-&gt;TS         = ts;                       <span class="comment">/* Save time stamp                                        */</span></span><br><span class="line"></span><br><span class="line">        OSIntQInPtr             =  OSIntQInPtr-&gt;NextPtr;    <span class="comment">/* Point to the next interrupt handler queue entry        */</span></span><br><span class="line"></span><br><span class="line">        OSRdyList[<span class="number">0</span>].NbrEntries = (OS_OBJ_QTY)<span class="number">1</span>;            <span class="comment">/* Make the interrupt handler task ready to run           */</span></span><br><span class="line">        OSRdyList[<span class="number">0</span>].HeadPtr    = &amp;OSIntQTaskTCB;</span><br><span class="line">        OSRdyList[<span class="number">0</span>].TailPtr    = &amp;OSIntQTaskTCB;</span><br><span class="line">        OS_PrioInsert(<span class="number">0u</span>);                                  <span class="comment">/* Add task priority 0 in the priority table              */</span></span><br><span class="line">        <span class="keyword">if</span> (OSPrioCur != <span class="number">0</span>) &#123;                               <span class="comment">/* Chk if OSIntQTask is not running                       */</span></span><br><span class="line">            OSPrioSaved         = OSPrioCur;                <span class="comment">/* Save current priority                                  */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       *p_err                   = OS_ERR_NONE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        OSIntQOvfCtr++;                                     <span class="comment">/* Count the number of ISR queue overflows                */</span></span><br><span class="line">       *p_err                   = OS_ERR_INT_Q_FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    CPU_CRITICAL_EXIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浅层次分析一波：</p>
<ul>
<li>首先关中断，避免出现ISR修改interrupt queue</li>
<li>然后在确保队列没有满</li>
<li>再才是对队列进行插入操作</li>
<li>然后比较“奇葩”的一点，现在是处于ISR中，直接手动的将我们的OSIntQTask的TCB插入到就绪队列中去了，也就是说手动唤醒“OSIntQTask”</li>
</ul>
<h1 id="任务挂起表"><a href="#任务挂起表" class="headerlink" title="任务挂起表"></a>任务挂起表</h1><p>这一章了解一下任务挂起表，pend lists 或者 wait lists</p>
<p>任务挂起表有很多个，任务的挂起可能是由于多个任务：</p>
<ul>
<li>等待信号量sem</li>
<li>等待互斥信号量mutex</li>
<li>等待标志组</li>
<li>等待消息队列</li>
</ul>
<p>由于有多个任务，于是就需要进行一个基本的排队操作，有pend lists这种数据结构完成。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-47-53.png"></p>
<p>任务挂起表的数据结构是：OS_PEND_LIST</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-50-04.png"></p>
<p>含有三个字段：</p>
<ul>
<li>NbrEntries：等待表中的表项数目</li>
<li>TailPtr：指向优先级最低的任务</li>
<li>HeadPtr：指向优先级最高的任务</li>
</ul>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-52-43.png"></p>
<p>pend list和 ready list不同，他指向的不是任务的TCB，而是另一种数据结构OS_PEND_DATA<br><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-54-05.png"></p>
<p>原因是，其不止需要指明pend task的TCB，还需要知道task等待的内核对象，并且有的对象可能已经就绪，还有消息等。</p>
<p>还是挺重要的，这里还是列举一下：</p>
<ul>
<li>PrevPtr</li>
<li>NextPtr</li>
<li>TCBPtr</li>
<li>PendObjPtr</li>
<li>RdyObjPtr</li>
<li>RdyMsgPtr</li>
<li>RdyMsgSize</li>
<li>RdyTS</li>
</ul>
<p><img src="/2022/05/26/MicroCOS-III/2022-05-30-23-59-43.png"></p>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><p><img src="/2022/05/26/MicroCOS-III/2022-06-05-21-26-44.png"></p>
<h2 id="OSTimeDly"><a href="#OSTimeDly" class="headerlink" title="OSTimeDly()"></a>OSTimeDly()</h2><p>函数功能：调用该函数的任务会延时指定时间，有三种模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSTimeDly</span> <span class="params">(OS_TICK   dly, <span class="comment">// 指定延时的时间片</span></span></span><br><span class="line"><span class="params">                 OS_OPT    opt, <span class="comment">// 指定调用这个函数的模式</span></span></span><br><span class="line"><span class="params">                 OS_ERR   *p_err)</span> <span class="comment">// 返回错误代码</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;             <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_TIME_DLY_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;       <span class="comment">/* Can&#x27;t delay when the scheduler is locked               */</span></span><br><span class="line">       *p_err = OS_ERR_SCHED_LOCKED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_DLY: <span class="comment">// 相对模式</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_TIMEOUT: <span class="comment">// 绝对模式</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_PERIODIC: <span class="comment">// 周期模式</span></span><br><span class="line">             <span class="keyword">if</span> (dly == (OS_TICK)<span class="number">0u</span>) &#123;                      <span class="comment">/* 0 means no delay!                                      */</span></span><br><span class="line">                *p_err = OS_ERR_TIME_ZERO_DLY;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_MATCH:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER();</span><br><span class="line">    OSTCBCurPtr-&gt;TaskState = OS_TASK_STATE_DLY;</span><br><span class="line">    OS_TickListInsert(OSTCBCurPtr,</span><br><span class="line">                      dly,</span><br><span class="line">                      opt,</span><br><span class="line">                      p_err);</span><br><span class="line">    <span class="keyword">if</span> (*p_err != OS_ERR_NONE) &#123;</span><br><span class="line">         OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OS_RdyListRemove(OSTCBCurPtr);                          <span class="comment">/* Remove current task from ready list                    */</span></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">    OSSched();                                              <span class="comment">/* Find next task to run!                                 */</span></span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是相对模式下的运行流程：<br><img src="/2022/05/26/MicroCOS-III/2022-06-05-21-42-38.png"></p>
<p>具体分析一下：（Tick时钟中断，ALL HPTs值得是所有高优先级的任务，LPT是我们的低优先级任务）</p>
<ul>
<li>首先是一个时间片来到（1），然后产生时钟中断，然后进入到时钟节拍的ISR中去，不管是关中断还是锁调度器（出ISR会运行中断队列服务函数），最终都会将信号量发送给时钟节拍任务（较高优先级），然后然后节拍任务进行延时，超时任务的更新。然后再是其它低优先级的任务的运行。</li>
<li>我们的LPT得到处理机（3），并且运行一段时间后，想要延时2个Tick，调用了OSTimeDly，以相对模式延时两个Tick，这时LPT将会将自己放入一个pend list里面，等待2个时钟节拍。</li>
<li>然后过了一段时间，第一个时钟节拍来了，一些HPT得到执行（指OSTickTask，OSIntQTask等），OSTickTask对pend list里的任务进行更新，此时LPT还需等待一个Tick（注意，LPT其实并没有延时Tick，比一个Tick要短）</li>
<li>然后再过了一个完整的Tick（7），其实还是有一些HPT得到运行，只不过图中没有强调，而是特意指出了：LPT等到了最后一个Tick（也是OSTickTask进行更新的，若是最后一个Tick，应该将自己从pend list里移除，然后加入rdy list，再进行一次OSSche调度），然后得到了处理机，延时结束！</li>
</ul>
<p>从上面看出，在相对模式下，并不能精确的延时两个时钟周期。</p>
<p>然后是周期模式：<br><img src="/2022/05/26/MicroCOS-III/2022-06-05-22-04-03.png"></p>
<p>周期模式可能在刚开始的第一个周期不准，但是后面都是准的。比较容易理解</p>
<p>绝对模式用的少，上电后10s关闭某个灯，没有具体的分析。</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-06-05-22-06-15.png"></p>
<h2 id="OSTimeDlyHMSM"><a href="#OSTimeDlyHMSM" class="headerlink" title="OSTimeDlyHMSM()"></a>OSTimeDlyHMSM()</h2><p>延时具体的时分秒毫秒。</p>
<p>该函数的工作模式仅有相对模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSTimeDlyHMSM</span> <span class="params">(CPU_INT16U   hours,</span></span><br><span class="line"><span class="params">                     CPU_INT16U   minutes,</span></span><br><span class="line"><span class="params">                     CPU_INT16U   seconds,</span></span><br><span class="line"><span class="params">                     CPU_INT32U   milli,</span></span><br><span class="line"><span class="params">                     OS_OPT       opt, </span></span><br><span class="line"><span class="params">                     <span class="comment">// OS_OPT_TIME_HMSM_STRICT，将检查延时参数的有效性,H: 0-99; M: 0-59; S: 0-59; M: 0-999</span></span></span><br><span class="line"><span class="params">                     <span class="comment">// OS_OPT_TIME_HMSM_NON_STRICT，不检查延时参数，只要不超过限制即可。</span></span></span><br><span class="line"><span class="params">                     OS_ERR      *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    CPU_BOOLEAN  opt_invalid;</span><br><span class="line">    CPU_BOOLEAN  opt_non_strict;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OS_OPT       opt_time;</span><br><span class="line">    OS_RATE_HZ   tick_rate;</span><br><span class="line">    OS_TICK      ticks;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;             <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_TIME_DLY_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;       <span class="comment">/* Can&#x27;t delay when the scheduler is locked               */</span></span><br><span class="line">       *p_err = OS_ERR_SCHED_LOCKED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opt_time = opt &amp; OS_OPT_TIME_MASK;                      <span class="comment">/* Retrieve time options only.                            */</span></span><br><span class="line">    <span class="keyword">switch</span> (opt_time) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_DLY:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_PERIODIC:</span><br><span class="line">             <span class="keyword">if</span> (milli == (CPU_INT32U)<span class="number">0u</span>) &#123;                 <span class="comment">/* Make sure we didn&#x27;t specify a 0 delay                  */</span></span><br><span class="line">                 <span class="keyword">if</span> (seconds == (CPU_INT16U)<span class="number">0u</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (minutes == (CPU_INT16U)<span class="number">0u</span>) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (hours == (CPU_INT16U)<span class="number">0u</span>) &#123;</span><br><span class="line">                            *p_err = OS_ERR_TIME_ZERO_DLY;</span><br><span class="line">                             <span class="keyword">return</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_TIME_MATCH:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u                                  <span class="comment">/* Validate arguments to be within range                  */</span></span></span><br><span class="line">    opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);</span><br><span class="line">    <span class="keyword">if</span> (opt_invalid == DEF_YES) &#123;</span><br><span class="line">       *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);</span><br><span class="line">    <span class="keyword">if</span> (opt_non_strict != DEF_YES) &#123;</span><br><span class="line">         <span class="keyword">if</span> (milli   &gt; (CPU_INT32U)<span class="number">999u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (seconds &gt; (CPU_INT16U)<span class="number">59u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_SECONDS;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (minutes &gt; (CPU_INT16U)<span class="number">59u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_MINUTES;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (hours   &gt; (CPU_INT16U)<span class="number">99u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_HOURS;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (minutes &gt; (CPU_INT16U)<span class="number">9999u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_MINUTES;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (hours   &gt; (CPU_INT16U)<span class="number">999u</span>) &#123;</span><br><span class="line">            *p_err = OS_ERR_TIME_INVALID_HOURS;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                                                            <span class="comment">/* Compute the total number of clock ticks required..     */</span></span><br><span class="line">                                                            <span class="comment">/* .. (rounded to the nearest tick)                       */</span></span><br><span class="line">    tick_rate = OSCfg_TickRate_Hz;</span><br><span class="line">    ticks     = ((OS_TICK)hours * (OS_TICK)<span class="number">3600u</span> + (OS_TICK)minutes * (OS_TICK)<span class="number">60u</span> + (OS_TICK)seconds) * tick_rate</span><br><span class="line">              + (tick_rate * ((OS_TICK)milli + (OS_TICK)<span class="number">500u</span> / tick_rate)) / (OS_TICK)<span class="number">1000u</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks &gt; (OS_TICK)<span class="number">0u</span>) &#123;</span><br><span class="line">        OS_CRITICAL_ENTER();</span><br><span class="line">        OSTCBCurPtr-&gt;TaskState = OS_TASK_STATE_DLY;</span><br><span class="line">        OS_TickListInsert(OSTCBCurPtr,</span><br><span class="line">                          ticks,</span><br><span class="line">                          opt_time,</span><br><span class="line">                          p_err);</span><br><span class="line">        <span class="keyword">if</span> (*p_err != OS_ERR_NONE) &#123;</span><br><span class="line">             OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OS_RdyListRemove(OSTCBCurPtr);                      <span class="comment">/* Remove current task from ready list                    */</span></span><br><span class="line">        OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">        OSSched();                                          <span class="comment">/* Find next task to run!                                 */</span></span><br><span class="line">       *p_err = OS_ERR_NONE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       *p_err = OS_ERR_TIME_ZERO_DLY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其opt中的限制模式说明下，小时的延时为啥最大是999小时。原因是：通常设置一个32位的计数器来跟踪时钟节拍，如果时钟节拍的频率是1000HZ，那么32位的整数可以记录：2^32&#x2F;1000&#x3D;4294967s&#x3D;1193H，所以将H的限制设置在999，也是合理的。</p>
<h2 id="OSTimeDlyResume"><a href="#OSTimeDlyResume" class="headerlink" title="OSTimeDlyResume()"></a>OSTimeDlyResume()</h2><p>使用该函数可以恢复其它调用了OSTimeDly或OSTimeDlyHMSM的任务。并且：<strong>延时的任务并不知道他是被其它任务恢复的，他以为自己到了延时的时间了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSTimeDlyResume</span> <span class="params">(OS_TCB  *p_tcb,</span></span><br><span class="line"><span class="params">                       OS_ERR  *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;             <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_TIME_DLY_RESUME_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_tcb == (OS_TCB *)<span class="number">0</span>) &#123;                             <span class="comment">/* Not possible for the running task to be delayed!       */</span></span><br><span class="line">       *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (p_tcb == OSTCBCurPtr) &#123;                             <span class="comment">/* Not possible for the running task to be delayed!       */</span></span><br><span class="line">       *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (p_tcb-&gt;TaskState) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_RDY:                             <span class="comment">/* Cannot Abort delay if task is ready                    */</span></span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_DLY:</span><br><span class="line">             OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();</span><br><span class="line">             p_tcb-&gt;TaskState = OS_TASK_STATE_RDY;</span><br><span class="line">             OS_TickListRemove(p_tcb);                      <span class="comment">/* Remove task from tick list                             */</span></span><br><span class="line">             OS_RdyListInsert(p_tcb);                       <span class="comment">/* Add to ready list                                      */</span></span><br><span class="line">             OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">            *p_err = OS_ERR_NONE;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_PEND:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_SUSPENDED:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_DLY_SUSPENDED:</span><br><span class="line">             OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();</span><br><span class="line">             p_tcb-&gt;TaskState = OS_TASK_STATE_SUSPENDED;</span><br><span class="line">             OS_TickListRemove(p_tcb);                      <span class="comment">/* Remove task from tick list                             */</span></span><br><span class="line">             OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">            *p_err            = OS_ERR_TASK_SUSPENDED;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_PEND_SUSPENDED:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_TASK_NOT_DLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_STATE_INVALID;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSched();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像金手指一样，只需要传进待恢复任务的TCB即可。</p>
<p>看看实现的细节switch的那一部分：</p>
<ul>
<li>不允许在ISR中恢复任务</li>
<li>首先检查TCB，如果是0代表当前任务，当前运行的任务肯定不是延时的，所以直接err</li>
<li>然后检查TCB的state，什么状态执行什么操作，细节看代码</li>
<li>最后发起任务调度OSSched</li>
</ul>
<p>明确下，任务delay后，进入的不是pend list，而是tick list，下面看看具体的tick list</p>
<p>我们先得看下从tick list中移除TCB的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_TickListRemove</span> <span class="params">(OS_TCB  *p_tcb)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_TICK_SPOKE  *p_spoke;</span><br><span class="line">    OS_TCB         *p_tcb1;</span><br><span class="line">    OS_TCB         *p_tcb2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_spoke = p_tcb-&gt;TickSpokePtr; <span class="comment">// 指向时基列表数组的指针，即用来指示该任务 TCB 属于哪条双向链表。</span></span><br><span class="line">    <span class="keyword">if</span> (p_spoke != (OS_TICK_SPOKE *)<span class="number">0</span>) &#123;                              <span class="comment">/* Confirm that task is in tick list            */</span></span><br><span class="line">        p_tcb-&gt;TickRemain = (OS_TICK)<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">if</span> (p_spoke-&gt;FirstPtr == p_tcb) &#123;                             <span class="comment">/* Is timer to remove at the beginning of list? */</span></span><br><span class="line">            p_tcb1            = (OS_TCB *)p_tcb-&gt;TickNextPtr;         <span class="comment">/* Yes                                          */</span></span><br><span class="line">            p_spoke-&gt;FirstPtr = p_tcb1;</span><br><span class="line">            <span class="keyword">if</span> (p_tcb1 != (OS_TCB *)<span class="number">0</span>) &#123;</span><br><span class="line">                p_tcb1-&gt;TickPrevPtr = (OS_TCB *)<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p_tcb1              = p_tcb-&gt;TickPrevPtr;                 <span class="comment">/* No, remove timer from somewhere in the list  */</span></span><br><span class="line">            p_tcb2              = p_tcb-&gt;TickNextPtr;</span><br><span class="line">            p_tcb1-&gt;TickNextPtr = p_tcb2;</span><br><span class="line">            <span class="keyword">if</span> (p_tcb2 != (OS_TCB *)<span class="number">0</span>) &#123;</span><br><span class="line">                p_tcb2-&gt;TickPrevPtr = p_tcb1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p_tcb-&gt;TickNextPtr  = (OS_TCB        *)<span class="number">0</span>;</span><br><span class="line">        p_tcb-&gt;TickPrevPtr  = (OS_TCB        *)<span class="number">0</span>;</span><br><span class="line">        p_tcb-&gt;TickSpokePtr = (OS_TICK_SPOKE *)<span class="number">0</span>;</span><br><span class="line">        p_tcb-&gt;TickCtrMatch = (OS_TICK        )<span class="number">0u</span>;</span><br><span class="line">        p_spoke-&gt;NbrEntries--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，并没有一个数据结构叫Tick list，那么上面说的双向链表是怎么来的呢？</p>
<p>TCB中维护着相关的字段：TickNextPtr，TickPrevPtr，TickSpokePtr，TickCtrMatch，看下Spoke的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_tick_spoke</span> &#123;</span></span><br><span class="line">    OS_TCB              *FirstPtr;                          <span class="comment">/* Pointer to list of tasks in tick spoke                 */</span></span><br><span class="line">    OS_OBJ_QTY           NbrEntries;                        <span class="comment">/* Current number of entries in the tick spoke            */</span></span><br><span class="line">    OS_OBJ_QTY           NbrEntriesMax;                     <span class="comment">/* Peak number of entries in the tick spoke               */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Spoke里定义了链表最开始的TCB是在哪，以及任务的数目，任务数目的最大值。</p>
<h2 id="OSTimeSet和OSTimeGet"><a href="#OSTimeSet和OSTimeGet" class="headerlink" title="OSTimeSet和OSTimeGet"></a>OSTimeSet和OSTimeGet</h2><p>获取和改变时钟节拍计数器的内容。</p>
<h2 id="OSTimeTick"><a href="#OSTimeTick" class="headerlink" title="OSTimeTick"></a>OSTimeTick</h2><p>Tick ISR中会调用的函数，之前系统任务里也看过，这里再搬过来看看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSTimeTick</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_ERR  err;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ISR_POST_DEFERRED_EN &gt; 0u</span></span><br><span class="line">    CPU_TS  ts;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OSTimeTickHook();                                       <span class="comment">/* Call user definable hook                               */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ISR_POST_DEFERRED_EN &gt; 0u <span class="comment">// 延迟发布</span></span></span><br><span class="line"></span><br><span class="line">    ts = OS_TS_GET();                                       <span class="comment">/* Get timestamp                                          */</span></span><br><span class="line">    OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             <span class="comment">/* Post to ISR queue                                      */</span></span><br><span class="line">                (<span class="type">void</span>      *)&amp;OSRdyList[OSPrioCur],</span><br><span class="line">                (<span class="type">void</span>      *) <span class="number">0</span>,</span><br><span class="line">                (OS_MSG_SIZE) <span class="number">0u</span>,</span><br><span class="line">                (OS_FLAGS   ) <span class="number">0u</span>,</span><br><span class="line">                (OS_OPT     ) <span class="number">0u</span>,</span><br><span class="line">                (CPU_TS     ) ts,</span><br><span class="line">                (OS_ERR    *)&amp;err);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 关中断</span></span></span><br><span class="line"></span><br><span class="line">   (<span class="type">void</span>)OSTaskSemPost((OS_TCB *)&amp;OSTickTaskTCB,            <span class="comment">/* Signal tick task                                       */</span></span><br><span class="line">                       (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                       (OS_ERR *)&amp;err);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_SCHED_ROUND_ROBIN_EN &gt; 0u</span></span><br><span class="line">    OS_SchedRoundRobin(&amp;OSRdyList[OSPrioCur]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TMR_EN &gt; 0u <span class="comment">// 使用定时器</span></span></span><br><span class="line">    OSTmrUpdateCtr--;</span><br><span class="line">    <span class="keyword">if</span> (OSTmrUpdateCtr == (OS_CTR)<span class="number">0u</span>) &#123;</span><br><span class="line">        OSTmrUpdateCtr = OSTmrUpdateCnt;</span><br><span class="line">        OSTaskSemPost((OS_TCB *)&amp;OSTmrTaskTCB,              <span class="comment">/* Signal timer task                                      */</span></span><br><span class="line">                      (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                      (OS_ERR *)&amp;err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下先分析关调度器的情况：</p>
<h3 id="OS-CFG-ISR-POST-DEFERRED-EN-1"><a href="#OS-CFG-ISR-POST-DEFERRED-EN-1" class="headerlink" title="OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1"></a>OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1</h3><p>会将函数调用和参数发给ISR Queue：OS_IntQPost</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">OS_IntQPost</span> <span class="params">(OS_OBJ_TYPE   type,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span>         *p_obj, <span class="comment">// 内核对象</span></span></span><br><span class="line"><span class="params">                   <span class="type">void</span>         *p_void, <span class="comment">// 消息</span></span></span><br><span class="line"><span class="params">                   OS_MSG_SIZE   msg_size, <span class="comment">// </span></span></span><br><span class="line"><span class="params">                   OS_FLAGS      flags,</span></span><br><span class="line"><span class="params">                   OS_OPT        opt,</span></span><br><span class="line"><span class="params">                   CPU_TS        ts,</span></span><br><span class="line"><span class="params">                   OS_ERR       *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (OSIntQNbrEntries &lt; OSCfg_IntQSize) &#123;                <span class="comment">/* Make sure we haven&#x27;t already filled the ISR queue      */</span></span><br><span class="line">        OSIntQNbrEntries++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OSIntQNbrEntriesMax &lt; OSIntQNbrEntries) &#123;</span><br><span class="line">            OSIntQNbrEntriesMax = OSIntQNbrEntries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OSIntQInPtr-&gt;Type       = type;                     <span class="comment">/* Save object type being posted                          */</span></span><br><span class="line">        OSIntQInPtr-&gt;ObjPtr     = p_obj;                    <span class="comment">/* Save pointer to object being posted                    */</span></span><br><span class="line">        OSIntQInPtr-&gt;MsgPtr     = p_void;                   <span class="comment">/* Save pointer to message if posting to a message queue  */</span></span><br><span class="line">        OSIntQInPtr-&gt;MsgSize    = msg_size;                 <span class="comment">/* Save the message size   if posting to a message queue  */</span></span><br><span class="line">        OSIntQInPtr-&gt;Flags      = flags;                    <span class="comment">/* Save the flags if posting to an event flag group       */</span></span><br><span class="line">        OSIntQInPtr-&gt;Opt        = opt;                      <span class="comment">/* Save post options                                      */</span></span><br><span class="line">        OSIntQInPtr-&gt;TS         = ts;                       <span class="comment">/* Save time stamp                                        */</span></span><br><span class="line"></span><br><span class="line">        OSIntQInPtr             =  OSIntQInPtr-&gt;NextPtr;    <span class="comment">/* Point to the next interrupt handler queue entry        */</span></span><br><span class="line"></span><br><span class="line">        OSRdyList[<span class="number">0</span>].NbrEntries = (OS_OBJ_QTY)<span class="number">1</span>;            <span class="comment">/* Make the interrupt handler task ready to run           */</span></span><br><span class="line">        OSRdyList[<span class="number">0</span>].HeadPtr    = &amp;OSIntQTaskTCB;</span><br><span class="line">        OSRdyList[<span class="number">0</span>].TailPtr    = &amp;OSIntQTaskTCB;</span><br><span class="line">        OS_PrioInsert(<span class="number">0u</span>);                                  <span class="comment">/* Add task priority 0 in the priority table              */</span></span><br><span class="line">        <span class="keyword">if</span> (OSPrioCur != <span class="number">0</span>) &#123;                               <span class="comment">/* Chk if OSIntQTask is not running                       */</span></span><br><span class="line">            OSPrioSaved         = OSPrioCur;                <span class="comment">/* Save current priority                                  */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       *p_err                   = OS_ERR_NONE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        OSIntQOvfCtr++;                                     <span class="comment">/* Count the number of ISR queue overflows                */</span></span><br><span class="line">       *p_err                   = OS_ERR_INT_Q_FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    CPU_CRITICAL_EXIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要看一下参数的意思，把注释也搬过来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*$PAGE*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*                                                   POST TO ISR QUEUE</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Description: This function places contents of posts into an intermediate queue to help defer processing of interrupts</span></span><br><span class="line"><span class="comment">*              at the task level.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Arguments  : type       is the type of kernel object the post is destined to:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*                             OS_OBJ_TYPE_SEM</span></span><br><span class="line"><span class="comment">*                             OS_OBJ_TYPE_Q</span></span><br><span class="line"><span class="comment">*                             OS_OBJ_TYPE_FLAG</span></span><br><span class="line"><span class="comment">*                             OS_OBJ_TYPE_TASK_MSG</span></span><br><span class="line"><span class="comment">*                             OS_OBJ_TYPE_TASK_SIGNAL</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              p_obj      is a pointer to the kernel object to post to.  This can be a pointer to a semaphore,</span></span><br><span class="line"><span class="comment">*              -----      a message queue or a task control clock.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              p_void     is a pointer to a message that is being posted.  This is used when posting to a message</span></span><br><span class="line"><span class="comment">*                         queue or directly to a task.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              msg_size   is the size of the message being posted</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              flags      if the post is done to an event flag group then this corresponds to the flags being</span></span><br><span class="line"><span class="comment">*                         posted</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              ts         is a timestamp as to when the post was done</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              opt        this corresponds to post options and applies to:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*                             OSFlagPost()</span></span><br><span class="line"><span class="comment">*                             OSSemPost()</span></span><br><span class="line"><span class="comment">*                             OSQPost()</span></span><br><span class="line"><span class="comment">*                             OSTaskQPost()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*              p_err      is a pointer to a variable that will contain an error code returned by this function.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*                             OS_ERR_NONE         if the post to the ISR queue was successful</span></span><br><span class="line"><span class="comment">*                             OS_ERR_INT_Q_FULL   if the ISR queue is full and cannot accepts any further posts.  This</span></span><br><span class="line"><span class="comment">*                                                 generally indicates that you are receiving interrupts faster than you</span></span><br><span class="line"><span class="comment">*                                                 can process them or, that you didn&#x27;t make the ISR queue large enough.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Returns    : none</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note(s)    : none</span></span><br><span class="line"><span class="comment">************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>再下面是interrupt queue结构的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_int_q</span> &#123;</span></span><br><span class="line">    OS_OBJ_TYPE          Type;                              <span class="comment">/* Type of object placed in the circular list             */</span></span><br><span class="line">    OS_INT_Q            *NextPtr;                           <span class="comment">/* Pointer to next OS_INT_Q in  circular list             */</span></span><br><span class="line">    <span class="type">void</span>                *ObjPtr;                            <span class="comment">/* Pointer to object placed in the queue                  */</span></span><br><span class="line">    <span class="type">void</span>                *MsgPtr;                            <span class="comment">/* Pointer to message if posting to a message queue       */</span></span><br><span class="line">    OS_MSG_SIZE          MsgSize;                           <span class="comment">/* Message Size       if posting to a message queue       */</span></span><br><span class="line">    OS_FLAGS             Flags;                             <span class="comment">/* Value of flags if posting to an event flag group       */</span></span><br><span class="line">    OS_OPT               Opt;                               <span class="comment">/* Post Options                                           */</span></span><br><span class="line">    CPU_TS               TS;                                <span class="comment">/* Timestamp                                              */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看来interrupt queue是个单链表，所以当我们进行update时应该也是首先post头部，下面看看当，退出ISR后，我们的OSIntQTask被唤醒就绪，其执行过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_IntQTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_BOOLEAN  done;</span><br><span class="line">    CPU_TS       ts_start;</span><br><span class="line">    CPU_TS       ts_end;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                          <span class="comment">/* Not using &#x27;p_arg&#x27;, prevent compiler warning            */</span></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        done = DEF_FALSE;</span><br><span class="line">        <span class="keyword">while</span> (done == DEF_FALSE) &#123;</span><br><span class="line">            CPU_CRITICAL_ENTER();</span><br><span class="line">            <span class="keyword">if</span> (OSIntQNbrEntries == (OS_OBJ_QTY)<span class="number">0u</span>) &#123; <span class="comment">// 如果interrupt queue里没有TCB，那么就将自己从就绪队列中移除，并且开始一次调度</span></span><br><span class="line">                OSRdyList[<span class="number">0</span>].NbrEntries = (OS_OBJ_QTY)<span class="number">0u</span>;   <span class="comment">/* Remove from ready list                                 */</span></span><br><span class="line">                OSRdyList[<span class="number">0</span>].HeadPtr    = (OS_TCB   *)<span class="number">0</span>;</span><br><span class="line">                OSRdyList[<span class="number">0</span>].TailPtr    = (OS_TCB   *)<span class="number">0</span>;</span><br><span class="line">                OS_PrioRemove(<span class="number">0u</span>);                          <span class="comment">/* Remove from the priority table                         */</span></span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">                OSSched();</span><br><span class="line">                done = DEF_TRUE;                            <span class="comment">/* No more entries in the queue, we are done              */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">                ts_start = OS_TS_GET();</span><br><span class="line">                OS_IntQRePost(); <span class="comment">// 这里是关键</span></span><br><span class="line">                ts_end   = OS_TS_GET() - ts_start;          <span class="comment">/* Measure execution time of tick task                    */</span></span><br><span class="line">                <span class="keyword">if</span> (OSIntQTaskTimeMax &lt; ts_end) &#123;</span><br><span class="line">                    OSIntQTaskTimeMax = ts_end;</span><br><span class="line">                &#125;</span><br><span class="line">                CPU_CRITICAL_ENTER();</span><br><span class="line">                OSIntQOutPtr = OSIntQOutPtr-&gt;NextPtr;       <span class="comment">/* Point to next item in the ISR queue                    */</span></span><br><span class="line">                OSIntQNbrEntries--;</span><br><span class="line">                CPU_CRITICAL_EXIT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，若是interrupt queue为空时，直接让出CPU，并将退出循环；若是有的话，就调用OS_IntQRePost函数，注意，是在while循环中，一直调用，直到interrupt queue为空为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_IntQRePost</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_TS  ts;</span><br><span class="line">    OS_ERR  err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (OSIntQOutPtr-&gt;Type) &#123;                           <span class="comment">/* Re-post to task                                        */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_FLAG:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_FLAG_EN &gt; 0u</span></span><br><span class="line">             (<span class="type">void</span>)OS_FlagPost((OS_FLAG_GRP *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                               (OS_FLAGS     ) OSIntQOutPtr-&gt;Flags,</span><br><span class="line">                               (OS_OPT       ) OSIntQOutPtr-&gt;Opt,</span><br><span class="line">                               (CPU_TS       ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                               (OS_ERR      *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_Q:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_Q_EN &gt; 0u</span></span><br><span class="line">             OS_QPost((OS_Q      *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                      (<span class="type">void</span>      *) OSIntQOutPtr-&gt;MsgPtr,</span><br><span class="line">                      (OS_MSG_SIZE) OSIntQOutPtr-&gt;MsgSize,</span><br><span class="line">                      (OS_OPT     ) OSIntQOutPtr-&gt;Opt,</span><br><span class="line">                      (CPU_TS     ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                      (OS_ERR    *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_SEM:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_SEM_EN &gt; 0u</span></span><br><span class="line">             (<span class="type">void</span>)OS_SemPost((OS_SEM *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                              (OS_OPT  ) OSIntQOutPtr-&gt;Opt,</span><br><span class="line">                              (CPU_TS  ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                              (OS_ERR *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_TASK_MSG:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_Q_EN &gt; 0u</span></span><br><span class="line">             OS_TaskQPost((OS_TCB    *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                          (<span class="type">void</span>      *) OSIntQOutPtr-&gt;MsgPtr,</span><br><span class="line">                          (OS_MSG_SIZE) OSIntQOutPtr-&gt;MsgSize,</span><br><span class="line">                          (OS_OPT     ) OSIntQOutPtr-&gt;Opt,</span><br><span class="line">                          (CPU_TS     ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                          (OS_ERR    *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_TASK_RESUME:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_SUSPEND_EN &gt; 0u</span></span><br><span class="line">             (<span class="type">void</span>)OS_TaskResume((OS_TCB *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                                 (OS_ERR *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_TASK_SIGNAL:</span><br><span class="line">             (<span class="type">void</span>)OS_TaskSemPost((OS_TCB *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                                  (OS_OPT  ) OSIntQOutPtr-&gt;Opt,</span><br><span class="line">                                  (CPU_TS  ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                                  (OS_ERR *)&amp;err);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_TASK_SUSPEND:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TASK_SUSPEND_EN &gt; 0u</span></span><br><span class="line">             (<span class="type">void</span>)OS_TaskSuspend((OS_TCB *) OSIntQOutPtr-&gt;ObjPtr,</span><br><span class="line">                                  (OS_ERR *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OBJ_TYPE_TICK:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_SCHED_ROUND_ROBIN_EN &gt; 0u</span></span><br><span class="line">             OS_SchedRoundRobin(&amp;OSRdyList[OSPrioSaved]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">             (<span class="type">void</span>)OS_TaskSemPost((OS_TCB *)&amp;OSTickTaskTCB,                <span class="comment">/* Signal tick task                        */</span></span><br><span class="line">                                  (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                                  (CPU_TS  ) OSIntQOutPtr-&gt;TS,</span><br><span class="line">                                  (OS_ERR *)&amp;err);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_TMR_EN &gt; 0u</span></span><br><span class="line">             OSTmrUpdateCtr--;</span><br><span class="line">             <span class="keyword">if</span> (OSTmrUpdateCtr == (OS_CTR)<span class="number">0u</span>) &#123;</span><br><span class="line">                 OSTmrUpdateCtr = OSTmrUpdateCnt;</span><br><span class="line">                 ts             = OS_TS_GET();                             <span class="comment">/* Get timestamp                           */</span></span><br><span class="line">                 (<span class="type">void</span>)OS_TaskSemPost((OS_TCB *)&amp;OSTmrTaskTCB,             <span class="comment">/* Signal timer task                       */</span></span><br><span class="line">                                      (OS_OPT  ) OS_OPT_POST_NONE,</span><br><span class="line">                                      (CPU_TS  ) ts,</span><br><span class="line">                                      (OS_ERR *)&amp;err);</span><br><span class="line">             &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据OSIntQOutPtr的类型来判断怎么去post，具体情况很多，细节看代码。</p>
<p>等待都唤醒完后，可能就是轮到OSTickTask运行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_TickTask</span> <span class="params">(<span class="type">void</span>  *p_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_ERR  err;</span><br><span class="line">    CPU_TS  ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p_arg = p_arg;                                          <span class="comment">/* Prevent compiler warning                               */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (DEF_ON) &#123;</span><br><span class="line">        (<span class="type">void</span>)OSTaskSemPend((OS_TICK  )<span class="number">0</span>,</span><br><span class="line">                            (OS_OPT   )OS_OPT_PEND_BLOCKING,</span><br><span class="line">                            (CPU_TS  *)&amp;ts,</span><br><span class="line">                            (OS_ERR  *)&amp;err);               <span class="comment">/* Wait for signal from tick interrupt                    */</span></span><br><span class="line">        <span class="keyword">if</span> (err == OS_ERR_NONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OSRunning == OS_STATE_OS_RUNNING) &#123;</span><br><span class="line">                OS_TickListUpdate();                        <span class="comment">/* Update all tasks waiting for time                      */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其会运行update函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_TickListUpdate</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_BOOLEAN        done;</span><br><span class="line">    OS_TICK_SPOKE     *p_spoke;</span><br><span class="line">    OS_TCB            *p_tcb;</span><br><span class="line">    OS_TCB            *p_tcb_next;</span><br><span class="line">    OS_TICK_SPOKE_IX   spoke;</span><br><span class="line">    CPU_TS             ts_start;</span><br><span class="line">    CPU_TS             ts_end;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER();</span><br><span class="line">    ts_start = OS_TS_GET();</span><br><span class="line">    OSTickCtr++;                                                       <span class="comment">/* Keep track of the number of ticks           */</span></span><br><span class="line">    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);</span><br><span class="line">    p_spoke  = &amp;OSCfg_TickWheel[spoke];</span><br><span class="line">    p_tcb    = p_spoke-&gt;FirstPtr;</span><br><span class="line">    done     = DEF_FALSE;</span><br><span class="line">    <span class="keyword">while</span> (done == DEF_FALSE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_tcb != (OS_TCB *)<span class="number">0</span>) &#123;</span><br><span class="line">            p_tcb_next = p_tcb-&gt;TickNextPtr;                           <span class="comment">/* Point to next TCB to update                 */</span></span><br><span class="line">            <span class="keyword">switch</span> (p_tcb-&gt;TaskState) &#123;</span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_RDY:</span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_PEND:</span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_SUSPENDED:</span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_PEND_SUSPENDED:</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_DLY:</span><br><span class="line">                     p_tcb-&gt;TickRemain = p_tcb-&gt;TickCtrMatch           <span class="comment">/* Compute time remaining of current TCB       */</span></span><br><span class="line">                                       - OSTickCtr;</span><br><span class="line">                     <span class="keyword">if</span> (OSTickCtr == p_tcb-&gt;TickCtrMatch) &#123;           <span class="comment">/* Process each TCB that expires               */</span></span><br><span class="line">                         p_tcb-&gt;TaskState = OS_TASK_STATE_RDY;</span><br><span class="line">                         OS_TaskRdy(p_tcb);                            <span class="comment">/* Make task ready to run                      */</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         done             = DEF_TRUE;                  <span class="comment">/* Don&#x27;t find a match, we&#x27;re done!             */</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT:</span><br><span class="line">                     p_tcb-&gt;TickRemain = p_tcb-&gt;TickCtrMatch           <span class="comment">/* Compute time remaining of current TCB       */</span></span><br><span class="line">                                       - OSTickCtr;</span><br><span class="line">                     <span class="keyword">if</span> (OSTickCtr == p_tcb-&gt;TickCtrMatch) &#123;           <span class="comment">/* Process each TCB that expires               */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (OS_MSG_EN &gt; 0u)</span></span><br><span class="line">                         p_tcb-&gt;MsgPtr     = (<span class="type">void</span>      *)<span class="number">0</span>;</span><br><span class="line">                         p_tcb-&gt;MsgSize    = (OS_MSG_SIZE)<span class="number">0u</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                         p_tcb-&gt;TS         = OS_TS_GET();</span><br><span class="line">                         OS_PendListRemove(p_tcb);                     <span class="comment">/* Remove from wait list                       */</span></span><br><span class="line">                         OS_TaskRdy(p_tcb);</span><br><span class="line">                         p_tcb-&gt;TaskState  = OS_TASK_STATE_RDY;</span><br><span class="line">                         p_tcb-&gt;PendStatus = OS_STATUS_PEND_TIMEOUT;   <span class="comment">/* Indicate pend timed out                     */</span></span><br><span class="line">                         p_tcb-&gt;PendOn     = OS_TASK_PEND_ON_NOTHING;  <span class="comment">/* Indicate no longer pending                  */</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         done              = DEF_TRUE;                 <span class="comment">/* Don&#x27;t find a match, we&#x27;re done!             */</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_DLY_SUSPENDED:</span><br><span class="line">                     p_tcb-&gt;TickRemain = p_tcb-&gt;TickCtrMatch           <span class="comment">/* Compute time remaining of current TCB       */</span></span><br><span class="line">                                       - OSTickCtr;</span><br><span class="line">                     <span class="keyword">if</span> (OSTickCtr == p_tcb-&gt;TickCtrMatch) &#123;           <span class="comment">/* Process each TCB that expires               */</span></span><br><span class="line">                         p_tcb-&gt;TaskState  = OS_TASK_STATE_SUSPENDED;</span><br><span class="line">                         OS_TickListRemove(p_tcb);                     <span class="comment">/* Remove from current wheel spoke             */</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         done              = DEF_TRUE;                 <span class="comment">/* Don&#x27;t find a match, we&#x27;re done!             */</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:</span><br><span class="line">                     p_tcb-&gt;TickRemain = p_tcb-&gt;TickCtrMatch           <span class="comment">/* Compute time remaining of current TCB       */</span></span><br><span class="line">                                       - OSTickCtr;</span><br><span class="line">                     <span class="keyword">if</span> (OSTickCtr == p_tcb-&gt;TickCtrMatch) &#123;           <span class="comment">/* Process each TCB that expires               */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (OS_MSG_EN &gt; 0u)</span></span><br><span class="line">                         p_tcb-&gt;MsgPtr     = (<span class="type">void</span>      *)<span class="number">0</span>;</span><br><span class="line">                         p_tcb-&gt;MsgSize    = (OS_MSG_SIZE)<span class="number">0u</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                         p_tcb-&gt;TS         = OS_TS_GET();</span><br><span class="line">                         OS_PendListRemove(p_tcb);                     <span class="comment">/* Remove from wait list                       */</span></span><br><span class="line">                         OS_TickListRemove(p_tcb);                     <span class="comment">/* Remove from current wheel spoke             */</span></span><br><span class="line">                         p_tcb-&gt;TaskState  = OS_TASK_STATE_SUSPENDED;</span><br><span class="line">                         p_tcb-&gt;PendStatus = OS_STATUS_PEND_TIMEOUT;   <span class="comment">/* Indicate pend timed out                     */</span></span><br><span class="line">                         p_tcb-&gt;PendOn     = OS_TASK_PEND_ON_NOTHING;  <span class="comment">/* Indicate no longer pending                  */</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         done              = DEF_TRUE;                 <span class="comment">/* Don&#x27;t find a match, we&#x27;re done!             */</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p_tcb = p_tcb_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            done  = DEF_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts_end = OS_TS_GET() - ts_start;                                   <span class="comment">/* Measure execution time of tick task         */</span></span><br><span class="line">    <span class="keyword">if</span> (OSTickTaskTimeMax &lt; ts_end) &#123;</span><br><span class="line">        OSTickTaskTimeMax = ts_end;</span><br><span class="line">    &#125;</span><br><span class="line">    OS_CRITICAL_EXIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较复杂。。。后面再看。</p>
<h1 id="定时器管理"><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h1><p>优先级低，先看信号量相关</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>本章讲述的是OS中的资源管理，有这几种资源：</p>
<ul>
<li>变量</li>
<li>结构体</li>
<li>内存中的表格</li>
<li>IO设备中的寄存器</li>
<li>等等</li>
</ul>
<p>书上举了个例子，是时钟同步的内容。在进行时钟同步时，时分秒累加。假设刚好满60min，分针清零，时针准备加一，然后来中断&#x2F;高优先级的任务，然后会获取当前时间，这时获取到的时间就会和真正的时间偏差一小时。</p>
<p>和老师上课举的例子差不多，都是要进行更新的时候被打断了，只不过老师课上讲的例子里面我们不仅打断了，还会修改其值。</p>
<p>上面说的这一类操作，可以总的归结起来为：“原子操作”，也就是<strong>不可被打断的操作</strong></p>
<p>资源是可以被共享的，所有的任务都可以访问，但是，如何保证资源的独占，避免资源的竞争，是OS设计者需要考虑的事情。</p>
<p>有几个方式来保证资源的独占：</p>
<ul>
<li>关中断：对于RTOS而言，关中断意味着放弃了部分实时性，所以需要谨慎使用！</li>
<li>锁调度器：锁调度器就不能进行任务的实时发布了，延迟发布会带来一定的延时，还是损失了部分实时性！同时，UCOS是基于优先级调度的，若是锁了调度器，高优先级的任务得不到响应，反而是低优先级的任务仍在运行，这违背了我们的优先级原则</li>
<li>使用sem：使用sem：可以保证实时性（中断，HPTs得到CPU），但是会出现：若高优先级的任务后pend sem，那么就算得到CPU，也会主动放弃，将自身挂起。称之为<strong>优先级反转</strong></li>
<li>使用mutex：能够暂时提升LPT的优先级，解决了优先级反转的问题</li>
</ul>
<p>下面是具体情况下的选取：<br><img src="/2022/05/26/MicroCOS-III/2022-06-06-23-15-09.png"></p>
<h2 id="关中断-1"><a href="#关中断-1" class="headerlink" title="关中断"></a>关中断</h2><p><img src="/2022/05/26/MicroCOS-III/2022-06-06-23-23-15.png"></p>
<p>具体操作可以随便看一端代码,看OS_TaskSuspend的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>   <span class="title function_">OS_TaskSuspend</span> <span class="params">(OS_TCB  *p_tcb,</span></span><br><span class="line"><span class="params">                       OS_ERR  *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC(); <span class="comment">//（1）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER(); <span class="comment">// （2）</span></span><br><span class="line">    <span class="keyword">if</span> (p_tcb == (OS_TCB *)<span class="number">0</span>) &#123;                             <span class="comment">/* See if specified to suspend self                       */</span></span><br><span class="line">        p_tcb = OSTCBCurPtr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_tcb == OSTCBCurPtr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;    <span class="comment">/* Can&#x27;t suspend when the scheduler is locked             */</span></span><br><span class="line">            CPU_CRITICAL_EXIT();</span><br><span class="line">           *p_err = OS_ERR_SCHED_LOCKED;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">    <span class="keyword">switch</span> (p_tcb-&gt;TaskState) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_TASK_STATE_RDY:</span><br><span class="line">             OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();</span><br><span class="line">             p_tcb-&gt;TaskState  =  OS_TASK_STATE_SUSPENDED;</span><br><span class="line">             p_tcb-&gt;SuspendCtr = (OS_NESTING_CTR)<span class="number">1</span>;</span><br><span class="line">             OS_RdyListRemove(p_tcb);</span><br><span class="line">             OS_CRITICAL_EXIT_NO_SCHED(); <span class="comment">// （3）</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>然后分析代码中的（1）（2）（3）</p>
<ul>
<li>（1）分配存储空间来存储当前CPU的中断状态。</li>
<li>（2）将CPU的中断标志位存储在上一步分配的空间中，并屏蔽所有可屏蔽中断。</li>
<li>（3）恢复局部变量中存储的CPU中断标志位</li>
</ul>
<p>再说两点：</p>
<ul>
<li>上面的着三个函数，都是CPU的函数，而不是OS函数</li>
<li>然后，关中断的时间越短越好</li>
</ul>
<h2 id="锁调度器"><a href="#锁调度器" class="headerlink" title="锁调度器"></a>锁调度器</h2><p>我们说UCOS是一个实时操作系统，可剥夺型的内核。刚刚上面<strong>关中断损失了实时性</strong>，下面看看锁调度器：</p>
<p><img src="/2022/05/26/MicroCOS-III/2022-06-06-23-39-30.png"></p>
<ul>
<li>（2）关闭调度器</li>
<li>（3）访问临界资源，这时，即使来了高优先级的任务也不会进行调度；如果interrupt来了，那么也没关系，执行完ISR后，还是回到了我们原来被中断的任务，所有的HPTs都需要等待（看上去是不是很像不可剥夺型内核）</li>
<li>（4）开调度器</li>
</ul>
<p>关调度损失的就是<strong>可剥夺</strong>这个特性了。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量最开始是一种机械机制，用在铁路系统中的。如今被用在多任务内核（CPU）中。</p>
<p>信号量大概有以下分类：</p>
<ul>
<li>二进制信号量</li>
<li>计数信号量</li>
<li>互斥量</li>
<li>任务信号量</li>
</ul>
<p>其中二进制型和计数型使用的是同一种数据结构，区别仅仅在于其数据结构不同。而互斥量跟优先级挂钩的。任务信号量是跟任务挂钩的。</p>
<h3 id="二进制信号量-计数信号量"><a href="#二进制信号量-计数信号量" class="headerlink" title="二进制信号量&#x2F;计数信号量"></a>二进制信号量&#x2F;计数信号量</h3><p>由于这俩的数据结构一样，区别仅在于使用，所以放在一起分析。</p>
<p>首先看看信号量的数据结构内部实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_sem</span> &#123;</span>                                            <span class="comment">/* Semaphore                                              */</span></span><br><span class="line">                                                            <span class="comment">/* ------------------ GENERIC  MEMBERS ------------------ */</span></span><br><span class="line">    OS_OBJ_TYPE          Type;                              <span class="comment">/* Should be set to OS_OBJ_TYPE_SEM                       */</span></span><br><span class="line">    CPU_CHAR            *NamePtr;                           <span class="comment">/* Pointer to Semaphore Name (NUL terminated ASCII)       */</span></span><br><span class="line">    OS_PEND_LIST         PendList;                          <span class="comment">/* List of tasks waiting on semaphore                     */</span></span><br><span class="line"><span class="comment">// 下是关于Debug是否开启的判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">    OS_SEM              *DbgPrevPtr;</span><br><span class="line">    OS_SEM              *DbgNextPtr;</span><br><span class="line">    CPU_CHAR            *DbgNamePtr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                            <span class="comment">/* ------------------ SPECIFIC MEMBERS ------------------ */</span></span><br><span class="line">    OS_SEM_CTR           Ctr;</span><br><span class="line">    CPU_TS               TS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以说，一般的信号量都只有四个字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_sem</span> &#123;</span>                                           </span><br><span class="line">                                                           </span><br><span class="line">    OS_OBJ_TYPE          Type; <span class="comment">// 类型，对于信号量，必须是OS_OBJ_TYPE_SEM，好像每个内核对象都有一个具体的type，下面分析这个</span></span><br><span class="line">    CPU_CHAR            *NamePtr; <span class="comment">// 信号量的名字，便于记忆</span></span><br><span class="line">    OS_PEND_LIST         PendList; <span class="comment">// 信号量对应的 pend list</span></span><br><span class="line">    OS_SEM_CTR           Ctr; <span class="comment">// 信号量的值是多少，意味着二进制型或者计数型</span></span><br><span class="line">    CPU_TS               TS; <span class="comment">// 时间戳，初始化时为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量是我们接触的第一个内核对象，下面看看内核对象类型OS_OBJ_TYPE，我猜测其是一个enum</p>
<p>但是猜错了，是一个32位数。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   CPU_INT32U      OS_OBJ_TYPE;                 <span class="comment">/* Special flag to determine object type,                   32 */</span></span><br></pre></td></tr></table></figure>

<p>但是我找到了内核对象的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_NONE                    (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;E&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_FLAG                    (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_MEM                     (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_MUTEX                   (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;X&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_Q                       (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;U&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_SEM                     (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TASK_MSG                (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;G&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TASK_RESUME             (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TASK_SIGNAL             (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;G&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TASK_SUSPEND            (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TICK                    (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;K&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OS_OBJ_TYPE_TMR                     (OS_OBJ_TYPE)CPU_TYPE_CREATE(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span></span><br></pre></td></tr></table></figure>


<p>然后看看如何创建一个信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_SEM key_sem;</span><br><span class="line">OSSemCreate((OS_SEM      *)&amp;key_sem,   </span><br><span class="line">           (CPU_CHAR    *)<span class="string">&quot;key_sem&quot;</span>,   </span><br><span class="line">           (OS_SEM_CTR   )<span class="number">0</span>,            </span><br><span class="line">           (OS_ERR      *)&amp;err);   </span><br></pre></td></tr></table></figure>
<p>上面我们首先声明了一个信号量，然后使用函数进行信号量的创建（初始化）。</p>
<p>可以看到OSSemCreate需要的参数：</p>
<ul>
<li>声明的信号量的指针</li>
<li>信号量的字符串名字</li>
<li>信号量的数量</li>
<li>创建结果存到&amp;err指针中</li>
</ul>
<p>看看OSSemCreat函数，附上注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSSemCreate</span> <span class="params">(OS_SEM      *p_sem,</span></span><br><span class="line"><span class="params">                   CPU_CHAR    *p_name,</span></span><br><span class="line"><span class="params">                   OS_SEM_CTR   cnt,</span></span><br><span class="line"><span class="params">                   OS_ERR      *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建信号量属于对内核数据结构的创建，需要实现操作的一气呵成，所以需要进入临界区</span></span><br><span class="line">    CPU_SR_ALLOC(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL_IEC61508</span></span><br><span class="line">    <span class="keyword">if</span> (OSSafetyCriticalStartFlag == DEF_TRUE) &#123;</span><br><span class="line">       *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* Not allowed to be called from an ISR                   */</span></span><br><span class="line">       *p_err = OS_ERR_CREATE_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_sem == (OS_SEM *)<span class="number">0</span>) &#123;                             <span class="comment">/* Validate &#x27;p_sem&#x27;                                       */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进入临界区，关中断or关调度器</span></span><br><span class="line">    OS_CRITICAL_ENTER();</span><br><span class="line">    <span class="comment">// 下面是给信号量数据结构进行赋值</span></span><br><span class="line">    p_sem-&gt;Type    = OS_OBJ_TYPE_SEM;                       <span class="comment">/* Mark the data structure as a semaphore                 */</span></span><br><span class="line">    p_sem-&gt;Ctr     = cnt;                                   <span class="comment">/* Set semaphore value                                    */</span></span><br><span class="line">    p_sem-&gt;TS      = (CPU_TS)<span class="number">0</span>;</span><br><span class="line">    p_sem-&gt;NamePtr = p_name;                                <span class="comment">/* Save the name of the semaphore                         */</span></span><br><span class="line">    <span class="comment">// 初始化一个信号量的pend list，当有任务pend这个信号量而其ctr=0时，会被加入到这个队列进行挂起等待</span></span><br><span class="line">    OS_PendListInit(&amp;p_sem-&gt;PendList);                      <span class="comment">/* Initialize the waiting list                            */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">    OS_SemDbgListAdd(p_sem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OSSemQty++;</span><br><span class="line">    <span class="comment">// 退出临界区并且不调度</span></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看pend一个信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">OS_SEM_CTR  <span class="title function_">OSSemPend</span> <span class="params">(OS_SEM   *p_sem,</span></span><br><span class="line"><span class="params">                       OS_TICK   timeout,</span></span><br><span class="line"><span class="params">                       OS_OPT    opt,</span></span><br><span class="line"><span class="params">                       CPU_TS   *p_ts,</span></span><br><span class="line"><span class="params">                       OS_ERR   *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_SEM_CTR    ctr;</span><br><span class="line">    OS_PEND_DATA  pend_data;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_PEND_ISR;</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_sem == (OS_SEM *)<span class="number">0</span>) &#123;                             <span class="comment">/* Validate &#x27;p_sem&#x27;                                       */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                          <span class="comment">/* Validate &#x27;opt&#x27;                                         */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_BLOCKING:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_NON_BLOCKING:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_sem-&gt;Type != OS_OBJ_TYPE_SEM) &#123;                   <span class="comment">/* Make sure semaphore was created                        */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">       *p_ts  = (CPU_TS)<span class="number">0</span>;                                  <span class="comment">/* Initialize the returned timestamp                      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从进入临界区开始分析</span></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (p_sem-&gt;Ctr &gt; (OS_SEM_CTR)<span class="number">0</span>) &#123;                       <span class="comment">/* Resource available?                                    */</span></span><br><span class="line">        <span class="comment">// 当信号量的ctr&gt;0时，可获取</span></span><br><span class="line">        p_sem-&gt;Ctr--;                                       <span class="comment">/* Yes, caller may proceed                                */</span></span><br><span class="line">        <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">           *p_ts  = p_sem-&gt;TS;                              <span class="comment">/*      get timestamp of last post                        */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ctr   = p_sem-&gt;Ctr;</span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">        *p_err = OS_ERR_NONE;</span><br><span class="line">        <span class="comment">// 返回了信号量剩余的值</span></span><br><span class="line">        <span class="keyword">return</span> (ctr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面sem-&gt;ctr=0的情况</span></span><br><span class="line">    <span class="comment">// 信号量不可用是否阻塞？</span></span><br><span class="line">    <span class="keyword">if</span> ((opt &amp; OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)<span class="number">0</span>) &#123;    <span class="comment">/* Caller wants to block if not available?                */</span></span><br><span class="line">        ctr   = p_sem-&gt;Ctr;                                 <span class="comment">/* No                                                     */</span></span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_PEND_WOULD_BLOCK;</span><br><span class="line">        <span class="keyword">return</span> (ctr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">/* Yes                                                    */</span></span><br><span class="line">        <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;    <span class="comment">/* Can&#x27;t pend when the scheduler is locked                */</span></span><br><span class="line">            CPU_CRITICAL_EXIT();</span><br><span class="line">           *p_err = OS_ERR_SCHED_LOCKED;</span><br><span class="line">            <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备阻塞任务了</span></span><br><span class="line">    OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  <span class="comment">/* Lock the scheduler/re-enable interrupts                */</span></span><br><span class="line">    OS_Pend(&amp;pend_data,                                     <span class="comment">/* Block task pending on Semaphore                        */</span></span><br><span class="line">            (OS_PEND_OBJ *)((<span class="type">void</span> *)p_sem),</span><br><span class="line">            OS_TASK_PEND_ON_SEM,</span><br><span class="line">            timeout);</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line"></span><br><span class="line">    OSSched();                                              <span class="comment">/* Find the next highest priority task ready to run       */</span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">switch</span> (OSTCBCurPtr-&gt;PendStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_OK:                             <span class="comment">/* We got the semaphore                                   */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  =  OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_NONE;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_ABORT:                          <span class="comment">/* Indicate that we aborted                               */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  =  OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_PEND_ABORT;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_TIMEOUT:                        <span class="comment">/* Indicate that we didn&#x27;t get semaphore within timeout   */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  = (CPU_TS  )<span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_TIMEOUT;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_DEL:                            <span class="comment">/* Indicate that object pended on has been deleted        */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  =  OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_OBJ_DEL;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_STATUS_INVALID;</span><br><span class="line">             CPU_CRITICAL_EXIT();</span><br><span class="line">             <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ctr = p_sem-&gt;Ctr;</span><br><span class="line">    CPU_CRITICAL_EXIT();</span><br><span class="line">    <span class="keyword">return</span> (ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是OSSemPost：（注意这个没有进入临界区）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">OS_SEM_CTR  <span class="title function_">OSSemPost</span> <span class="params">(OS_SEM  *p_sem,</span></span><br><span class="line"><span class="params">                       OS_OPT   opt,</span></span><br><span class="line"><span class="params">                       OS_ERR  *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_SEM_CTR  ctr;</span><br><span class="line">    CPU_TS      ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_sem == (OS_SEM *)<span class="number">0</span>) &#123;                             <span class="comment">/* Validate &#x27;p_sem&#x27;                                       */</span></span><br><span class="line">       *p_err  = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                          <span class="comment">/* Validate &#x27;opt&#x27;                                         */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_1:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_ALL:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err =  OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_sem-&gt;Type != OS_OBJ_TYPE_SEM) &#123;                   <span class="comment">/* Make sure semaphore was created                        */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ts = OS_TS_GET();                                       <span class="comment">/* Get timestamp                                          */</span></span><br><span class="line"><span class="comment">// 关调度器？</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ISR_POST_DEFERRED_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* See if called from an ISR                              */</span></span><br><span class="line">        OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           <span class="comment">/* Post to ISR queue                                      */</span></span><br><span class="line">                    (<span class="type">void</span>      *)p_sem,</span><br><span class="line">                    (<span class="type">void</span>      *)<span class="number">0</span>,</span><br><span class="line">                    (OS_MSG_SIZE)<span class="number">0</span>,</span><br><span class="line">                    (OS_FLAGS   )<span class="number">0</span>,</span><br><span class="line">                    (OS_OPT     )opt,</span><br><span class="line">                    (CPU_TS     )ts,</span><br><span class="line">                    (OS_ERR    *)p_err);</span><br><span class="line">        <span class="keyword">return</span> ((OS_SEM_CTR)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 关中断？</span></span><br><span class="line">    ctr = OS_SemPost(p_sem,                                 <span class="comment">/* Post to semaphore                                      */</span></span><br><span class="line">                     opt,</span><br><span class="line">                     ts,</span><br><span class="line">                     p_err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用操作就上面这些，简单理解下源码即可。然后下面是使用时的注意事项：</p>
<ul>
<li>计数型常用来做缓冲</li>
<li>信号量的使用需要谨慎，一些简单的操作可以直接使用关中断来实现，使用信号量就大材小用了。</li>
</ul>
<p>例子：如进行int型共享变量的自增，直接关中断，因为很快；而进行float运算，则需要使用信号量了，因为如果是关中断的话，那么中断的关闭时间会太久了，影响系统的实时性。</p>
<p>总之，牢记信号量被提出的目的：保证OS的实时性！</p>
<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>在讲互斥型信号量之前，先说明普通信号量存在的问题：<strong>优先级反转</strong>，如下图：<br><img src="/2022/05/26/MicroCOS-III/2022-06-13-22-53-55.png"></p>
<p>简单的来说，就是当LPT先得到信号量时，HPT再获取信号量，这时pend不到，将自身挂到内核对象对应的pend list中。</p>
<p>然后，就会出现这样的现象：<strong>所有其它高优先级的任务占据处理机，而我们最高优先级的HPT被挂起，等待LPT释放信号量，而Sem由于优先级太低得不到处理机</strong></p>
<p>上面这段过程中，存在着<strong>高优先级的任务得不到处理机，而低优先级的任务在运行的现象</strong>。</p>
<p>其根本原因是最先得到sem的LPT优先级太低了，所以，出现了mutex解决这个问题：最简单的，在HPT发现Sem被LPT获取后，将LPT的优先级暂时提升到和HPT一样。</p>
<h3 id="互斥型信号量"><a href="#互斥型信号量" class="headerlink" title="互斥型信号量"></a>互斥型信号量</h3><p>先看定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_MUTEX	TEST_MUTEX;</span><br></pre></td></tr></table></figure>
<p>再看结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">os_mutex</span> &#123;</span>                                          <span class="comment">/* Mutual Exclusion Semaphore                             */</span></span><br><span class="line">                                                            <span class="comment">/* ------------------ GENERIC  MEMBERS ------------------ */</span></span><br><span class="line">    OS_OBJ_TYPE          Type;                              <span class="comment">/* Should be set to OS_OBJ_TYPE_MUTEX                     */</span></span><br><span class="line">    CPU_CHAR            *NamePtr;                           <span class="comment">/* Pointer to Mutex Name (NUL terminated ASCII)           */</span></span><br><span class="line">    OS_PEND_LIST         PendList;                          <span class="comment">/* List of tasks waiting on mutex                         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">    OS_MUTEX            *DbgPrevPtr;</span><br><span class="line">    OS_MUTEX            *DbgNextPtr;</span><br><span class="line">    CPU_CHAR            *DbgNamePtr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                            <span class="comment">/* ------------------ SPECIFIC MEMBERS ------------------ */</span></span><br><span class="line">    OS_TCB              *OwnerTCBPtr;</span><br><span class="line">    OS_PRIO              OwnerOriginalPrio; <span class="comment">// 该字段存放的是占有mutex的任务之前的优先级，为了避免出现无界优先级反转的问题</span></span><br><span class="line">    <span class="comment">// 允许任务多次pend mutex，但是pend多少次就要post多少次；最高嵌套次数250</span></span><br><span class="line">    OS_NESTING_CTR       OwnerNestingCtr;                   <span class="comment">/* Mutex is available when the counter is 0               */</span></span><br><span class="line">    CPU_TS               TS; <span class="comment">/* 记录上一次被释放时的时间戳 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再看看使用mutex后，上一节的优先级反转就不存在了：<br><img src="/2022/05/26/MicroCOS-III/2022-06-13-23-21-21.png"></p>
<p>注意，和信号量一样，只有task能使用mutex，而ISR不行（中断事件越短越好）</p>
<p>下面看看mutex的API：<br><img src="/2022/05/26/MicroCOS-III/2022-06-13-23-34-55.png"></p>
<p>OSMutexCreate</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSMutexCreate</span> <span class="params">(OS_MUTEX  *p_mutex,</span></span><br><span class="line"><span class="params">                     CPU_CHAR  *p_name,</span></span><br><span class="line"><span class="params">                     OS_ERR    *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL_IEC61508</span></span><br><span class="line">    <span class="keyword">if</span> (OSSafetyCriticalStartFlag == DEF_TRUE) &#123;</span><br><span class="line">       *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* Not allowed to be called from an ISR                   */</span></span><br><span class="line">       *p_err = OS_ERR_CREATE_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex == (OS_MUTEX *)<span class="number">0</span>) &#123;                         <span class="comment">/* Validate &#x27;p_mutex&#x27;                                     */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER();</span><br><span class="line">    p_mutex-&gt;Type              =  OS_OBJ_TYPE_MUTEX;        <span class="comment">/* Mark the data structure as a mutex                     */</span></span><br><span class="line">    p_mutex-&gt;NamePtr           =  p_name;</span><br><span class="line">    p_mutex-&gt;OwnerTCBPtr       = (OS_TCB       *)<span class="number">0</span>;</span><br><span class="line">    p_mutex-&gt;OwnerNestingCtr   = (OS_NESTING_CTR)<span class="number">0</span>;         <span class="comment">/* Mutex is available                                     */</span></span><br><span class="line">    p_mutex-&gt;TS                = (CPU_TS        )<span class="number">0</span>;</span><br><span class="line">    p_mutex-&gt;OwnerOriginalPrio =  OS_CFG_PRIO_MAX;</span><br><span class="line">    OS_PendListInit(&amp;p_mutex-&gt;PendList);                    <span class="comment">/* Initialize the waiting list                            */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">    OS_MutexDbgListAdd(p_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OSMutexQty++;</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSMutexPend：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSMutexPend</span> <span class="params">(OS_MUTEX  *p_mutex,</span></span><br><span class="line"><span class="params">                   OS_TICK    timeout,</span></span><br><span class="line"><span class="params">                   OS_OPT     opt,</span></span><br><span class="line"><span class="params">                   CPU_TS    *p_ts,</span></span><br><span class="line"><span class="params">                   OS_ERR    *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_PEND_DATA  pend_data;</span><br><span class="line">    OS_TCB       *p_tcb;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_PEND_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex == (OS_MUTEX *)<span class="number">0</span>) &#123;                         <span class="comment">/* Validate arguments                                     */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                          <span class="comment">/* Validate &#x27;opt&#x27;                                         */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_BLOCKING:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_NON_BLOCKING:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;Type != OS_OBJ_TYPE_MUTEX) &#123;               <span class="comment">/* Make sure mutex was created                            */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">       *p_ts  = (CPU_TS  )<span class="number">0</span>;                                <span class="comment">/* Initialize the returned timestamp                      */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;OwnerNestingCtr == (OS_NESTING_CTR)<span class="number">0</span>) &#123;    <span class="comment">/* Resource available?                                    */</span></span><br><span class="line">        p_mutex-&gt;OwnerTCBPtr       =  OSTCBCurPtr;          <span class="comment">/* Yes, caller may proceed                                */</span></span><br><span class="line">        p_mutex-&gt;OwnerOriginalPrio =  OSTCBCurPtr-&gt;Prio;</span><br><span class="line">        p_mutex-&gt;OwnerNestingCtr   = (OS_NESTING_CTR)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">           *p_ts  = p_mutex-&gt;TS;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_NONE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OSTCBCurPtr == p_mutex-&gt;OwnerTCBPtr) &#123;              <span class="comment">/* See if current task is already the owner of the mutex  */</span></span><br><span class="line">        p_mutex-&gt;OwnerNestingCtr++;</span><br><span class="line">        <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">           *p_ts  = p_mutex-&gt;TS;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_MUTEX_OWNER;                         <span class="comment">/* Indicate that current task already owns the mutex      */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((opt &amp; OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)<span class="number">0</span>) &#123;    <span class="comment">/* Caller wants to block if not available?                */</span></span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    <span class="comment">/* No                                                     */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (OSSchedLockNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;    <span class="comment">/* Can&#x27;t pend when the scheduler is locked                */</span></span><br><span class="line">            CPU_CRITICAL_EXIT();</span><br><span class="line">           *p_err = OS_ERR_SCHED_LOCKED;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  <span class="comment">/* Lock the scheduler/re-enable interrupts                */</span></span><br><span class="line">    p_tcb = p_mutex-&gt;OwnerTCBPtr;                           <span class="comment">/* Point to the TCB of the Mutex owner                    */</span></span><br><span class="line">    <span class="keyword">if</span> (p_tcb-&gt;Prio &gt; OSTCBCurPtr-&gt;Prio) &#123;                  <span class="comment">/* See if mutex owner has a lower priority than current   */</span></span><br><span class="line">        <span class="keyword">switch</span> (p_tcb-&gt;TaskState) &#123;</span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_RDY:</span><br><span class="line">                 OS_RdyListRemove(p_tcb);                   <span class="comment">/* Remove from ready list at current priority             */</span></span><br><span class="line">                 p_tcb-&gt;Prio = OSTCBCurPtr-&gt;Prio;           <span class="comment">/* Raise owner&#x27;s priority                                 */</span></span><br><span class="line">                 OS_PrioInsert(p_tcb-&gt;Prio);</span><br><span class="line">                 OS_RdyListInsertHead(p_tcb);               <span class="comment">/* Insert in ready list at new priority                   */</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_DLY:</span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_DLY_SUSPENDED:</span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_SUSPENDED:</span><br><span class="line">                 p_tcb-&gt;Prio = OSTCBCurPtr-&gt;Prio;           <span class="comment">/* Only need to raise the owner&#x27;s priority                */</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_PEND:                        <span class="comment">/* Change the position of the task in the wait list       */</span></span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT:</span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_PEND_SUSPENDED:</span><br><span class="line">            <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:</span><br><span class="line">                 OS_PendListChangePrio(p_tcb,</span><br><span class="line">                                       OSTCBCurPtr-&gt;Prio);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                 OS_CRITICAL_EXIT();</span><br><span class="line">                *p_err = OS_ERR_STATE_INVALID;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OS_Pend(&amp;pend_data,                                     <span class="comment">/* Block task pending on Mutex                            */</span></span><br><span class="line">            (OS_PEND_OBJ *)((<span class="type">void</span> *)p_mutex),</span><br><span class="line">             OS_TASK_PEND_ON_MUTEX,</span><br><span class="line">             timeout);</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line"></span><br><span class="line">    OSSched();                                              <span class="comment">/* Find the next highest priority task ready to run       */</span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">switch</span> (OSTCBCurPtr-&gt;PendStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_OK:                             <span class="comment">/* We got the mutex                                       */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  = OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_NONE;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_ABORT:                          <span class="comment">/* Indicate that we aborted                               */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  = OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_PEND_ABORT;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_TIMEOUT:                        <span class="comment">/* Indicate that we didn&#x27;t get mutex within timeout       */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  = (CPU_TS  )<span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_TIMEOUT;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_STATUS_PEND_DEL:                            <span class="comment">/* Indicate that object pended on has been deleted        */</span></span><br><span class="line">             <span class="keyword">if</span> (p_ts != (CPU_TS *)<span class="number">0</span>) &#123;</span><br><span class="line">                *p_ts  = OSTCBCurPtr-&gt;TS;</span><br><span class="line">             &#125;</span><br><span class="line">            *p_err = OS_ERR_OBJ_DEL;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err = OS_ERR_STATUS_INVALID;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CPU_CRITICAL_EXIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSMutexPost</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OSMutexPost</span> <span class="params">(OS_MUTEX  *p_mutex,</span></span><br><span class="line"><span class="params">                   OS_OPT     opt,</span></span><br><span class="line"><span class="params">                   OS_ERR    *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_PEND_LIST  *p_pend_list;</span><br><span class="line">    OS_TCB        *p_tcb;</span><br><span class="line">    CPU_TS         ts;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;              <span class="comment">/* Not allowed to call from an ISR                        */</span></span><br><span class="line">       *p_err = OS_ERR_POST_ISR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex == (OS_MUTEX *)<span class="number">0</span>) &#123;                         <span class="comment">/* Validate &#x27;p_mutex&#x27;                                     */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                          <span class="comment">/* Validate &#x27;opt&#x27;                                         */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_NONE:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_POST_NO_SCHED:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err =  OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;Type != OS_OBJ_TYPE_MUTEX) &#123;               <span class="comment">/* Make sure mutex was created                            */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    <span class="keyword">if</span> (OSTCBCurPtr != p_mutex-&gt;OwnerTCBPtr) &#123;              <span class="comment">/* Make sure the mutex owner is releasing the mutex       */</span></span><br><span class="line">        CPU_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_MUTEX_NOT_OWNER;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();</span><br><span class="line">    ts          = OS_TS_GET();                              <span class="comment">/* Get timestamp                                          */</span></span><br><span class="line">    p_mutex-&gt;TS = ts;</span><br><span class="line">    p_mutex-&gt;OwnerNestingCtr--;                             <span class="comment">/* Decrement owner&#x27;s nesting counter                      */</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;OwnerNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;     <span class="comment">/* Are we done with all nestings?                         */</span></span><br><span class="line">        OS_CRITICAL_EXIT();                                 <span class="comment">/* No                                                     */</span></span><br><span class="line">       *p_err = OS_ERR_MUTEX_NESTING;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p_pend_list = &amp;p_mutex-&gt;PendList;</span><br><span class="line">    <span class="keyword">if</span> (p_pend_list-&gt;NbrEntries == (OS_OBJ_QTY)<span class="number">0</span>) &#123;         <span class="comment">/* Any task waiting on mutex?                             */</span></span><br><span class="line">        p_mutex-&gt;OwnerTCBPtr     = (OS_TCB       *)<span class="number">0</span>;       <span class="comment">/* No                                                     */</span></span><br><span class="line">        p_mutex-&gt;OwnerNestingCtr = (OS_NESTING_CTR)<span class="number">0</span>;</span><br><span class="line">        OS_CRITICAL_EXIT();</span><br><span class="line">       *p_err = OS_ERR_NONE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">                                                            <span class="comment">/* Yes                                                    */</span></span><br><span class="line">    <span class="keyword">if</span> (OSTCBCurPtr-&gt;Prio != p_mutex-&gt;OwnerOriginalPrio) &#123;</span><br><span class="line">        OS_RdyListRemove(OSTCBCurPtr);</span><br><span class="line">        OSTCBCurPtr-&gt;Prio = p_mutex-&gt;OwnerOriginalPrio;     <span class="comment">/* Lower owner&#x27;s priority back to its original one        */</span></span><br><span class="line">        OS_PrioInsert(OSTCBCurPtr-&gt;Prio);</span><br><span class="line">        OS_RdyListInsertTail(OSTCBCurPtr);                  <span class="comment">/* Insert owner in ready list at new priority             */</span></span><br><span class="line">        OSPrioCur         = OSTCBCurPtr-&gt;Prio;</span><br><span class="line">    &#125;</span><br><span class="line">                                                            <span class="comment">/* Get TCB from head of pend list                         */</span></span><br><span class="line">    p_tcb                      = p_pend_list-&gt;HeadPtr-&gt;TCBPtr;</span><br><span class="line">    p_mutex-&gt;OwnerTCBPtr       = p_tcb;                     <span class="comment">/* Give mutex to new owner                                */</span></span><br><span class="line">    p_mutex-&gt;OwnerOriginalPrio = p_tcb-&gt;Prio;</span><br><span class="line">    p_mutex-&gt;OwnerNestingCtr   = (OS_NESTING_CTR)<span class="number">1</span>;</span><br><span class="line">                                                            <span class="comment">/* Post to mutex                                          */</span></span><br><span class="line">    OS_Post((OS_PEND_OBJ *)((<span class="type">void</span> *)p_mutex),</span><br><span class="line">            (OS_TCB      *)p_tcb,</span><br><span class="line">            (<span class="type">void</span>        *)<span class="number">0</span>,</span><br><span class="line">            (OS_MSG_SIZE  )<span class="number">0</span>,</span><br><span class="line">            (CPU_TS       )ts);</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((opt &amp; OS_OPT_POST_NO_SCHED) == (OS_OPT)<span class="number">0</span>) &#123;</span><br><span class="line">        OSSched();                                          <span class="comment">/* Run the scheduler                                      */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSMutexDel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_MUTEX_DEL_EN &gt; 0u</span></span><br><span class="line">OS_OBJ_QTY  <span class="title function_">OSMutexDel</span> <span class="params">(OS_MUTEX  *p_mutex,</span></span><br><span class="line"><span class="params">                        OS_OPT     opt,</span></span><br><span class="line"><span class="params">                        OS_ERR    *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_OBJ_QTY     cnt;</span><br><span class="line">    OS_OBJ_QTY     nbr_tasks;</span><br><span class="line">    OS_PEND_DATA  *p_pend_data;</span><br><span class="line">    OS_PEND_LIST  *p_pend_list;</span><br><span class="line">    OS_TCB        *p_tcb;</span><br><span class="line">    OS_TCB        *p_tcb_owner;</span><br><span class="line">    CPU_TS         ts;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0</span>) &#123;                  <span class="comment">/* Not allowed to delete a mutex from an ISR          */</span></span><br><span class="line">       *p_err = OS_ERR_DEL_ISR;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex == (OS_MUTEX *)<span class="number">0</span>) &#123;                             <span class="comment">/* Validate &#x27;p_mutex&#x27;                                 */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                              <span class="comment">/* Validate &#x27;opt&#x27;                                     */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_DEL_NO_PEND:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_DEL_ALWAYS:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err =  OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;Type != OS_OBJ_TYPE_MUTEX) &#123;                   <span class="comment">/* Make sure mutex was created                        */</span></span><br><span class="line">       *p_err = OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER();</span><br><span class="line">    p_pend_list = &amp;p_mutex-&gt;PendList;</span><br><span class="line">    cnt         = p_pend_list-&gt;NbrEntries;</span><br><span class="line">    nbr_tasks   = cnt;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_DEL_NO_PEND:                                <span class="comment">/* Delete mutex only if no task waiting               */</span></span><br><span class="line">             <span class="keyword">if</span> (nbr_tasks == (OS_OBJ_QTY)<span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">                 OS_MutexDbgListRemove(p_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 OSMutexQty--;</span><br><span class="line">                 OS_MutexClr(p_mutex);</span><br><span class="line">                 OS_CRITICAL_EXIT();</span><br><span class="line">                *p_err = OS_ERR_NONE;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 OS_CRITICAL_EXIT();</span><br><span class="line">                *p_err = OS_ERR_TASK_WAITING;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_DEL_ALWAYS:                                            <span class="comment">/* Always delete the mutex                 */</span></span><br><span class="line">             p_tcb_owner = p_mutex-&gt;OwnerTCBPtr;                           <span class="comment">/* Did we had to change the prio of owner? */</span></span><br><span class="line">             <span class="keyword">if</span> ((p_tcb_owner       != (OS_TCB *)<span class="number">0</span>) &amp;&amp;</span><br><span class="line">                 (p_tcb_owner-&gt;Prio !=  p_mutex-&gt;OwnerOriginalPrio)) &#123;</span><br><span class="line">                 <span class="keyword">switch</span> (p_tcb_owner-&gt;TaskState) &#123;                         <span class="comment">/* yes                                     */</span></span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_RDY:</span><br><span class="line">                          OS_RdyListRemove(p_tcb_owner);</span><br><span class="line">                          p_tcb_owner-&gt;Prio = p_mutex-&gt;OwnerOriginalPrio;  <span class="comment">/* Lower owner&#x27;s prio back                 */</span></span><br><span class="line">                          OS_PrioInsert(p_tcb_owner-&gt;Prio);</span><br><span class="line">                          OS_RdyListInsertTail(p_tcb_owner);               <span class="comment">/* Insert owner in ready list at new prio  */</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_DLY:</span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_SUSPENDED:</span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_DLY_SUSPENDED:</span><br><span class="line">                          p_tcb_owner-&gt;Prio = p_mutex-&gt;OwnerOriginalPrio;  <span class="comment">/* Not in any pend list, change the prio   */</span></span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_PEND:</span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT:</span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_PEND_SUSPENDED:</span><br><span class="line">                     <span class="keyword">case</span> OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:</span><br><span class="line">                          OS_PendListChangePrio(p_tcb_owner,               <span class="comment">/* Owner is pending on another object      */</span></span><br><span class="line">                                                p_mutex-&gt;OwnerOriginalPrio);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">default</span>:</span><br><span class="line">                          OS_CRITICAL_EXIT();</span><br><span class="line">                         *p_err = OS_ERR_STATE_INVALID;</span><br><span class="line">                          <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             ts = OS_TS_GET();                                             <span class="comment">/* Get timestamp                           */</span></span><br><span class="line">             <span class="keyword">while</span> (cnt &gt; <span class="number">0u</span>) &#123;                                            <span class="comment">/* Remove all tasks from the pend list     */</span></span><br><span class="line">                 p_pend_data = p_pend_list-&gt;HeadPtr;</span><br><span class="line">                 p_tcb       = p_pend_data-&gt;TCBPtr;</span><br><span class="line">                 OS_PendObjDel((OS_PEND_OBJ *)((<span class="type">void</span> *)p_mutex),</span><br><span class="line">                               p_tcb,</span><br><span class="line">                               ts);</span><br><span class="line">                 cnt--;</span><br><span class="line">             &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_DBG_EN &gt; 0u</span></span><br><span class="line">             OS_MutexDbgListRemove(p_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             OSMutexQty--;</span><br><span class="line">             OS_MutexClr(p_mutex);</span><br><span class="line">             OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line">             OSSched();                                                    <span class="comment">/* Find highest priority task ready to run */</span></span><br><span class="line">            *p_err = OS_ERR_NONE;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">             OS_CRITICAL_EXIT();</span><br><span class="line">            *p_err = OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (nbr_tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSMutexPendAbort</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_MUTEX_PEND_ABORT_EN &gt; 0u</span></span><br><span class="line">OS_OBJ_QTY  <span class="title function_">OSMutexPendAbort</span> <span class="params">(OS_MUTEX  *p_mutex,</span></span><br><span class="line"><span class="params">                              OS_OPT     opt,</span></span><br><span class="line"><span class="params">                              OS_ERR    *p_err)</span></span><br><span class="line">&#123;</span><br><span class="line">    OS_PEND_LIST  *p_pend_list;</span><br><span class="line">    OS_TCB        *p_tcb;</span><br><span class="line">    CPU_TS         ts;</span><br><span class="line">    OS_OBJ_QTY     nbr_tasks;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_SAFETY_CRITICAL</span></span><br><span class="line">    <span class="keyword">if</span> (p_err == (OS_ERR *)<span class="number">0</span>) &#123;</span><br><span class="line">        OS_SAFETY_CRITICAL_EXCEPTION();</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_CALLED_FROM_ISR_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (OSIntNestingCtr &gt; (OS_NESTING_CTR)<span class="number">0u</span>) &#123;             <span class="comment">/* Not allowed to Pend Abort from an ISR                  */</span></span><br><span class="line">       *p_err =  OS_ERR_PEND_ABORT_ISR;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_ARG_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex == (OS_MUTEX *)<span class="number">0</span>) &#123;                         <span class="comment">/* Validate &#x27;p_mutex&#x27;                                     */</span></span><br><span class="line">       *p_err =  OS_ERR_OBJ_PTR_NULL;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;                                          <span class="comment">/* Validate &#x27;opt&#x27;                                         */</span></span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_ABORT_1:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_ABORT_ALL:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:</span><br><span class="line">        <span class="keyword">case</span> OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *p_err =  OS_ERR_OPT_INVALID;</span><br><span class="line">             <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CFG_OBJ_TYPE_CHK_EN &gt; 0u</span></span><br><span class="line">    <span class="keyword">if</span> (p_mutex-&gt;Type != OS_OBJ_TYPE_MUTEX) &#123;               <span class="comment">/* Make sure mutex was created                            */</span></span><br><span class="line">       *p_err =  OS_ERR_OBJ_TYPE;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    p_pend_list = &amp;p_mutex-&gt;PendList;</span><br><span class="line">    <span class="keyword">if</span> (p_pend_list-&gt;NbrEntries == (OS_OBJ_QTY)<span class="number">0u</span>) &#123;        <span class="comment">/* Any task waiting on mutex?                             */</span></span><br><span class="line">        CPU_CRITICAL_EXIT();                                <span class="comment">/* No                                                     */</span></span><br><span class="line">       *p_err =  OS_ERR_PEND_ABORT_NONE;</span><br><span class="line">        <span class="keyword">return</span> ((OS_OBJ_QTY)<span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();</span><br><span class="line">    nbr_tasks = <span class="number">0u</span>;</span><br><span class="line">    ts        = OS_TS_GET();                                <span class="comment">/* Get local time stamp so all tasks get the same time    */</span></span><br><span class="line">    <span class="keyword">while</span> (p_pend_list-&gt;NbrEntries &gt; (OS_OBJ_QTY)<span class="number">0u</span>) &#123;</span><br><span class="line">        p_tcb = p_pend_list-&gt;HeadPtr-&gt;TCBPtr;</span><br><span class="line">        OS_PendAbort((OS_PEND_OBJ *)((<span class="type">void</span> *)p_mutex),</span><br><span class="line">                     p_tcb,</span><br><span class="line">                     ts);</span><br><span class="line">        nbr_tasks++;</span><br><span class="line">        <span class="keyword">if</span> (opt != OS_OPT_PEND_ABORT_ALL) &#123;                 <span class="comment">/* Pend abort all tasks waiting?                          */</span></span><br><span class="line">            <span class="keyword">break</span>;                                          <span class="comment">/* No                                                     */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OS_CRITICAL_EXIT_NO_SCHED();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((opt &amp; OS_OPT_POST_NO_SCHED) == (OS_OPT)<span class="number">0u</span>) &#123;</span><br><span class="line">        OSSched();                                          <span class="comment">/* Run the scheduler                                      */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   *p_err = OS_ERR_NONE;</span><br><span class="line">    <span class="keyword">return</span> (nbr_tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>或抱死（deadly embrace），具体例子很熟悉了不阐述。</p>
<p>而解决死锁，教材上提到的是加入timeout。其原理是：破坏了死锁产生的几个必要条件中的<strong>请求保持和释放</strong>，不会一直保持pend状态，超时后就会返回错误，恢复到就绪态或运行态。</p>
<h1 id="任务同步"><a href="#任务同步" class="headerlink" title="任务同步"></a>任务同步</h1><h2 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h2><p>在前面一张已经讲过一些信号量（通过信号量进行资源管理），然后这一章是通过信号量进行任务同步（我们OS的所有任务都是异步执行的，而要想实现任务的顺序执行，也就是同步，那么可以采用信号量这种方式）</p>
<p>看下面这张图：<br><img src="/2022/05/26/MicroCOS-III/2022-06-16-23-08-44.png"></p>
<p>我们看到有两种方式：</p>
<ul>
<li>任务-任务-sem：任务可以post，也可以pend，灵活性很大</li>
<li>ISR-任务-sem：ISR只能post，不能pend，原因也很简单，若ISR进行pend等待，那么ISR的优先级总是高于任务，这样所有的任务都跑不了了。（？）</li>
</ul>
<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/26/MicroCOS-III/" data-id="cm9shytpt003bv7nncm7y6b1i" data-title="嵌入式操作系统-MicroCOS III" class="article-share-link">Share</a>
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/covers/IMG_2618.PNG" data-sizes="auto" alt="d2l" class="lazyload">
          
        
        <a href="/2023/07/31/d2l/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            d2l
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/covers/IMG_2578.JPG" data-sizes="auto" alt="rust-lang" class="lazyload">
        
      
      <a href="/2022/02/05/rust-lang/"></a>
      <div class="article-nav-caption">Older</div>
      <h3 class="article-nav-title">
        
          rust-lang
        
      </h3>
    </div>
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E6%96%AD%E4%BB%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">临界断代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">临界段代码的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E5%85%B3%E4%B8%AD%E6%96%AD%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">测量关中断的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8A%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">调度器上锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E9%94%81%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">测量锁调度器的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">任务优先级的分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%A1%AE%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">栈空间大小确定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B"><span class="toc-number">2.4.</span> <span class="toc-text">任务栈溢出检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8MPU-or-MMU"><span class="toc-number">2.4.1.</span> <span class="toc-text">使用MPU or MMU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">堆栈指针溢出检测寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">软件检测方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%A9%BA%E9%97%B2%E5%A0%86%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">计算空闲堆栈空间的数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">任务管理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">任务管理的内部原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCB"><span class="toc-number">2.6.2.</span> <span class="toc-text">TCB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.</span> <span class="toc-text">系统内部任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.1.</span> <span class="toc-text">空闲任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.2.</span> <span class="toc-text">时钟节拍任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">统计任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.4.</span> <span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.5.</span> <span class="toc-text">中断服务管理任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85"><span class="toc-number">2.7.6.</span> <span class="toc-text">额外补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">任务就绪表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8D%E6%98%A0%E5%B0%84%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">就绪优先级位映射表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">就绪任务列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%89%A5%E5%A4%BA%E5%9E%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">可剥夺型调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">调度点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">时间片轮转调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.4.</span> <span class="toc-text">调度的实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSSched"><span class="toc-number">4.4.1.</span> <span class="toc-text">OSSched()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSIntExit"><span class="toc-number">4.4.2.</span> <span class="toc-text">OSIntExit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSSchedRoundRobin"><span class="toc-number">4.4.3.</span> <span class="toc-text">OSSchedRoundRobin()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">任务切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSCtxSw"><span class="toc-number">5.1.</span> <span class="toc-text">OSCtxSw()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSIntCtxSw"><span class="toc-number">5.2.</span> <span class="toc-text">OSIntCtxSw()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84ISR"><span class="toc-number">6.1.</span> <span class="toc-text">典型的ISR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E5%86%85%E6%A0%B8%E5%8F%82%E4%B8%8E%E7%9A%84ISR"><span class="toc-number">6.2.</span> <span class="toc-text">无需内核参与的ISR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">多中断优先级的处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E4%B8%AD%E6%96%AD%E6%BA%90%E5%85%B1%E7%94%A8%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">所有中断源共用中断服务程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%BA%90%E9%83%BD%E6%9C%89%E4%B8%93%E9%97%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">每个中断源都有专门的中断服务程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%B8%83%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.</span> <span class="toc-text">直接发布和延迟发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.1.</span> <span class="toc-text">直接发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.2.</span> <span class="toc-text">延迟发布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.7.</span> <span class="toc-text">两种发布的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D"><span class="toc-number">6.8.</span> <span class="toc-text">时钟节拍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">任务挂起表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDly"><span class="toc-number">8.1.</span> <span class="toc-text">OSTimeDly()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDlyHMSM"><span class="toc-number">8.2.</span> <span class="toc-text">OSTimeDlyHMSM()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDlyResume"><span class="toc-number">8.3.</span> <span class="toc-text">OSTimeDlyResume()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeSet%E5%92%8COSTimeGet"><span class="toc-number">8.4.</span> <span class="toc-text">OSTimeSet和OSTimeGet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeTick"><span class="toc-number">8.5.</span> <span class="toc-text">OSTimeTick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OS-CFG-ISR-POST-DEFERRED-EN-1"><span class="toc-number">8.5.1.</span> <span class="toc-text">OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">定时器管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD-1"><span class="toc-number">10.1.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">锁调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.1.</span> <span class="toc-text">二进制信号量&#x2F;计数信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-number">10.3.2.</span> <span class="toc-text">优先级反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.3.</span> <span class="toc-text">互斥型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">10.3.4.</span> <span class="toc-text">死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">11.</span> <span class="toc-text">任务同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="toc-number">11.1.</span> <span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">12.</span> <span class="toc-text">消息传递</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2025
        <span class="footer-info-sep"></span>
        chengyiqiu
      </div>
      
        <div>
          Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          138.7k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          09:27
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E6%96%AD%E4%BB%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">临界断代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">临界段代码的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E5%85%B3%E4%B8%AD%E6%96%AD%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">测量关中断的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8A%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">调度器上锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E9%94%81%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">测量锁调度器的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">任务优先级的分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%A1%AE%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">栈空间大小确定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B"><span class="toc-number">2.4.</span> <span class="toc-text">任务栈溢出检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8MPU-or-MMU"><span class="toc-number">2.4.1.</span> <span class="toc-text">使用MPU or MMU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">堆栈指针溢出检测寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">软件检测方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%A9%BA%E9%97%B2%E5%A0%86%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">计算空闲堆栈空间的数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">任务管理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">任务管理的内部原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCB"><span class="toc-number">2.6.2.</span> <span class="toc-text">TCB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.</span> <span class="toc-text">系统内部任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.1.</span> <span class="toc-text">空闲任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.2.</span> <span class="toc-text">时钟节拍任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">统计任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.4.</span> <span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.5.</span> <span class="toc-text">中断服务管理任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85"><span class="toc-number">2.7.6.</span> <span class="toc-text">额外补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">任务就绪表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8D%E6%98%A0%E5%B0%84%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">就绪优先级位映射表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">就绪任务列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%89%A5%E5%A4%BA%E5%9E%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">可剥夺型调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">调度点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">时间片轮转调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.4.</span> <span class="toc-text">调度的实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSSched"><span class="toc-number">4.4.1.</span> <span class="toc-text">OSSched()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSIntExit"><span class="toc-number">4.4.2.</span> <span class="toc-text">OSIntExit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSSchedRoundRobin"><span class="toc-number">4.4.3.</span> <span class="toc-text">OSSchedRoundRobin()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">任务切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSCtxSw"><span class="toc-number">5.1.</span> <span class="toc-text">OSCtxSw()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSIntCtxSw"><span class="toc-number">5.2.</span> <span class="toc-text">OSIntCtxSw()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84ISR"><span class="toc-number">6.1.</span> <span class="toc-text">典型的ISR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E5%86%85%E6%A0%B8%E5%8F%82%E4%B8%8E%E7%9A%84ISR"><span class="toc-number">6.2.</span> <span class="toc-text">无需内核参与的ISR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">多中断优先级的处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E4%B8%AD%E6%96%AD%E6%BA%90%E5%85%B1%E7%94%A8%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">所有中断源共用中断服务程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%BA%90%E9%83%BD%E6%9C%89%E4%B8%93%E9%97%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">每个中断源都有专门的中断服务程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%B8%83%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.</span> <span class="toc-text">直接发布和延迟发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.1.</span> <span class="toc-text">直接发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8F%91%E5%B8%83"><span class="toc-number">6.6.2.</span> <span class="toc-text">延迟发布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.7.</span> <span class="toc-text">两种发布的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D"><span class="toc-number">6.8.</span> <span class="toc-text">时钟节拍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">任务挂起表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDly"><span class="toc-number">8.1.</span> <span class="toc-text">OSTimeDly()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDlyHMSM"><span class="toc-number">8.2.</span> <span class="toc-text">OSTimeDlyHMSM()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeDlyResume"><span class="toc-number">8.3.</span> <span class="toc-text">OSTimeDlyResume()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeSet%E5%92%8COSTimeGet"><span class="toc-number">8.4.</span> <span class="toc-text">OSTimeSet和OSTimeGet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSTimeTick"><span class="toc-number">8.5.</span> <span class="toc-text">OSTimeTick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OS-CFG-ISR-POST-DEFERRED-EN-1"><span class="toc-number">8.5.1.</span> <span class="toc-text">OS_CFG_ISR_POST_DEFERRED_EN&#x3D;1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">定时器管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD-1"><span class="toc-number">10.1.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">锁调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.1.</span> <span class="toc-text">二进制信号量&#x2F;计数信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-number">10.3.2.</span> <span class="toc-text">优先级反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.3.3.</span> <span class="toc-text">互斥型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">10.3.4.</span> <span class="toc-text">死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">11.</span> <span class="toc-text">任务同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="toc-number">11.1.</span> <span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">12.</span> <span class="toc-text">消息传递</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>






<script src="/js/pjax_script.js" data-pjax></script>

















  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.2' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

