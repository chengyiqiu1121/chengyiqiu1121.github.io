
  <!DOCTYPE html>
  <html lang="en"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>
    window.icon_font = '4552607_ikzjpc9jicn';
  </script>
  
  
  <title>
    rust-lang |
    
    Hexo
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="0.基本操作1.使用Clion开发Rust​	需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。 2.使用cargo创建库项目​	cargo new add –lib 3.打印地址123456789101112131415161718192021fn main() &#123;    let o &#x3D; Obj::new(1, 2, 3);    l">
<meta property="og:type" content="article">
<meta property="og:title" content="rust-lang">
<meta property="og:url" content="http://example.com/2022/02/05/rust-lang/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0.基本操作1.使用Clion开发Rust​	需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。 2.使用cargo创建库项目​	cargo new add –lib 3.打印地址123456789101112131415161718192021fn main() &#123;    let o &#x3D; Obj::new(1, 2, 3);    l">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220412225015836.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220412225123863.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114153100948.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114153226641.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114182046202.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114181038063.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114181940185.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220114182405990.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115132259157.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115132743008.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115132811413.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115133335999.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115133353197.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115134031494.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115135319262.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115140318148.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115141807954.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115142315424.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115144940387.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115144751616.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220115163757974.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116100625209.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116102055982.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116103815978.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116121716763.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116142000246.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220116152252174.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220119202214447.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220119202225682.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220120223838199.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220121151726938.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220122155108279.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220123150617915.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220123172820248.png">
<meta property="og:image" content="http://example.com/2022/02/05/rust-lang/image-20220214142148258.png">
<meta property="article:published_time" content="2022-02-05T00:32:12.000Z">
<meta property="article:modified_time" content="2022-06-26T12:12:16.138Z">
<meta property="article:author" content="chengyiqiu">
<meta property="article:tag" content="语言">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/05/rust-lang/image-20220412225015836.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 7.2.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/banner.jpg" alt="rust-lang">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>rust-lang</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-rust-lang" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2022/02/05/rust-lang/" class="article-date-link">
    <time datetime="2022-02-05T00:32:12.000Z" itemprop="datePublished">2022-02-05</time>
  </a>
</div>

      
  <div class="article-category wow slideInLeft">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h1><h2 id="1-使用Clion开发Rust"><a href="#1-使用Clion开发Rust" class="headerlink" title="1.使用Clion开发Rust"></a>1.使用Clion开发Rust</h2><p>​	需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。</p>
<h2 id="2-使用cargo创建库项目"><a href="#2-使用cargo创建库项目" class="headerlink" title="2.使用cargo创建库项目"></a>2.使用cargo创建库项目</h2><p>​	cargo new add –lib</p>
<h2 id="3-打印地址"><a href="#3-打印地址" class="headerlink" title="3.打印地址"></a>3.打印地址</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o</span> = Obj::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">adr</span> = &amp;o <span class="keyword">as</span> *<span class="keyword">const</span> Obj <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x&#123;:x&#125;&quot;</span>, adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    val1: <span class="type">u8</span>,</span><br><span class="line">    val2: <span class="type">u8</span>,</span><br><span class="line">    val3: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v1: <span class="type">u8</span>, v2: <span class="type">u8</span>, v3: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> Obj &#123;</span><br><span class="line">        Obj &#123;</span><br><span class="line">            val1: v1,</span><br><span class="line">            val2: v2,</span><br><span class="line">            val3: v3,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1-rust简介"><a href="#1-rust简介" class="headerlink" title="1 rust简介"></a>1 rust简介</h1><h2 id="1-1-基本特性"><a href="#1-1-基本特性" class="headerlink" title="1.1 基本特性"></a>1.1 基本特性</h2><p>特性</p>
<ul>
<li><p>运行时速度快</p>
</li>
<li><p>内存安全</p>
</li>
<li><p>并发</p>
<p>  rust是一门安全的语言，表现在类型安全和内存安全（横向对比c&#x2F;c++），同时性能也很好，因为没有GC（对比java），同时在设计的时候就考虑了多核处理器，支持并发，火狐公司的一个内核就是用rust写的，全并发执行。</p>
<p>  rust采的命名方法是：蛇形命名法，也就是字母小写单词之间加下划线</p>
<p>  rust的命令有rustc和rustup，rustc后面的c的意思是编译器。</p>
</li>
</ul>
<h2 id="1-2-命令行-vscode构建项目"><a href="#1-2-命令行-vscode构建项目" class="headerlink" title="1.2 命令行+vscode构建项目"></a>1.2 命令行+vscode构建项目</h2><p>步骤</p>
<ul>
<li>mkdir hello_rust创建工程目录</li>
<li>cd h*进入目录</li>
<li>code .用vscode打开该工程</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用的windows cmd命令</span><br><span class="line"><span class="number">1</span>. cd / -<span class="punctuation">-&gt;</span> 进入首盘，如c盘d盘</span><br><span class="line"><span class="number">2</span>. cd .. -<span class="punctuation">-&gt;</span> 进入上一级目录</span><br><span class="line"><span class="number">3</span>. dir -<span class="punctuation">-&gt;</span> 查看当当前目录下的文件 dir /a 是查看所有文件，包括隐藏文件</span><br><span class="line"><span class="number">4</span>. 可以用help cd查看cd的用法</span><br></pre></td></tr></table></figure>

<h2 id="1-3-编写hello-world程序"><a href="#1-3-编写hello-world程序" class="headerlink" title="1.3 编写hello world程序"></a>1.3 编写hello world程序</h2><ul>
<li>fn表示函数声明</li>
<li>rust采用的缩进不是tab，而是四个空格</li>
<li>println!是rust的宏，也就是rust micro</li>
<li>rust是预先编译的语言，也就是先编译好，然后生成二进制文件，可直接交给别人使用，而无需rust环境</li>
<li>rustc只适用于简单的rust文件，用cargo</li>
</ul>
<h2 id="1-4-cargo创建工程"><a href="#1-4-cargo创建工程" class="headerlink" title="1.4 cargo创建工程"></a>1.4 cargo创建工程</h2><pre><code>cargo是rust的创建及包管理工具

rust里代码的包称为crate
</code></pre>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows cmd</span><br><span class="line"><span class="number">1</span>.rmdir xxx -- remove dir</span><br><span class="line"><span class="number">2</span>.del xxx -- delete file</span><br></pre></td></tr></table></figure>

<p>cargo.toml文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.toml是cargo的配置文件</span><br><span class="line"><span class="number">2</span>.前一部分是项目的信息，如项目名称，package，版本信息作者等</span><br><span class="line"><span class="number">3</span>.后部分是项目依赖</span><br></pre></td></tr></table></figure>

<p>顶层目录可放置的信息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.README文件</span><br><span class="line"><span class="number">2</span>.许可信息</span><br><span class="line"><span class="number">3</span>.配置文件</span><br><span class="line"><span class="number">4</span>.其它与源程序无关的东西</span><br></pre></td></tr></table></figure>

<pre><code>当没有用cargo创建工程时，可以直接把文件拷贝到src下，然后再在顶层目录下编写一个cargo.toml文件即可
</code></pre>
<p>cargo.lock</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.负责追寻项目依赖的准确版本</span><br><span class="line"><span class="number">2</span>.不需要去修改这个文件</span><br></pre></td></tr></table></figure>

<p>使用cargo运行项目</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.cargo run会编译当前工程的main.rs及相关文件，然后再运行生成的exe文件</span><br><span class="line"><span class="number">2</span>.如果源代码没有更改过的话，就不编译了，之既然运行exe</span><br></pre></td></tr></table></figure>

<p>cargo check调试检查项目</p>
<pre><code>一般在开发的时候都是用的这个命令来进行检查调试，因为更快。

只有要生成文件的时候才会使用run/build指令

如果要发布的话，使用cargo build --release，这样编译的时候时间更久，会进行优化，提高编译出来的程序的性能
</code></pre>
<br>

<h1 id="2-rust基本语法"><a href="#2-rust基本语法" class="headerlink" title="2 rust基本语法"></a>2 rust基本语法</h1><h2 id="2-1-获取控制台输入"><a href="#2-1-获取控制台输入" class="headerlink" title="2.1 获取控制台输入"></a>2.1 获取控制台输入</h2><h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1.输入"></a>1.输入</h3><pre><code>std里提供了一个io，也就是标准输入输出，然后io里有一个关联函数叫stdin，是io里关于输入输出的输入那一部分，会返回一个句柄。然后stdin里有一个方法是read_line，读取命令行中的一行，这个方法可能抛出异常，所以该有一个except函数。

read_line会返回一个io::Result类型，也就是枚举类型，有两个值，一个是OK，另一个是Err，如果返回Err的话，就会中断当前程序，执行except那一部分。
</code></pre>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::io::stdin.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> string).<span class="title function_ invoke__">except</span>(<span class="string">&quot;exception message&quot;</span>);</span><br></pre></td></tr></table></figure>

<pre><code>关联函数类似于java中的静态方法。
</code></pre>
<p>​	rust会有一些默认的preclude的类型，预导入。要想使用其它的类型，需要使用use引入外部包。</p>
<p>​	<strong>use std::io</strong>表示引入了标准库下的io这个包，该包下的所有类型都可以通过io::xxx来使用。</p>
<p>​	**io::stdin()**会返回一个句柄。句柄就是一个指针，可以是一个数或者其它内容，将OS或者数据库的某块内存关联起来，这是百度上的解释。下面是官方文档中的解释，可以结合参考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A handle to the standard input stream of a process.</span><br><span class="line"></span><br><span class="line">Each handle is a shared reference to a global buffer of input data to this process. A handle can be lock’d to gain full access to BufRead <span class="title function_">methods</span> <span class="params">(e.g., .lines())</span>. Reads to this handle are otherwise locked with respect to other reads.</span><br></pre></td></tr></table></figure>



<h3 id="2-输出"><a href="#2-输出" class="headerlink" title="2.输出"></a>2.输出</h3><pre><code>println!宏
</code></pre>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;这是一个数字：&#123;&#125;&quot;</span>, number);</span><br></pre></td></tr></table></figure>

<pre><code>&#123;&#125;中的就是number。
</code></pre>
<h2 id="2-2-添加外部依赖包rand（修改toml文件）"><a href="#2-2-添加外部依赖包rand（修改toml文件）" class="headerlink" title="2.2 添加外部依赖包rand（修改toml文件）"></a>2.2 添加外部依赖包rand（修改toml文件）</h2><pre><code>在cargo.toml中添加bin结点。
</code></pre>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guess_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span></span><br><span class="line"><span class="comment"># 下面的部分是添加的代码，其中name是你的项目名称</span></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guess_game&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/test.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.5.0&quot;</span></span><br></pre></td></tr></table></figure>

<pre><code>然后cargo就会自动下载依赖包了。

为什么会自动下载包？

其实，是因为打开了rust server，这样就会自动去扫描toml里的依赖，检查版本并且及时下载对应的版本。

如果我们关闭这个server，那么更新toml中的依赖，工程文件中的包并不会更新，因为工程文件会去lock文件中去找到并使用对应的版本。这个时候不仅要修改toml，还要进行生级，也就是输入指令：cargo update。

但事实上使用这个指令需要换源，因为直接用的话，会提示超时，因为下载的源好像是github，需要用steam++加速或者换源。
</code></pre>
<p>​	cargo.lock文件是一个版本锁，锁住当前项目使用的包的版本。就算更新了toml文件，包也不会更新，除非使用cargo update</p>
<p>​	这里引入了一个Rng，是一个trait。若想使用类型A，A实现了trait B，那么需要同时use trait和类型。</p>
<p>​	这里就是引入了Rng和thread_rng()随机数生成器类型。</p>
<h2 id="2-3-使用枚举进行比较"><a href="#2-3-使用枚举进行比较" class="headerlink" title="2.3 使用枚举进行比较"></a>2.3 使用枚举进行比较</h2><pre><code>进行比较需要用到std下的cmp中的Ordering这个枚举类型。
</code></pre>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br></pre></td></tr></table></figure>

<pre><code>进行枚举时需要注意一下两个问题：
</code></pre>
<ul>
<li>类型一致</li>
<li>使用时大小等都得写全</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num1</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num2</span>: <span class="type">i32</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">match</span> num1.<span class="title function_ invoke__">cmp</span>(&amp;num2) &#123;</span><br><span class="line">    Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;=&quot;</span>),</span><br><span class="line">    Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&gt;&quot;</span>),</span><br><span class="line">    Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&lt;&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-处理异常"><a href="#2-4-处理异常" class="headerlink" title="2.4 处理异常"></a>2.4 处理异常</h2><pre><code>前面我们使用的是except方法来处理异常，如parse将字符串转换成数字时，会返回一个Result，根据这个类型是OK还是Err来判断是否执行except中的内容。如果Result中判定为Err的话，会直接中断当前程序，然后程序结束（崩溃）。这样我们的程序一遇到非法输入就崩溃，并不健壮。

所以这里我们用了上一节中的match模式匹配来处理这个问题。如果是OK的话，就执行ok的代码块，如果是Rrr的话再做相应的应对措施（如提示用户重新输入）
</code></pre>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u32</span> = <span class="keyword">match</span> num.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is not valid input, try again&quot;</span>, num.<span class="title function_ invoke__">trim</span>());</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;; <span class="comment">//将字符串转为u32类型，无符号整数32位</span></span><br></pre></td></tr></table></figure>

<p>​	下面是完整的猜数字代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::&#123;Rng, thread_rng&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::stdin;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ans</span> = <span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);<span class="comment">// 使用随机数生成器生成随机数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hander</span> = <span class="title function_ invoke__">stdin</span>();<span class="comment">// 创建句柄，可以复用</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里在里面创建了string类型，因为下面会使用shadow机制，会覆盖类型</span></span><br><span class="line"><span class="comment">        同时，句柄是会在str后面追加内容，所以这个string是一定不可以复用的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;enter a num: &quot;</span>);</span><br><span class="line">        hander.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;unknown error&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(i) =&gt; i,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;please enter a num&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;ans) &#123;</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;right&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ordering::Greater =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;greater&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Ordering::Less =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;less&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-变量及控制流"><a href="#3-变量及控制流" class="headerlink" title="3 变量及控制流"></a>3 变量及控制流</h1><h2 id="3-1变量"><a href="#3-1变量" class="headerlink" title="3.1变量"></a>3.1变量</h2><h3 id="3-1-1-不可变变量"><a href="#3-1-1-不可变变量" class="headerlink" title="3.1.1 不可变变量"></a>3.1.1 不可变变量</h3><p>​	使用let关键字声明，将等号右边的值绑定到等号左侧。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// num = 2;错误，不可变变量无法二次绑定</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-可变变量"><a href="#3-1-2-可变变量" class="headerlink" title="3.1.2 可变变量"></a>3.1.2 可变变量</h3><p>​	mutable，可变化的，还是使用let声明</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line">num = num + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-常量"><a href="#3-1-3-常量" class="headerlink" title="3.1.3 常量"></a>3.1.3 常量</h3><p>​		常量用const声明（constant的意思），常量必须显式声明数据类型，无法自动推断。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_LEN: <span class="type">u8</span> = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>​	其实工程中大多数都是不可变类型的变量。</p>
<h2 id="3-2-shadow机制"><a href="#3-2-shadow机制" class="headerlink" title="3.2 shadow机制"></a>3.2 shadow机制</h2><p>​	变量可以被隐藏。如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = string.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = string + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;string is &#123;&#125;&quot;</span>, string);</span><br></pre></td></tr></table></figure>

<p>​	此机制是为了避免以下情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name_string</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">name_length</span> <span class="operator">=</span> name_string.length();</span><br></pre></td></tr></table></figure>

<p>​	隐藏变量在在作用域外被定义，并绑定值后，在另一个作用域中被shadow后，出了此作用域，隐藏的变量会恢复。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="number">65535</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出hello</span></span><br></pre></td></tr></table></figure>

<p>ps：shadow机制的实际意义是，重新创建了一个新的变量，这个变量可以有新的值，而它的意义就是既能够进行<strong>变量名称的复用</strong>，也能够<strong>不增加新的变量</strong>。</p>
<h2 id="3-3-标量类型"><a href="#3-3-标量类型" class="headerlink" title="3.3 标量类型"></a>3.3 标量类型</h2><p>​	rust是静态数据类型，在编译时就需要所有变量的具体数据类型。并且rust提供了类型推断机制，根据值的类型和具体的使用情况，可以推断出变量的类型。若是不能推断出，编译器便会报错，需要我们给出更多的信息（一般是需要显示声明了就）。如下：</p>
<p><img src="/2022/02/05/rust-lang/image-20220412225015836.png" alt="image-20220412225015836"></p>
<p>​	无法推断出字符串会转换成什么类型。所以需要我们显示声明：</p>
<p><img src="/2022/02/05/rust-lang/image-20220412225123863.png" alt="image-20220412225123863"></p>
<h3 id="3-3-1-整数"><a href="#3-3-1-整数" class="headerlink" title="3.3.1 整数"></a>3.3.1 整数</h3><p>​	整数的类型：</p>
<p>​													 <img src="/2022/02/05/rust-lang/image-20220114153100948.png" alt="image-20220114153100948"></p>
<p>​	其中isize和usize和机器的位数有关，一般不用。</p>
<p>​	整数的字面量表示：</p>
<p><img src="/2022/02/05/rust-lang/image-20220114153226641.png" alt="image-20220114153226641"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">adr</span> = <span class="number">0x1234_5678u64</span><span class="comment">//无符号64位16进制数</span></span><br></pre></td></tr></table></figure>

<p>​	整数的默认类型一般是i32，比较快。	</p>
<p>​	下面是整数溢出的情况：</p>
<ul>
<li>调试模式下：会发生panic（恐慌）</li>
<li>发布模式：不发生panic，选择环绕操作，即256&#x3D;0</li>
</ul>
<h3 id="3-3-2-浮点"><a href="#3-3-2-浮点" class="headerlink" title="3.3.2 浮点"></a>3.3.2 浮点</h3><p>​	两种类型：</p>
<ul>
<li>f64</li>
<li>f32</li>
</ul>
<p>​    一般是采用f64</p>
<h3 id="3-3-3-bool类型"><a href="#3-3-3-bool类型" class="headerlink" title="3.3.3 bool类型"></a>3.3.3 bool类型</h3><p>​	true或者false。</p>
<p>​	占用大小一个Byte</p>
<p>​	为什么不用一个bit？因为如果用一位的话不利于存储，会产生内存碎片。</p>
<h3 id="3-3-4-字符类型"><a href="#3-3-4-字符类型" class="headerlink" title="3.3.4 字符类型"></a>3.3.4 字符类型</h3><p>​	char</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">yeye</span> = &#x27;👴&#x27;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, yeye);</span><br></pre></td></tr></table></figure>

<h2 id="3-4-复合类型"><a href="#3-4-复合类型" class="headerlink" title="3.4 复合类型"></a>3.4 复合类型</h2><h3 id="3-4-1-元组Tuple"><a href="#3-4-1-元组Tuple" class="headerlink" title="3.4.1 元组Tuple"></a>3.4.1 元组Tuple</h3><p>​	每个位置对应一个类型，类型不必相同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tp</span> = (<span class="number">1</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;S&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, tp.<span class="number">0</span>, tp.<span class="number">1</span>, tp.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​	元组赋值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tp</span> = (<span class="number">1</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;S&quot;</span>);</span><br><span class="line"><span class="comment">// println!(&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;, tp.0, tp.1, tp.2);</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tp;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-数组"><a href="#3-4-2-数组" class="headerlink" title="3.4.2 数组"></a>3.4.2 数组</h3><p>​	和其他语言类似</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-5-Vector"><a href="#3-4-5-Vector" class="headerlink" title="3.4.5 Vector"></a>3.4.5 Vector</h3><p>​	大小可变，用的更多。</p>
<h2 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h2><p>​	函数声明，函数名，参数列表，返回值。这是声明函数的全过程。</p>
<p>​	代码块里的最后一行没加分号，代表是返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">32</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	或者这样也行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-if-else"><a href="#3-6-if-else" class="headerlink" title="3.6 if-else"></a>3.6 if-else</h2><p>​	第一种用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">cdt</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">if</span> cdt &#123; <span class="number">1</span> &#125; <span class="keyword">else</span> &#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<p>​	第二种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">cdt</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span>;</span><br><span class="line"><span class="keyword">if</span> cdt &#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<p>​	如果ifelse嵌套太多，使用模式匹配吧。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">cdt</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">match</span> cdt &#123;</span><br><span class="line">    <span class="literal">true</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="literal">false</span> =&gt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<h2 id="3-7-循环"><a href="#3-7-循环" class="headerlink" title="3.7 循环"></a>3.7 循环</h2><h3 id="3-7-1-loop"><a href="#3-7-1-loop" class="headerlink" title="3.7.1 loop"></a>3.7.1 loop</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, count);</span><br><span class="line">    <span class="keyword">if</span> count &gt;<span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2-while"><a href="#3-7-2-while" class="headerlink" title="3.7.2 while"></a>3.7.2 while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">100</span> &#123;</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3-for-each"><a href="#3-7-3-for-each" class="headerlink" title="3.7.3 for - each"></a>3.7.3 for - each</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> arr &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>60s倒计时</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">61</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-所有权"><a href="#4-所有权" class="headerlink" title="4 所有权"></a>4 所有权</h1><p>​	rust采用所有权系统来管理内存。并且，是在编译时检查，这样就不会减慢程序运行的速度。无运行时开销。</p>
<p><img src="/2022/02/05/rust-lang/image-20220114182046202.png" alt="image-20220114182046202"></p>
<h2 id="4-1-栈内存与堆内存"><a href="#4-1-栈内存与堆内存" class="headerlink" title="4.1 栈内存与堆内存"></a>4.1 栈内存与堆内存</h2><ul>
<li>堆栈：LIFO，last in first out，后进先出</li>
<li>堆：OS给用户在heap上找到一块足够大的区域，标记为在用，然后返回给用户。这就是在堆上分配内存。</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220114181038063.png" alt="image-20220114181038063"></p>
<p>​	堆是通过分配来得到内存，而栈不同，栈是直接将数据存放到那一个格子就行了，不需要分配。</p>
<p>​	栈上分配的内存是固定不变的，如数组。而堆上分配的内存可以动态变化，也就是可变数组，像C语言里的动态内存分配，就是在堆上分配空间，然后返回一个指针给用户（malloc函数返回指针）。而这个指针由于是固定大小，所以可以存到栈上去。</p>
<p>​	在堆上分配空间更慢，因为OS需要找到一块足够大的空间。而在栈上就比较快了，因为这个空间肯定在栈的顶端。</p>
<p>​	在堆上访问数据也慢，因为需要通过指针寻址来访问，是间接访问，需要跳转，从栈-&gt;堆，比较慢；而从栈上访问数据就不一样了，因为是栈-&gt;栈，所以快。</p>
<p><img src="/2022/02/05/rust-lang/image-20220114181940185.png" alt="image-20220114181940185"></p>
<h2 id="4-2-所有权规则"><a href="#4-2-所有权规则" class="headerlink" title="4.2 所有权规则"></a>4.2 所有权规则</h2><p><img src="/2022/02/05/rust-lang/image-20220114182405990.png" alt="image-20220114182405990"></p>
<p>​	简化：在一个时间内，每个值有且只有一个变量，并且当所有者超出作用域时，所有者及其值将被删除。</p>
<h2 id="4-3-初识String"><a href="#4-3-初识String" class="headerlink" title="4.3 初识String"></a>4.3 初识String</h2><p>​	之前的标量数据类型都是存储在stack上的，一旦离开作用域就会被弹出。</p>
<p>​	而String是一种存放在heap上的数据类型。	</p>
<p>​	String可以代表std中复杂的数据类型，或者是我们自己创建的数据类型。</p>
<p>​	在程序运行中，有两种字符串：</p>
<ul>
<li>字符串字面量：是不可变的。在程序运行之前，即在编译期间，就可以知道其内容了，所以直接硬编码到可执行文件中了。所以在运行期间就不需要额外的内存了，高效。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>; <span class="comment">//hello就是一个字符串字面量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>String类型：可变的，如获取用户的输入是，是不可预知的，用的就是String。String是在运行期间才会在heap上分配内存，通过from函数向OS申请内存。然后变变量超出作用域后，救会通过drop函数回收内存（自动的）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//从字符串字面量创建一个String类型</span></span><br></pre></td></tr></table></figure>

<p>​	下面解释一段程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>

<p>​	第一行向heap申请了一块内存。具体是如下：在堆上申请了一块空间，存放hello字符数组，然后返回这个字符数组的三个信息：起始地址，长度，容量。返回给s1接收。</p>
<p><img src="/2022/02/05/rust-lang/image-20220115132259157.png" alt="image-20220115132259157"></p>
<p>​	第二行是将s1的指针考培给了s2，包括heap指针，len和capacity。然后按照常规的思路，s1 s2都离开作用域时，都会进行drop回收内存。这样一块heap内存被回收了两次，是不安全的。</p>
<p>​	为了解决这个，在将s1指针拷贝给了s2后，也就是MOVE操作后，s1的内容被废弃，再次调用将出现报错。然后s1s2离开作用域后，只有s2指向的heap会被drop掉。</p>
<p><img src="/2022/02/05/rust-lang/image-20220115132743008.png" alt="image-20220115132743008"></p>
<p><img src="/2022/02/05/rust-lang/image-20220115132811413.png" alt="image-20220115132811413"></p>
<p>​	这样无疑更安全，也不会在堆上重新分配空间。</p>
<p>​	以上其实是一种浅拷贝，然是由于s1时失效了，于是创建了新的术语叫MOVE。</p>
<ul>
<li>浅拷贝 – MOVE移动</li>
<li>深拷贝 – CLONE克隆</li>
</ul>
<p>​    Rust所有的操作都是廉价的浅拷贝操作，不会开辟新的heap内存，除非是这样要求的。</p>
<p>​	下面的深拷贝，即克隆的操作。</p>
<p><img src="/2022/02/05/rust-lang/image-20220115133335999.png" alt="image-20220115133335999"></p>
<p><img src="/2022/02/05/rust-lang/image-20220115133353197.png" alt="image-20220115133353197"></p>
<p>​	而在栈上进行的MOVE，先前声明的变量就不会失效。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>; <span class="comment">//useful</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">//useful</span></span><br></pre></td></tr></table></figure>

<p>​	可以用下面两个概念来解释：</p>
<ul>
<li>Copy trait（复制特性）：实现了Copy trait的数据结构，在赋值后旧的变量仍然有效。</li>
<li>Drop trait（回收特性）：实现了Drop trait的数据结构，不能再实现Copy trait</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220115134031494.png" alt="image-20220115134031494"></p>
<h2 id="4-4-函数与所有权"><a href="#4-4-函数与所有权" class="headerlink" title="4.4 函数与所有权"></a>4.4 函数与所有权</h2><p>​	将值窜给函数，要么会发生移动（Move），要么发生复制（Copy）</p>
<p><img src="/2022/02/05/rust-lang/image-20220115135319262.png" alt="image-20220115135319262"></p>
<ul>
<li>copy trait的数据类型被传入时（i32）：传进去的时副本，在函数结束的时候，副本会被弹出stack</li>
<li>drop trait数据类型被传入时（String）：传进去后，旧的变量丧失所有权，回收时不再使用drop清理heap内存。传进去的数据获得所有权，在函数结束时弹出堆栈并且使用drop回收堆内存</li>
</ul>
<p>​    如果想即使用所有权，还能返回回来的话，可以使用元组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> (s1, len) = <span class="title function_ invoke__">get_len</span>(s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;   &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_len</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    (s, l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-引用"><a href="#4-5-引用" class="headerlink" title="4.5 引用"></a>4.5 引用</h2><p>​	引用：引用数据的值而不使用其所有权。&amp;符号表示</p>
<p><img src="/2022/02/05/rust-lang/image-20220115140318148.png" alt="image-20220115140318148"></p>
<p>引用分类：</p>
<ul>
<li>不可变引用：不能修改指向堆上的数据</li>
<li>可变引用：可以修改指向堆上的数据</li>
<li>悬空引用：引用指向的数据已经被释放，而引用依然有效（Rust在编译期杜绝了这个问题）</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220115141807954.png" alt="image-20220115141807954"></p>
<p>​	有以下规则： </p>
<ul>
<li>一个作用域内只能有一个可变引用</li>
<li>一个作用域内可以有多个不可变引用</li>
<li>同一个作用域内可变引用与不可变引用不能同时存在</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220115142315424.png" alt="image-20220115142315424"></p>
<p>​	可以看到：先声明了俩不可变的引用，然后声明了一个可变引用。如果不对不可变引用做操作的话，不会报错。如果在声明了可变引用后，还对不可变引用进行操作，这样就会报错。</p>
<h2 id="4-5-切片"><a href="#4-5-切片" class="headerlink" title="4.5 切片"></a>4.5 切片</h2><p><img src="/2022/02/05/rust-lang/image-20220115144940387.png" alt="image-20220115144940387"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ssss ssss&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">indx</span> = <span class="title function_ invoke__">get_space_index</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, indx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_space_index</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> p1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面的代码是获取第一个空格所在的位置。</p>
<p>​	bug：当字符串被清空了后，得到的index不会发生改变，也就是同步性的问题。要保证：在字符串改变的同时，这个index也会同步改变。这很困难。</p>
<p>​	rust可以采用切片解决这个问题。</p>
<p><img src="/2022/02/05/rust-lang/image-20220115144751616.png" alt="image-20220115144751616"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ssss ssss&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">indx</span> = <span class="title function_ invoke__">get_space_index</span>(&amp;s[..]);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">//报错，这个方法会创建一个可变的引用，与上一行的不可变引用冲突 </span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, indx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_space_index</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> p1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i]; <span class="comment">//[0, i)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	因为函数里面采用了字符串切片，也就是不可变引用，所以修改时报错。</p>
<p>​	注意：字符串切片仅仅针对UTF-8的字符，两字节的汉字会报错。</p>
<p>​	还做了一个优化，把字符串引用修改成为了字符串切片，这样就能同时接收两种类型了(&amp;String -&gt; &amp;str)。如字符串字面量（&amp;str）和String类型。</p>
<p>​	数组也可以切片，和上面类似。</p>
<h1 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h1><h2 id="5-1-结构定义"><a href="#5-1-结构定义" class="headerlink" title="5.1 结构定义"></a>5.1 结构定义</h2><p>​	三类：</p>
<ul>
<li>struct：普通结构</li>
<li>tuple struct：元组结构，当你想给元组起名字的时候，使用它。</li>
<li>Unit - like - struct：无任何字段的结构</li>
</ul>
<p>​	普通结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">jack</span> = <span class="title function_ invoke__">get_user</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;jack&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;12222@qq.com&quot;</span>), <span class="literal">true</span>, <span class="number">1111</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, jack.active);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_user</span>(name: <span class="type">String</span>, email: <span class="type">String</span>, active: <span class="type">bool</span>, id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        name,</span><br><span class="line">        email,</span><br><span class="line">        active,</span><br><span class="line">        id,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	元组结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-结构实例"><a href="#5-2-结构实例" class="headerlink" title="5.2 结构实例"></a>5.2 结构实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = rectangle&#123;</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        length: <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">get_area</span>(&amp;r1));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, r1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_area</span>(rec: &amp;rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rec.length * rec.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	Rust中有类似与java的toString方法，或者说是trait，但是默认没有实现，所以我们就用的是debug特性。</p>
<p><img src="/2022/02/05/rust-lang/image-20220115163757974.png" alt="image-20220115163757974"></p>
<ul>
<li>#[derive(Debug)]：实现debug trait</li>
<li>{:?}：输出结构的信息，不换行</li>
<li>{:#?}：输出结构的信息，换行</li>
</ul>
<h2 id="5-3-struct方法"><a href="#5-3-struct方法" class="headerlink" title="5.3 struct方法"></a>5.3 struct方法</h2><p>​	两种：</p>
<ul>
<li>方法：方法用impl定义的块去实现，需要传递它本身（或本身的引用）</li>
<li>关联函数：不需要传递本身，只是跟这个结构有关联，类似静态函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length &gt;= other.length &amp;&amp; <span class="keyword">self</span>.width &gt;= other.width</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sqare</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> rectangle &#123;</span><br><span class="line">        rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        length: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = rectangle &#123;</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        length: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        length: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r2.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r1.<span class="title function_ invoke__">can_hold</span>(&amp;r2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r1.<span class="title function_ invoke__">can_hold</span>(&amp;r3));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r4</span> = rectangle::<span class="title function_ invoke__">sqare</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-枚举与模式匹配"><a href="#6-枚举与模式匹配" class="headerlink" title="6 枚举与模式匹配"></a>6 枚举与模式匹配</h1><h2 id="6-1-定义枚举"><a href="#6-1-定义枚举" class="headerlink" title="6.1 定义枚举"></a>6.1 定义枚举</h2><p>​	rust的枚举很强大。可以自定义枚举并存储数据，不需要消耗额外的结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddrKind::<span class="title function_ invoke__">V4</span>(<span class="number">120</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = IpAddrKind::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	枚举也可以定义方法。与结构体相同使用impl</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">express</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-Option枚举"><a href="#6-2-Option枚举" class="headerlink" title="6.2 Option枚举"></a>6.2 Option<T>枚举</T></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Sdssdffdsdsds&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n2</span>:<span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-match"><a href="#6-3-match" class="headerlink" title="6.3 match"></a>6.3 match</h2><p>​	math允许一个值与一系列的模式进行匹配，并执行匹配上的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Fir,</span><br><span class="line">    <span class="title function_ invoke__">Fun</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_fun</span>(one_day: &amp;Week) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> one_day &#123;</span><br><span class="line">            Week::<span class="title function_ invoke__">Fun</span>(statement) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, statement);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Week::Mon =&gt; <span class="literal">false</span>,</span><br><span class="line">            Week::Fir =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">day</span> = Week::<span class="title function_ invoke__">Fun</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;no need to work!!!&quot;</span>));</span><br><span class="line">    Week::<span class="title function_ invoke__">is_fun</span>(&amp;day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面通过枚举存储了数据（String），并且通过模式匹配，将数据与statement绑定，重现了数据。</p>
<p>​	match必须列举所有的值进行匹配，若值太多了，使用_来代表其他的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Tue,</span><br><span class="line">    Wed,</span><br><span class="line">    Thi,</span><br><span class="line">    Fir,</span><br><span class="line">    <span class="title function_ invoke__">Fun</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_fun</span>(one_day: &amp;Week) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> one_day &#123;</span><br><span class="line">            Week::<span class="title function_ invoke__">Fun</span>(statement) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, statement);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Week::Mon =&gt; <span class="literal">false</span>,</span><br><span class="line">            Week::Fir =&gt; <span class="literal">false</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-4-if-let语法糖"><a href="#6-4-if-let语法糖" class="headerlink" title="6.4 if-let语法糖"></a>6.4 if-let语法糖</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Tue,</span><br><span class="line">    Wed,</span><br><span class="line">    Thi,</span><br><span class="line">    Fir,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">day</span> = Week::Fir;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">day</span> = Week::Fir &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;this is Firday&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;nonono&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Tue,</span><br><span class="line">    Wed,</span><br><span class="line">    Thi,</span><br><span class="line">    Fir,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">day</span> = Week::Fir;</span><br><span class="line">    <span class="keyword">match</span> day &#123;</span><br><span class="line">        Week::Fir =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;this is Firday&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;nonono&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-package-crate-module"><a href="#7-package-crate-module" class="headerlink" title="7  package crate module"></a>7  package crate module</h1><p><img src="/2022/02/05/rust-lang/image-20220116100625209.png" alt="image-20220116100625209"></p>
<h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h2><p>​	自顶向下：</p>
<ul>
<li><p>Package：通过cargo可以创建一个新的包，位于最顶层。</p>
</li>
<li><p>Crate：cargo创建完包后，下面的.rs文件，有的会生成binary二进制文件（main.rs就是默认创建的binary文件，crate root），有的是产生library（其它的非main.rs文件）。Crate只能是以下两种类型：</p>
<ul>
<li>binary</li>
<li>library</li>
</ul>
</li>
<li><p>Module：在一个.rs文件中，可以定义多个module。</p>
</li>
<li><p>Path：</p>
</li>
</ul>
<p>​	还有一个概念叫crate root，是.rs源代码文件，编译器从这里开始组成我们的Module文件。</p>
<p>​	下面是Package的描述：</p>
<p><img src="/2022/02/05/rust-lang/image-20220116102055982.png" alt="image-20220116102055982"></p>
<p>​	crate可以把相关的功能整合到一个作用域内，还可以避免命名冲突。</p>
<p>​	Module是在一个crate内，将代码进行分组，可以复用，并且可以控制代码的权限（pub or pri）。mod还是可以嵌套的。</p>
<h2 id="7-2-权限"><a href="#7-2-权限" class="headerlink" title="7.2 权限"></a>7.2 权限</h2><p><img src="/2022/02/05/rust-lang/image-20220116103815978.png" alt="image-20220116103815978"></p>
<p>​	同级可以互相调用，父级不能调用子级的私有，子级可以调用所有父级的，无论暴露与否。外层mod加上了pub，里层的函数没加，函数依然是pri的。所以外面的mod里面的fn都需要加上pub才行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> father &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> son_1 &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun1</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> son_2 &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fun2</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">testtt</span>() &#123;</span><br><span class="line">    crate::father::son_1::<span class="title function_ invoke__">fun1</span>();</span><br><span class="line">    crate::father::son_2::<span class="title function_ invoke__">fun2</span>(); <span class="comment">//报错，提示函数和mod都是私有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	访问函数可以通过绝对路径和相对路径。建议绝对路径。</p>
<ul>
<li>绝对路径：<code>crate::father::son_1::fun1();</code></li>
<li>相对路径：<ul>
<li><code>father::son_1::fun1();</code></li>
<li>子级在调用父级的函数时，可以通过<code>super关键字</code></li>
</ul>
</li>
</ul>
<h2 id="7-3-结构的权限"><a href="#7-3-结构的权限" class="headerlink" title="7.3 结构的权限"></a>7.3 结构的权限</h2><p>​	结构默认为pri，并且结构的字段也是pri的，如果像设置乘公有的，加上pub</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> father &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">eat</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> time: (<span class="type">u16</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">        <span class="keyword">pub</span> food: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">eat</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">to_eat</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;is eating &#123;&#125; at &#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>, <span class="keyword">self</span>.food, <span class="keyword">self</span>.time.<span class="number">0</span>, <span class="keyword">self</span>.time.<span class="number">1</span>, <span class="keyword">self</span>.time.<span class="number">2</span>, <span class="keyword">self</span>.time.<span class="number">3</span>, <span class="keyword">self</span>.time.<span class="number">4</span>);</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">testtt</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">jack</span> = crate::father::eat &#123;</span><br><span class="line">        time: (<span class="number">2022</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">12</span>),</span><br><span class="line">        food: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;kaoji&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    jack.<span class="title function_ invoke__">to_eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-枚举的权限"><a href="#7-4-枚举的权限" class="headerlink" title="7.4 枚举的权限"></a>7.4 枚举的权限</h2><p>​	枚举前面加上pub后，其里面的枚举变体自动变成公共的了。</p>
<h2 id="7-5-use的使用"><a href="#7-5-use的使用" class="headerlink" title="7.5 use的使用"></a>7.5 use的使用</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>​	针对函数，use一般时引用它的上一级mod，而不是直接引入到函数本身，这样增强代码的可读性，避免函数冲突了。</p>
<p>​	而针对结构struct，enum的话，就是引入到本身，而不是父级条目。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> father &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> son &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">eat</span> &#123;</span><br><span class="line">            <span class="keyword">pub</span> time: (<span class="type">u16</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">            <span class="keyword">pub</span> food: <span class="type">String</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cry</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;wawawawa&quot;</span>);</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> crate::father::son;</span><br><span class="line"><span class="keyword">use</span> crate::father::son::eat;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">testtttt</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = eat &#123;</span><br><span class="line">        time: (<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>),</span><br><span class="line">        food: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sasa&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    son::<span class="title function_ invoke__">cry</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于有同名的数据结构，有以下两种做法：</p>
<ul>
<li>像函数一样，引入到父级条目下就停止，不到该数据结构。</li>
<li>可以使用别名，用as，指定一个别名。</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220116121716763.png" alt="image-20220116121716763"></p>
<p>​	可以看到报错了。</p>
<p>​	可以写成如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span> <span class="keyword">as</span> FmtResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = IoResult::<span class="title function_ invoke__">Ok</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = FmtResult::<span class="literal">Ok</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p>​	使用use导入mod后，这个mod对内部作用是可见的。而对如果外部去调用这个函数，对这个mod是没有访问权限的。所以这个时候可以使用pub use，这样这个模块对外部也是可见的了。</p>
<p>​	pub use 意思是重导出。</p>
<h2 id="7-6-特殊的use使用"><a href="#7-6-特殊的use使用" class="headerlink" title="7.6 特殊的use使用"></a>7.6 特殊的use使用</h2><ul>
<li>一次引入同一级下的多个包。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span> <span class="keyword">as</span> FmtResult;</span><br><span class="line">-------<span class="punctuation">-&gt;</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    io::<span class="type">Result</span> <span class="keyword">as</span> IoResult,</span><br><span class="line">    fmt::<span class="type">Result</span> <span class="keyword">as</span> FmtResult,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用self代表它自身</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line">-------<span class="punctuation">-&gt;</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;</span><br><span class="line">    <span class="type">Result</span>,</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过通配符*引入全部的包（不建议经常使用），一般用于 以下情况<ul>
<li>测试：将所有的公共条目引入测试test模块</li>
<li>预导入</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::*;</span><br></pre></td></tr></table></figure>

<h2 id="7-7-引入自己写的mod"><a href="#7-7-引入自己写的mod" class="headerlink" title="7.7 引入自己写的mod"></a>7.7 引入自己写的mod</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_lib;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my_lib::father::son::<span class="title function_ invoke__">cry</span>(); <span class="comment">//使用了my_lib.rs下的father模块中的son模块中的一个关联函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果mod的嵌套太多，可以创建一个新的同名文件夹，然后里面建立子mod的同名.rs文件。</p>
<p>​	可以用mod和use一起作用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.rs</span></span><br><span class="line"><span class="keyword">mod</span> my_lib;</span><br><span class="line"><span class="keyword">use</span> my_lib::father::son <span class="keyword">as</span> son;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    son::<span class="title function_ invoke__">cry</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//my_lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> father;</span><br><span class="line"></span><br><span class="line"><span class="comment">//my_lib\father.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> son &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">eat</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> time: (<span class="type">u16</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">        <span class="keyword">pub</span> food: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cry</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;wawawawa&quot;</span>);</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	树形结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">	main.rs</span><br><span class="line">	my_lib.rs</span><br><span class="line">	my_lib</span><br><span class="line">		father.rs</span><br></pre></td></tr></table></figure>

<h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><p>​	集和是建立在heap上的数据，因此在编译时不需要去确定大小，在运行时会自动变化。</p>
<h2 id="8-1-Vector"><a href="#8-1-Vector" class="headerlink" title="8.1 Vector"></a>8.1 Vector</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><p>​	有两种方式创建Vector</p>
<ul>
<li>通过关联函数，这种情况需要显示的指明类型。</li>
<li>通过已有的值来创建</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;first&quot;</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	rust有上下文推断机制，如果前面没有明确Vec的类型，这时会报错；然后后面添加了元素，又能够自动推断出类型了，报错会消失。</p>
<h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h3><p>​	我们使用第一种方式创建Vector，并且向里面添加元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1i64</span>); <span class="comment">//64位有符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-清理"><a href="#3-清理" class="headerlink" title="3.清理"></a>3.清理</h3><p>​	一般而言，离开作用域后，Vector就会被OS调用drop给清理掉。</p>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4.获取"></a>4.获取</h3><p>​	两种方法：</p>
<ul>
<li>索引：得到的是数据本身</li>
<li>get方法：得到的是Some(T)或者None，其中T是不可变引用。</li>
</ul>
<p>​	get更安全，可以对得到的数据进行类型判断，如果是Some就取出，是None就不取出，提示错误。</p>
<p>​	而索引的话，就会出现panic，程序恐慌。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">30i32</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">i32</span> = <span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;get it: &#123;&#125;&quot;</span>, n);</span><br><span class="line">            *n</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            -<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	因为Vec在heap上，所以有所有权的借用，用get得到的是引用，用索引的到的是本身。但是借用两边并不会报错（i32），<em>说明是存放在栈上的，copy和move都一样</em>。这个地方是错误的，因为i32实现的是copy trait，所以使用等号时会在栈上压栈一个相同的数据。自然不会有所有权的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">30i32</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n2</span> = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并没有报错</span></span><br></pre></td></tr></table></figure>

<p>​	下面修改成String类型的试试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cannot move out of index of `std::vec::Vec&lt;std::string::String&gt;`</span></span><br><span class="line"><span class="comment">//move occurs because value has type `std::string::String`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = v[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	错误信息如上。String没有实现copy trait，而是drop trait，如果操作成功，原来Vec里面对应位置的数据就会失效，所以只能采用借用，也就是用引用来获取。</p>
<p>​	而get默认的就是得到一个引用，用索引的话需要加上引用符号。</p>
<p>​	下面我们先通过索引加引用符号得到一个不可变引用，然后再添加一个元素进去，最后再打印这个不可变引用指向的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;   &quot;</span>)); <span class="comment">//这一行会报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/05/rust-lang/image-20220116142000246.png" alt="image-20220116142000246"></p>
<p>​	原因是什么呢？</p>
<ul>
<li>不可变引用与可变引用不能同时存在。</li>
<li>Vec的机制，因为在堆上分配的空间，所以空间可能不足，需要重新分配空间，然后进行一个数据的迁移，最后释放掉原来那部分的空间。如果发生这种情况，上面获取的不可变引用，它的指向是不会改变的，这样就指向了一片空的内存，是不安全的。所以编译器不允许这样的情况发生。</li>
</ul>
<p>​	然后再次试了一下使用Vector存放i64，放很多数据。然后发生了栈溢出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**memory allocation of 8589934592 bytes failed</span></span><br><span class="line"><span class="comment"> *error: process didn&#x27;t exit successfully: `target\debug\stdvector.exe` (exit code: 0xc0000409,    	      *STATUS_STACK_BUFFER_OVERRUN)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1i64</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2i64</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span> = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">1000000000000000000i64</span>) &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	换成String也会发生溢出。</p>
<p>​	然后查阅了相关资料，确定Vec是存放在栈上的。</p>
<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5.遍历"></a>5.遍历</h3><p>​	通过for循环遍历，通过解引用*更新。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *num = *num + <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-enum-vector"><a href="#8-2-enum-vector" class="headerlink" title="8.2 enum &amp; vector"></a>8.2 enum &amp; vector</h2><p>​	存放时直接存放就行，取出时需要根据类型取出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">InputKind</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        InputKind::<span class="title function_ invoke__">Int</span>(<span class="number">32</span>),</span><br><span class="line">        InputKind::<span class="title function_ invoke__">Float</span>(<span class="number">3.22222</span>),</span><br><span class="line">        InputKind::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hhhh&quot;</span>)),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h2><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1.创建字符串"></a>1.创建字符串</h3><p>​	两种方法：</p>
<ul>
<li>字符串无初值，使用new关联函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串有初值：</p>
<ul>
<li>使用关联函数from</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hhh&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用to_String方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hhh&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">//这里的string是小写</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-更新-1"><a href="#2-更新-1" class="headerlink" title="2.更新"></a>2.更新</h3><p><img src="/2022/02/05/rust-lang/image-20220116152252174.png" alt="image-20220116152252174"></p>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><p>​	不支持索引访问，只能用切片来访问。</p>
<p>​	原因有两个：</p>
<ul>
<li>UTF8编码，一个Unicode值对应的字节数不是固定的。</li>
<li>索引操作应该消耗O(1)的时间复杂度，但是String无法保证。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello_world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = &amp;s[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-内部表示"><a href="#4-内部表示" class="headerlink" title="4.内部表示"></a>4.内部表示</h3><p>​	String时对Vec<u8>的包装，也就是一个可变字节数组。</u8></p>
<p>​	有一个len方法返回的是它的字节数。</p>
<p>​	String有一个大坑，String里面存储的是字节，但是字符都有它的Unicode标量值，一个Unicode值不一定就是一个字节。如下：</p>
<ul>
<li>汉字：1 Unicode – 3 Byte</li>
<li>英语：1 Unicode – 1 Byte</li>
<li>印度：1 Unicode – 2 Byte</li>
</ul>
<p>​	这个时候我们访问，用字符串切割也要看响应的场景了。</p>
<p>​	Rust里有三种看待字符串的方式（自底向上）：</p>
<ul>
<li>字节</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//224 164 168 224 164 174 224 164 184 224 165 141 224 164 164 224 165 135 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>标量值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;हेलो बास्टियन&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//न म स ् त े </span></span><br><span class="line"><span class="comment">//第四个和第六个是类似音调的东西，拆分开没有意义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字形簇：标准库里没有提供。</li>
</ul>
<h3 id="5-字符串切片的坑"><a href="#5-字符串切片的坑" class="headerlink" title="5.字符串切片的坑"></a>5.字符串切片的坑</h3><p>​	使用[min..max]来进行切片，从[min, max - 1]</p>
<p>​	如果切割的不是完整的Unicode编码，不会报错，但会发生恐慌</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;नमस्ते&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">q</span> = &amp;s[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;न&#x27; (bytes 0..3) of `नमस्ते`&#x27;, src\main.rs:3:14</span></span><br></pre></td></tr></table></figure>



<h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h3><p>​	遍历在内部表示中提及。</p>
<h2 id="8-4-HashMap"><a href="#8-4-HashMap" class="headerlink" title="8.4 HashMap"></a>8.4 HashMap</h2><h3 id="1-创建及插入"><a href="#1-创建及插入" class="headerlink" title="1.创建及插入"></a>1.创建及插入</h3><ul>
<li>引入包</li>
<li>new创建</li>
<li>insert插入</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;001&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;qcy&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	HashMap是同构的，所有的key是一种类型，value也是一种类型</p>
<p>​	上面是常规的创建方法，还可以使用tuple来创建。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="built_in">vec!</span>[<span class="string">&quot;qcy&quot;</span>, <span class="string">&quot;qqccuy&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="built_in">vec!</span>[<span class="number">12u8</span>, <span class="number">13u8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = name.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(age.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	先创建两个Vector，然后用一个vec生成一个迭代器，再跟另外一个vec的迭代器进行一一映射。然后再用collect方法打包返回一个hashmap。</p>
<p>​	那个&lt;_, _&gt;是会自动推断的，但是不可以省去。</p>
<p>​	向HashMap中插入数据时，如果数据是实现了copy trait的话，数据会被复制一份。如果是是西安了drop trait的话，数据会被一觉，所有权也会转移，源数据也会失效。</p>
<p>​	但如果插入的是引用，就不会发生所有权的移交了。</p>
<p>​	下面是通过get获取map中的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="built_in">vec!</span>[<span class="string">&quot;qcy&quot;</span>, <span class="string">&quot;qqccuy&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="built_in">vec!</span>[<span class="number">18u8</span>, <span class="number">18u8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>((&amp;age).<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = map.<span class="title function_ invoke__">get</span>(&amp;name[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;error&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印18</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="built_in">vec!</span>[<span class="string">&quot;qcy&quot;</span>, <span class="string">&quot;qqccuy&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="built_in">vec!</span>[<span class="number">18u8</span>, <span class="number">18u8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>((&amp;age).<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = map.<span class="title function_ invoke__">get</span>(&amp;<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;error&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 error</span></span><br></pre></td></tr></table></figure>

<h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>​	使用元组tuple和for-each进行遍历</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="built_in">vec!</span>[<span class="string">&quot;qcy&quot;</span>, <span class="string">&quot;qqccuy&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="built_in">vec!</span>[<span class="number">18u8</span>, <span class="number">18u8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>((&amp;age).<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> map &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h3><p>​	当向map中插入数据时，可能有三种情况：</p>
<ul>
<li><p>数据不存在，直接插入即可。</p>
</li>
<li><p>数据存在</p>
<ul>
<li>忽略原来的数据v，用新的v替换掉它 – insert()方法就是这样的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;qcy&quot;</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(&amp;s, <span class="number">0u8</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(&amp;s, <span class="number">99u8</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;&quot;qcy&quot;: 99&#125;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>保留现在的v，忽略新的v – 使用entry来判断是否存在，用or_insert(v)方法来插入，如果k不存在，执行；存在，不执行。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;qqcy&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;qcwdfg&quot;</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">insert</span>(&amp;s1, <span class="number">1u8</span>);</span><br><span class="line">    m.<span class="title function_ invoke__">entry</span>(&amp;s2).<span class="title function_ invoke__">or_insert</span>(<span class="number">122u8</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;&quot;qqcy&quot;: 1, &quot;qcwdfg&quot;: 122&#125;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>合并旧的v和新的v – 还是使用or_insert(v)，来判断，若k存在会返回一个k的可变引用，可以对k进行修改。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">String</span>, <span class="type">u32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;h h h h h a a x c v b g r e qw s f gf g h h &quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = text.<span class="title function_ invoke__">split_whitespace</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> res &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span> = map.<span class="title function_ invoke__">entry</span>((*i).<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;&quot;h&quot;: 7, &quot;b&quot;: 1, &quot;x&quot;: 1, &quot;r&quot;: 1, &quot;e&quot;: 1, &quot;f&quot;: 1, &quot;gf&quot;: 1, &quot;g&quot;: 2, &quot;s&quot;: 1, &quot;c&quot;: 1, &quot;qw&quot;: 1, &quot;v&quot;: 1, &quot;a&quot;: 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-Hash函数"><a href="#4-Hash函数" class="headerlink" title="4.Hash函数"></a>4.Hash函数</h3><p>​	一般默认情况下：</p>
<ul>
<li>可抵御Dos攻击 – 良好的安全性</li>
<li>并不是最快的 – 性能一般</li>
</ul>
<p>若是觉得性能不好，可以修改trait</p>
<h1 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9.错误处理"></a>9.错误处理</h1><h2 id="1-不可恢复的错误与panic-宏"><a href="#1-不可恢复的错误与panic-宏" class="headerlink" title="1.不可恢复的错误与panic!宏"></a>1.不可恢复的错误与panic!宏</h2><p>​	大多编程语言在错误处理这方面提供了异常机制，没有对可恢复错误与不可恢复错误进行区分，而Rust没有异常机制，但他对错误处理进行了分类：</p>
<ul>
<li>可恢复错误：如文件找不到，可再次尝试<ul>
<li>使用Result&lt;T, E&gt;</li>
</ul>
</li>
<li>不可恢复错误：如Vec越界访问<ul>
<li>使用panic!宏进行处理</li>
</ul>
</li>
</ul>
<p>​	针对不可恢复的错误，我们有两种处理，展开或终止（abort）调用栈。</p>
<ul>
<li>展开调用栈：Rust沿着调用栈往回走，清理遇到每个函数中的数据。</li>
<li>终止调用栈：直接终止程序，不进行清理。但是需要由OS来清理。</li>
</ul>
<p>​	若想二进制文件更小，需要将默认的展开改成终止。</p>
<p>​	具体就是在cargo.toml中设置profile。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;paniccccccc&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>

<p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2u8</span>];</span><br><span class="line">    v[<span class="number">999</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span></span><br><span class="line"><span class="comment">//通过set RUST_BACKTRACE=1 &amp;&amp; cargo run 进行栈回溯</span></span><br></pre></td></tr></table></figure>

<p>​	顺便再次复习一下，v.get(999)并不会报错，得到的返回值是None</p>
<h2 id="2-Result枚举与可恢复的错误"><a href="#2-Result枚举与可恢复的错误" class="headerlink" title="2.Result枚举与可恢复的错误"></a>2.Result枚举与可恢复的错误</h2><p>​	执行文件操作会返回一个Result的枚举变体，操作成功为Ok(T)，失败为Err(E)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;xxx.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	下面是针对不同的错误，通过match做的一些处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::ErrorKind,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;xxx.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;xxx.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(msg) =&gt; msg,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(msg) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, msg),</span><br><span class="line">            &#125;,</span><br><span class="line">            OtherError =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, OtherError),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-unwrap与expect替换match"><a href="#3-unwrap与expect替换match" class="headerlink" title="3.unwrap与expect替换match"></a>3.unwrap与expect替换match</h2><p>​	上面我们用了很多match，代码的可读性还行，但太臃肿了。</p>
<p>​	下面提供一种unwrap()方法。</p>
<p>​	使用unwrap打开文件</p>
<ul>
<li>如果文件不存在，程序恐慌</li>
<li>如果文件存在，返回文件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;xxx.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用unwrap创建文件</p>
<ul>
<li>如果文件不存在，创建文件</li>
<li>如果文件存在，返回文件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;xxx.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	但是有一个缺点，unwrap无法定位错误信息（所有unwrap返回的错误信息都是一样的），所以下面介绍expect</p>
<p>​	expect与unwrap一样，单数可以控制输出的错误信息，精确的定位到处错在哪一行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;xxx.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-通过函数将错误返回"><a href="#4-通过函数将错误返回" class="headerlink" title="4.通过函数将错误返回"></a>4.通过函数将错误返回</h2><p>​	将函数的返回值设置为一个Result枚举类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">read_text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> s &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(res) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text</span>(path: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(path);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123; <span class="comment">//file必须是可变的，因为会执行读这个操作。</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(f) =&gt; f,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e) <span class="comment">//直接作为函数返回值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-语法糖：”-”"><a href="#5-语法糖：”-”" class="headerlink" title="5.语法糖：”?”"></a>5.语法糖：”?”</h2><p>​	?：执行一个操作</p>
<ul>
<li>如果是Ok的话，就把Ok里的值作为结果绑定到变量。</li>
<li>如果是Err的话，就直接返回错误（注意main函数没有返回值，所以如果要使用”?”的话，需要加东西）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">read_text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> s &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(res) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text</span>(path: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="comment">// let mut f = match f &#123; //file必须是可变的，因为会执行读这个操作。</span></span><br><span class="line">    <span class="comment">//     Ok(f) =&gt; f,</span></span><br><span class="line">    <span class="comment">//     Err(e) =&gt; return Err(e) //直接作为函数返回值</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="comment">// match f.read_to_string(&amp;mut s) &#123;</span></span><br><span class="line">    <span class="comment">//     Ok(_) =&gt; Ok(s),</span></span><br><span class="line">    <span class="comment">//     Err(e) =&gt; Err(e),</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	删掉注释后效果如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">read_text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> s &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(res) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text</span>(path: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	非常精简。</p>
<p>​	然后再进行链式调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">read_text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> s &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(res) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text</span>(path: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(path)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-main函数中如何使用”-”运算符"><a href="#6-main函数中如何使用”-”运算符" class="headerlink" title="6.main函数中如何使用”?”运算符"></a>6.main函数中如何使用”?”运算符</h2><p>​	main的返回类型是()，也可以修改为Result，T对应的是()，E对应的是任意可能的错误类型（其实是一个trait对象7.）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;xxx.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-何时使用panic"><a href="#7-何时使用panic" class="headerlink" title="7.何时使用panic!"></a>7.何时使用panic!</h2><p>​	总体原则如下：</p>
<ul>
<li>尽量使用Result！将错误返回到代码的调用者，让他们决定如何去处理，如果我们觉得这个错误除了panic!，没有其它的解决办法，就直接使用panic!吧</li>
</ul>
<h1 id="10-泛型，trait，生命周期"><a href="#10-泛型，trait，生命周期" class="headerlink" title="10.泛型，trait，生命周期"></a>10.泛型，trait，生命周期</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h2><p>​	Rust对类型的命名采用的是驼峰命名而非蛇形命名。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DogAnimal</span> &#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	泛型的声明</p>
<ul>
<li>结构</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Good</span>&lt;X, Y&gt; &#123;</span><br><span class="line">    name: X,</span><br><span class="line">    msg: Y,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hhh</span>&lt;X&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举（Option<T> 和 Result&lt;T, E&gt;）</T></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法</li>
</ul>
<p>​	注：针对具体的方法，impl后不需要接收泛型。如果是泛型方法，那么就需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Good</span>&lt;X, Y&gt; &#123;</span><br><span class="line">    name: X,</span><br><span class="line">    msg: Y,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X, Y&gt; Good&lt;X, Y&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: X, msg: Y) <span class="punctuation">-&gt;</span> Good&lt;X, Y&gt;&#123;</span><br><span class="line">        Good&#123;</span><br><span class="line">            name,</span><br><span class="line">            msg,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Good</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">speak</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	使用泛型并不会影响性能。因为Rust使用了<em><strong>单态化</strong></em>，也就是编译的时候会将具体的类型带入到泛型参数里去，从而在运行时不需要额外的开销。</p>
<h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2.trait"></a>2.trait</h2><ul>
<li>类似于接口，告诉编译器哪些类型可以具有相同的功能。</li>
<li>还有一个trait bound的特性：要求传进来的泛型参数必须实现了对应的trait</li>
</ul>
<p>​	trait的产生和接口是类似的，有些不同的类型会实现相同的方法。所以我们就把这些方法提取出来，实现一个trait。</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​	如下，只有方法签名，无具体实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Behavior</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eat</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_money</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>my_lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_struct &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::my_trait::Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">pub</span> age: <span class="type">i8</span>,</span><br><span class="line">        <span class="keyword">pub</span> money: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">pub</span> age: <span class="type">i8</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Text</span> <span class="keyword">for</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;name is &#123;&#125;, age is &#123;&#125;, get money &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age, <span class="keyword">self</span>.money)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Text</span> <span class="keyword">for</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;i am &#123;&#125;, age is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> fanxingggggg::my_struct::&#123;</span><br><span class="line">    Man,</span><br><span class="line">    Boy,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> fanxingggggg::my_trait::Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Man &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;father&quot;</span>),</span><br><span class="line">        age: <span class="number">40</span>,</span><br><span class="line">        money: <span class="number">100</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Boy &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boy&quot;</span>),</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, m.<span class="title function_ invoke__">write</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b.<span class="title function_ invoke__">write</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	trait也可以使用默认实现，也就是在trait的定义时就实现trait。如果结构对trait的默认实现进行了重写的话，就不能再调用默认实现了。</p>
<h3 id="3-将trait作为参数"><a href="#3-将trait作为参数" class="headerlink" title="3.将trait作为参数"></a>3.将trait作为参数</h3><ul>
<li>参数类型为iml trait</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_struct &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::my_trait::Text;</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun1</span>(object: <span class="keyword">impl</span> <span class="title class_">Text</span> + Display) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用trait bound</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_struct &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line">    <span class="keyword">use</span> crate::my_trait::Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun</span>&lt;T: Text + Display&gt;(o: T) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在返回类型后使用where</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_struct &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line">    <span class="keyword">use</span> crate::my_trait::Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun</span>&lt;T&gt;(o: T) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">where</span> T: Text + <span class="built_in">Clone</span> + Display,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> my_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><p>​	定义：让引用保持有效的作用域。</p>
<p>​	Rust有一个东西叫做借用检查器。会在编译的时候比较两个引用的生命周期的长短。</p>
<h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h3><p>​	当你写了一个函数时，向里面传了多个引用，然后对其进行一系列操作，最后返回一个引用时。需要用到生命周期。</p>
<p>​	因为编译器需要确保传进来的生命周期，与传出去的生命周期一样，或者说大于。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sss&quot;</span>); <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">get_longer</span>(&amp;s1, &amp;s2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, &amp;res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_longer</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	目的检查非法调用。</p>
<p>​	实际返回结果的生命周期是两个参数中生命周期较小的那一个。</p>
<p>​	我们看下面这个错误调用。</p>
<p><img src="/2022/02/05/rust-lang/image-20220119202214447.png" alt="image-20220119202214447"></p>
<p><img src="/2022/02/05/rust-lang/image-20220119202225682.png" alt="image-20220119202225682"></p>
<p>​	通过函数，res的生命这些周期被缩短到和s2一样了。这样在外部继续调用的话，就会发生错误。</p>
<p>​	再试试Java里的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.reptile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        String res;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;sss&quot;</span>;</span><br><span class="line">            res = s2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	res的值和s2是一样的，这意味着s2并没有被GC回收掉。</p>
<h3 id="2-函数的生命周期"><a href="#2-函数的生命周期" class="headerlink" title="2.函数的生命周期"></a>2.函数的生命周期</h3><p>​	函数的返回值的生命周期跟输入的参数的生命周期有关。</p>
<p>​	如果要返回一个引用，需要确保这个引用不会被回收（即不是本地变量）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">//报错，returns a reference to data owned by the current function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	返回的引用指向的堆已经被drop掉了，所以不行。这个引用叫悬垂指针。在Rust里，只要提供了足够的信息（生命周期），就不会发生这种情况。</p>
<p>​	如果想要使用在函数里的变量，建议返回一个String，移交所有权，而不是返回一个引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(arg: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arg.<span class="title function_ invoke__">len</span>() != <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = &amp;arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = &amp;arg[<span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(</span><br><span class="line">        Config &#123;</span><br><span class="line">            query: p1,</span><br><span class="line">            file_path: p2,</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-struct的生命周期"><a href="#3-struct的生命周期" class="headerlink" title="3.struct的生命周期"></a>3.struct的生命周期</h3><p>​	与函数类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Man</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里生命周期的意思是：字段存活的时间必须比结构久，不然的话字段先被回收了，结构还在，就会发生内存泄漏。</p>
<p>​	即绑定给name的数据的生命周期的存活时间必须要覆盖这个结构的生命周期。</p>
<h3 id="4-生命周期省略的规则"><a href="#4-生命周期省略的规则" class="headerlink" title="4.生命周期省略的规则"></a>4.生命周期省略的规则</h3><ul>
<li>每个引用类型的参数都有自己的生命周期</li>
<li>如果只有一个输入生命周期参数，那么这个生命周期参数将被赋给输出生命周期参数</li>
<li>如果有多个输入生命周期参数，但是其中之一是<code>&amp;self or &amp;mut self</code>，那么self的生命周期将被赋给输出生命周期参数。</li>
</ul>
<h3 id="5-静态生命周期"><a href="#5-静态生命周期" class="headerlink" title="5.静态生命周期"></a>5.静态生命周期</h3><p>​	静态生命周期用&#96;static，表示，意思是比那辆的存活时间和程序的存活时间是一致的。也就是说编译器在编译的时候就把这一部分作为二进制值写进去了。</p>
<p>​	只有实现了copy trait的变量才可以声明static</p>
<h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11.测试"></a>11.测试</h1><p>​	测试三个步骤，3A</p>
<ul>
<li><em><strong>准备数据</strong></em> </li>
<li><em><strong>运行测试代码</strong></em></li>
<li><em><strong>断言结果</strong></em></li>
</ul>
<h2 id="1-编写测试"><a href="#1-编写测试" class="headerlink" title="1.编写测试"></a>1.编写测试</h2><p>​	在函数的上方加上 属性（aattribute）<code>#[test]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2.运行测试"></a>2.运行测试</h2><p>​	使用cargo test命令</p>
<h2 id="3-断言的作用"><a href="#3-断言的作用" class="headerlink" title="3.断言的作用"></a>3.断言的作用</h2><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1.assert!"></a>1.assert!</h3><p>​	断定此处为true！</p>
<p>​	可以接收一个bool类型，true通过，false则panic</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">fn ppp() &#123;</span><br><span class="line">    let f = false;</span><br><span class="line">    assert!(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-assert-eq"><a href="#2-assert-eq" class="headerlink" title="2.assert_eq!"></a>2.assert_eq!</h3><p>​	断定两个同类型的变量相等！</p>
<p>​	比如下面的assert_eq!，就是表明括号里面传入的参数肯定相等，不然就会报错。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	还可以接收字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-assert-ne"><a href="#3-assert-ne" class="headerlink" title="3.assert_ne!"></a>3.assert_ne!</h3><p>​	与assert eq相反，ne的意思是not eq</p>
<h3 id="4-给断言添加自定义消息"><a href="#4-给断言添加自定义消息" class="headerlink" title="4.给断言添加自定义消息"></a>4.给断言添加自定义消息</h3><p>​		其实assert宏还有另外一个参数，可以传递字符串，而事实上这个字符串最终会传递给format宏。所以这个字符串里面可以添加占位符{}，并且后面可以带参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, i2, <span class="string">&quot;&#123;&#125; is not eq &#123;&#125;&quot;</span>, i1, i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-属性should-panic"><a href="#4-属性should-panic" class="headerlink" title="4.属性should_panic"></a>4.属性should_panic</h2><p>​	在测试下面，函数上面再添加一条属性（attribute），叫<code>#[should_panic]</code></p>
<p>​	表示下面的测试函数应该恐慌，不恐慌测试就不会通过。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ggg</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;hello should_panic&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以通过在should_panic(expected &#x3D; “”)添加参数，让测试更加精确一点。如添加了字符串参数，然后如果恐慌信息里包含了这个expected参数，那么就测试通过；反之，如果不包含，那么测试失败。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;hello&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ggg</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;hello should_panic&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用Result枚举来进行测试"><a href="#5-使用Result枚举来进行测试" class="headerlink" title="5.使用Result枚举来进行测试"></a>5.使用Result枚举来进行测试</h2><p>​	无需panic。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ggg</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;not eq&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="12-命令行项目"><a href="#12-命令行项目" class="headerlink" title="12.命令行项目"></a>12.命令行项目</h1><p>​	实现这样的功能：通过命令行，向程序中输入参数，一个是字符串，一个是文件绝对路径。然后找到这个绝对路径中跟字符串内容匹配的部分，并且打印出来。</p>
<h2 id="1-接收命令行参数"><a href="#1-接收命令行参数" class="headerlink" title="1.接收命令行参数"></a>1.接收命令行参数</h2><p>​	使用std::env下的args接收参数，并调用collect方法，返回一个Vec</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">// let p1 = &amp;v[0];</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-读取文件内容"><a href="#2-读取文件内容" class="headerlink" title="2.读取文件内容"></a>2.读取文件内容</h2><p>​	使用std::fs下的read _to_string 来读取，会返回一个result，所以我们调用except来处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">target: python</span></span><br><span class="line"><span class="comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = &amp;v[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(path).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-代码重构"><a href="#3-代码重构" class="headerlink" title="3.代码重构"></a>3.代码重构</h2><p>​	遵循一个函数一个功能的原则，main函数现在太臃肿了。</p>
<p>​	选择将main.rs拆分成main.rs和lib.rs，将业务逻辑的实现放在libl里。</p>
<p>​	具体如下：</p>
<ul>
<li>在main.rs里编写全部功能，可以忽略重构，忽略错误处理，只考虑理想情况。</li>
<li>将实现功能的业务逻辑抽取出来，独立成单个的函数。</li>
<li>在函数中进行错误处理，或者返回一个Result让main去处理。</li>
<li>最后将抽取出来的函数移动到lib里去</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;env, fs, process&#125;;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> cmdddddd::&#123;Config, run&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">target: python</span></span><br><span class="line"><span class="comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;v).<span class="title function_ invoke__">unwrap_or_else</span>(|error_msg| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;problem happened: &#123;&#125;&quot;</span>, error_msg);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">run</span>(&amp;config) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(()) =&gt; (),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;got some problem； &#123;:#?&#125;&quot;</span>, err);</span><br><span class="line">            process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: &amp;Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = config.<span class="title function_ invoke__">query</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = config.<span class="title function_ invoke__">file_path</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(path)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    query: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    file_path: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Config&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(arg: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> arg.<span class="title function_ invoke__">len</span>() != <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p1</span> = &amp;arg[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p2</span> = &amp;arg[<span class="number">2</span>];</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(</span><br><span class="line">            Config &#123;</span><br><span class="line">                query: p1,</span><br><span class="line">                file_path: p2,</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">query</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.query</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">file_path</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.file_path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-使用TDD在lib里进行查错"><a href="#4-使用TDD在lib里进行查错" class="headerlink" title="4.使用TDD在lib里进行查错"></a>4.使用TDD在lib里进行查错</h2><p>​	TDD：test driver development，测试驱动开发</p>
<p><img src="/2022/02/05/rust-lang/image-20220120223838199.png" alt="image-20220120223838199"></p>
<p>​	测试部分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_test</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">content</span> = <span class="string">&quot;\n</span></span><br><span class="line"><span class="string">hi,\n</span></span><br><span class="line"><span class="string">rust-langn</span></span><br><span class="line"><span class="string">demo demo dododododod\n</span></span><br><span class="line"><span class="string">hello \n</span></span><br><span class="line"><span class="string">hhh\n</span></span><br><span class="line"><span class="string">s\n</span></span><br><span class="line"><span class="string">hhh\n</span></span><br><span class="line"><span class="string">hhh hanpi\n</span></span><br><span class="line"><span class="string">en\n&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;demo demo dododododod&quot;</span>], <span class="title function_ invoke__">search</span>(<span class="string">&quot;demo&quot;</span>, content));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	被测试的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lines</span> = content.<span class="title function_ invoke__">lines</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> lines &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            res.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		以后使用TDD来进行测试。测试样例与功能实现分离开。</p>
<h2 id="5-使用环境变量进行选择"><a href="#5-使用环境变量进行选择" class="headerlink" title="5.使用环境变量进行选择"></a>5.使用环境变量进行选择</h2><p>​	方法如下：</p>
<p>​	程序中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">flag</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	命令行中：IGNORE_CASE &#x3D; 1 cargo run</p>
<p>​	这样就可以在程序中读到环境变量了。</p>
<h2 id="6-进行错误信息定向输出"><a href="#6-进行错误信息定向输出" class="headerlink" title="6.进行错误信息定向输出"></a>6.进行错误信息定向输出</h2><p>​	我们可以使用cargo run &gt; output.txt 运行使得通过println!输出的内容定向到output.txt里面。</p>
<p>​	但是这样错误信息也输出到output里了。</p>
<p>​	可以使用eprintln!，将错误信息定向到控制台输出。</p>
<h1 id="13-迭代器-闭包"><a href="#13-迭代器-闭包" class="headerlink" title="13.迭代器 闭包"></a>13.迭代器 闭包</h1><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1 闭包的定义"></a>1 闭包的定义</h3><p>​	定义：可以捕获其所在环境的匿名函数。</p>
<p>​	闭包是一个匿名函数，他是将一个函数的定义存放在一个变量中去，而不是函数的执行结果。这个闭包只有在遇到向里面传输参数的时候，才会去执行函数，得到返回结果。</p>
<p>​	闭包并不需要显式声明它的参数和返回值类型。因为闭包是在当前作用域内工作的，范围狭小，不是作为接口去调用的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ggg</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bi_bao</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the num is &#123;&#125;&quot;</span>, num);</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">bi_bao</span>(<span class="number">3</span>)); <span class="comment">//调用bi_bao(3)的时候才是会真正执行闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	将闭包绑定给变量后，变量的类型就是：<code>variable bi_bao: fn(&lt;unknown&gt;) -&gt; &lt;unknown&gt;</code></p>
<h3 id="2用结构来存储闭包"><a href="#2用结构来存储闭包" class="headerlink" title="2用结构来存储闭包"></a>2用结构来存储闭包</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cashe</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;</span><br><span class="line">        Cashe &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, num: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(n) =&gt; n,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = (<span class="keyword">self</span>.calculation)(num);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(res);</span><br><span class="line">                res</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Cashe::<span class="title function_ invoke__">new</span>(|num| num + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">value</span>(<span class="number">32</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">value</span>(<span class="number">92</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面结构中的calculation，是一个泛型参数T，并且加上了限制，要求这个泛型参数是实现了Fn trait的一个闭包。</p>
<p>​	但是只能存储一次。</p>
<p>​	可以用hashmap来进行改进。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cashe</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: HashMap&lt;<span class="type">u32</span>, <span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;</span><br><span class="line">        Cashe &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, num: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">map</span> = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.value;</span><br><span class="line">        <span class="keyword">match</span> map.<span class="title function_ invoke__">get</span>(&amp;num) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(res) =&gt; *res,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = (<span class="keyword">self</span>.calculation)(num);</span><br><span class="line">                map.<span class="title function_ invoke__">insert</span>(num, res);</span><br><span class="line">                res</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Cashe::<span class="title function_ invoke__">new</span>(|num| num + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">value</span>(<span class="number">32</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">value</span>(<span class="number">92</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用闭包捕获外部变量"><a href="#3-使用闭包捕获外部变量" class="headerlink" title="3.使用闭包捕获外部变量"></a>3.使用闭包捕获外部变量</h3><p>​	闭包可以捕获和他定义于同一个作用域的变量。这是闭包独有的功能，而函数是没有的。</p>
<p>​	但是会产生额外的内存开销。</p>
<h3 id="4-闭包的trait"><a href="#4-闭包的trait" class="headerlink" title="4.闭包的trait"></a>4.闭包的trait</h3><ul>
<li>Fn            不可变借用</li>
<li>FnMut    可变借用</li>
<li>FnOnce   取得所有权</li>
</ul>
<p><img src="/2022/02/05/rust-lang/image-20220121151726938.png" alt="image-20220121151726938"></p>
<p>​	可以使用move关键字将闭包外的所有权强行移动到闭包内。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&quot;&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bb</span> = <span class="keyword">move</span> ||v; <span class="comment">//移动所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, v); <span class="comment">//这一行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2.迭代器"></a>2.迭代器</h2><h3 id="1-iterator-trait"><a href="#1-iterator-trait" class="headerlink" title="1.iterator trait"></a>1.iterator trait</h3><p>​	实现next方法即可。</p>
<h3 id="2-几个迭代api"><a href="#2-几个迭代api" class="headerlink" title="2.几个迭代api"></a>2.几个迭代api</h3><ul>
<li>iter：在不可变引用上创建迭代器</li>
<li>into_iter：创建的迭代器会获取所有权 – 用一个数据引出迭代器，并且夺取了元数据的所有权。</li>
<li>iter_mut：迭代可变的引用 – 可以通过解引用修改其中的值。</li>
</ul>
<h3 id="3-消耗-产生-迭代器"><a href="#3-消耗-产生-迭代器" class="headerlink" title="3.消耗&#x2F;产生 迭代器"></a>3.消耗&#x2F;产生 迭代器</h3><h4 id="1-消耗（消耗性适配器）"><a href="#1-消耗（消耗性适配器）" class="headerlink" title="1.消耗（消耗性适配器）"></a>1.消耗（消耗性适配器）</h4><p>​	消耗迭代器：当调用迭代器的next方法时，会消耗迭代器，迭代器中的元素会被一个一个消除掉，这就是叫消耗的原因。rust里有些方法（针对于实现了iterator trait的类型），会自主调用next，从而消耗迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iterator</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>: <span class="type">i32</span> = iterator.<span class="title function_ invoke__">sum</span>(); <span class="comment">//sum消耗了迭代器</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/05/rust-lang/image-20220122155108279.png" alt="image-20220122155108279"></p>
<p>​	要调用sum这个方法，self必须实现Sizd这个trait，并且泛型参数必须实现了Sum这个trait。 </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Sized trait: 要求这个类型必须有固定的长度，如i32，u32</span></span><br><span class="line"><span class="comment">2.Sum trait：可以进行求和</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-产生（迭代器适配器）"><a href="#2-产生（迭代器适配器）" class="headerlink" title="2.产生（迭代器适配器）"></a>2.产生（迭代器适配器）</h4><p>​	将一个迭代器转换成另一个迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter1</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span> = iter1.<span class="title function_ invoke__">map</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = map.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter2</span> = v2.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	map()方法：一个泛型方法，接收两个泛型参数，目的是将传进来的类型T更改成传出去的类型F。接收两个参数，第一个是self，要求实现了Sized这个trait。第二个参数是T，要求实现FnMut这个trait，也就是一个闭包，并且是可变引用，因为要对参数进行修改。</p>
<p>​	调用map方法后，迭代器的所有权被Move。</p>
<h4 id="3-迭代器-闭包-捕获环境"><a href="#3-迭代器-闭包-捕获环境" class="headerlink" title="3.迭代器+闭包 捕获环境"></a>3.迭代器+闭包 捕获环境</h4><p>​	使用filter()这个方法，一个迭代器适配器。接收一个闭包，这个闭包必须返回bool类型。若是返回true，则元素被加到迭代器里，最终作为这个方法的返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">100</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|num| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        **num &gt; <span class="number">90</span></span><br><span class="line">    &#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, i1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	传进闭包后，要用collect进行收集,返回一个集合，不然闭包是不会执行的</p>
<h4 id="4-构建自定义的迭代器"><a href="#4-构建自定义的迭代器" class="headerlink" title="4.构建自定义的迭代器"></a>4.构建自定义的迭代器</h4><p>​	实现Iterator trait即可。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">e1</span> = Elem::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e1.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Elem</span> &#123;</span><br><span class="line">    val: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Elem</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Elem &#123;</span><br><span class="line">        Elem &#123;</span><br><span class="line">            val: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Elem</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	迭代器比for循环遍历要快一点。</p>
<p>​	用filter方法。</p>
<h1 id="14-发布"><a href="#14-发布" class="headerlink" title="14.发布"></a>14.发布</h1><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15.智能指针"></a>15.智能指针</h1><h2 id="1-Box-T"><a href="#1-Box-T" class="headerlink" title="1.Box&lt; T &gt;"></a>1.Box&lt; T &gt;</h2><p>​	Rust中所有的类型在编译时都会知道大小。</p>
<p>​	考虑C语言中的链表的实现，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	有两个类型，一个是int，一个是指针。这实际就是一个递归，只不过递归的是指针，并不是结构，如果是结构的话，就永远无法知道声明一个struct的时候应该分配多少大小了。所以用的是指针。指针存放在栈上，就是一个地址而已。</p>
<p>​	rust也是类似的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Node &#123;</span><br><span class="line">        value: <span class="number">1</span>,</span><br><span class="line">        next: <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">2</span>,</span><br><span class="line">            next: <span class="literal">None</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	Box这个类型就是一个智能指针，实现了两个trait，deref的目的是确保Box可以被当成一个引用实现；drop则是确保Box在离开作用域时，其指针（栈内存）和指向的数据（堆内存）都会被释放。</p>
<p><img src="/2022/02/05/rust-lang/image-20220123150617915.png" alt="image-20220123150617915"></p>
<h2 id="2-deref-trait"><a href="#2-deref-trait" class="headerlink" title="2.deref trait"></a>2.deref trait</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><p>​	实现这个trait后，可以确保类型被当成引用来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(n);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, n);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, *m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现Deref-trait"><a href="#2-实现Deref-trait" class="headerlink" title="2.实现Deref trait"></a>2.实现Deref trait</h3><p>​	给结构实现deref trait即可。</p>
<p>​	具体的话，就是指定一下类型，然后实现deref方法即可。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(m, *n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-deref-coercion"><a href="#3-deref-coercion" class="headerlink" title="3.deref coercion"></a>3.deref coercion</h3><p>​	假设实现了deref trait，然后传入的是引用，那么编译器就会自动调用deref方法，将&amp;Box<T> -&gt; &amp;T。</T></p>
<p>​	如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	首先将&amp;MyBox<String> -&gt; &amp;String，由于String类型实现了deref trait，所以 &amp;String -&gt; &amp;str，所以参数就匹配了。</String></p>
<p>​	并且，所有的这些操作，都是在编译期完成的，不会产生额外的运行时性能开销。</p>
<h2 id="3-drop-trait"><a href="#3-drop-trait" class="headerlink" title="3.drop trait"></a>3.drop trait</h2><p>​	变量在离开作用域时，会自动调用drop方法，来释放相关的资源。</p>
<p>​	不可以提前调用drop trait的drop方法，但是可以提前释放资源，使用另外一个drop方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Rc-T"><a href="#4-Rc-T" class="headerlink" title="4.Rc&lt; T &gt;"></a>4.Rc&lt; T &gt;</h2><p>​	引用计数智能指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;s1)); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;s1)); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	为什么要有Rc<T>？</T></p>
<p>​	把Box<T>传进去之后，Box会夺取T的所有权，所以如果还想复用T的话，或者是在别的地方传入Box<T>，那么就会报错，因为T已经被移动了。</T></T></p>
<p>​	使用Rc就不一样了，如果函数接收的是Rc<T>，那么传入Rc::clone(&amp;T)就可以了，这个clone函数并不会深拷贝，只是增加引用计数，返回一个Rc<T>。</T></T></p>
<p>​	使用了Rc<T>，就相当于单个值有了多个所有者。</T></p>
<p>​	Rc使用的是不可变引用，如果是可变引用就会违反引用规则。并且，Rc只能在单线程下使用。</p>
<h2 id="5-RfCell-T"><a href="#5-RfCell-T" class="headerlink" title="5.RfCell&lt; T &gt;"></a>5.RfCell&lt; T &gt;</h2><p><img src="/2022/02/05/rust-lang/image-20220123172820248.png" alt="image-20220123172820248"></p>
<h1 id="16-并发"><a href="#16-并发" class="headerlink" title="16.并发"></a>16.并发</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><p>​	创建线程的两种方式：</p>
<ul>
<li>通过OS的api来创建 – 运行时小 – 1  : 1</li>
<li>语言自己实现的线程 – 运行时大 – M : N</li>
</ul>
<p>​	Rust提供的是1:1线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这样写，一旦主线程结束了，我们创建的线程也就停止了。可以通过join方法来阻塞主线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;thread: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;main: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">//只有j的线程结束后，才会恢复主线程的执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以使用move将主线程里的值的所有权强制移动到分线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    j.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-通过channel实现线程通信"><a href="#2-通过channel实现线程通信" class="headerlink" title="2.通过channel实现线程通信"></a>2.通过channel实现线程通信</h2><p>​	通过mpsc的一个关联函数可以构造一个元组（send, receive）</p>
<p>​	mpsc的意思：多个生产者，一个消费者。multiple producer， single consumer</p>
<p>​	可以通过克隆来实现多个发送者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (send, receive) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">send1</span> = send.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ss</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;from&quot;</span>];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> ss &#123;</span><br><span class="line">            send.<span class="title function_ invoke__">send</span>(s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j1</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ss</span> = [<span class="string">&quot;111hello&quot;</span>, <span class="string">&quot;111world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;111from&quot;</span>];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> ss &#123;</span><br><span class="line">            send1.<span class="title function_ invoke__">send</span>(s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">r</span> <span class="keyword">in</span> receive &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    j.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    j1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Mutex-T-共享内存"><a href="#3-Mutex-T-共享内存" class="headerlink" title="3.Mutex&lt; T &gt;共享内存"></a>3.Mutex&lt; T &gt;共享内存</h2><p>​		Mutex就是一个互斥锁，使用数据前需要先获取锁，然后使用完后需要释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;mpsc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = n.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="comment">//n从5到7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	mutex可能会产生死锁</p>
<h2 id="4-Arc-T-原子引用计数"><a href="#4-Arc-T-原子引用计数" class="headerlink" title="4.Arc&lt; T &gt;原子引用计数"></a>4.Arc&lt; T &gt;原子引用计数</h2><p>​	在外面克隆引用，然后把克隆的引用传进去。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, mpsc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;n);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = l1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num += <span class="number">999</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="comment">//1004</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ceshi:</p>
<p><img src="/2022/02/05/rust-lang/image-20220214142148258.png" alt="image-20220214142148258"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/05/rust-lang/" data-id="cm9l0al4k005rjmnnewhu3n2x" data-title="rust-lang" class="article-share-link">Share</a>
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/covers/IMG_2577.JPG" data-sizes="auto" alt="嵌入式操作系统-MicroCOS III" class="lazyload">
          
        
        <a href="/2022/05/26/MicroCOS-III/"></a>
        <div class="article-nav-caption">Newer</div>
        <h3 class="article-nav-title">
          
            嵌入式操作系统-MicroCOS III
          
        </h3>
      </div>
    
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">0.基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Clion%E5%BC%80%E5%8F%91Rust"><span class="toc-number">1.1.</span> <span class="toc-text">1.使用Clion开发Rust</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8cargo%E5%88%9B%E5%BB%BA%E5%BA%93%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2.使用cargo创建库项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%89%93%E5%8D%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text">3.打印地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-rust%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">1 rust简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%91%BD%E4%BB%A4%E8%A1%8C-vscode%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 命令行+vscode构建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BC%96%E5%86%99hello-world%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 编写hello world程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-cargo%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 cargo创建工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">2 rust基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%8E%B7%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 获取控制台输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%8C%85rand%EF%BC%88%E4%BF%AE%E6%94%B9toml%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 添加外部依赖包rand（修改toml文件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 使用枚举进行比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 处理异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E5%8F%8A%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">3 变量及控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">3.1变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1 不可变变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2 可变变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%B8%B8%E9%87%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.1.3 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-shadow%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 shadow机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 标量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%95%B4%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.3.1 整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%B5%AE%E7%82%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3.2 浮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3.3 bool类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.3.4 字符类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%85%83%E7%BB%84Tuple"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 元组Tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-Vector"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.5 Vector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-if-else"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-loop"><span class="toc-number">4.7.1.</span> <span class="toc-text">3.7.1 loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-while"><span class="toc-number">4.7.2.</span> <span class="toc-text">3.7.2 while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-for-each"><span class="toc-number">4.7.3.</span> <span class="toc-text">3.7.3 for - each</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">5.</span> <span class="toc-text">4 所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 栈内存与堆内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 所有权规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%88%9D%E8%AF%86String"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 初识String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 函数与所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%BC%95%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%88%87%E7%89%87"><span class="toc-number">5.6.</span> <span class="toc-text">4.5 切片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">5 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 结构定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 结构实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-struct%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 struct方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">7.</span> <span class="toc-text">6 枚举与模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 定义枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Option%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 Option枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-match"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-if-let%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 if-let语法糖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-package-crate-module"><span class="toc-number">8.</span> <span class="toc-text">7  package crate module</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9D%83%E9%99%90"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%BB%93%E6%9E%84%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 结构的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 枚举的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-use%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 use的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use"><span class="toc-number">8.5.1.</span> <span class="toc-text">use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pub-use"><span class="toc-number">8.5.2.</span> <span class="toc-text">pub use</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%89%B9%E6%AE%8A%E7%9A%84use%E4%BD%BF%E7%94%A8"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 特殊的use使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E5%BC%95%E5%85%A5%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84mod"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 引入自己写的mod</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9B%86%E5%90%88"><span class="toc-number">9.</span> <span class="toc-text">8 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Vector"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">2.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B8%85%E7%90%86"><span class="toc-number">9.1.3.</span> <span class="toc-text">3.清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96"><span class="toc-number">9.1.4.</span> <span class="toc-text">4.获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86"><span class="toc-number">9.1.5.</span> <span class="toc-text">5.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-enum-vector"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 enum &amp; vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.3.1.</span> <span class="toc-text">1.创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0-1"><span class="toc-number">9.3.2.</span> <span class="toc-text">2.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BF%E9%97%AE"><span class="toc-number">9.3.3.</span> <span class="toc-text">3.访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">9.3.4.</span> <span class="toc-text">4.内部表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%E7%9A%84%E5%9D%91"><span class="toc-number">9.3.5.</span> <span class="toc-text">5.字符串切片的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%8D%E5%8E%86"><span class="toc-number">9.3.6.</span> <span class="toc-text">6.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-HashMap"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%8F%8A%E6%8F%92%E5%85%A5"><span class="toc-number">9.4.1.</span> <span class="toc-text">1.创建及插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%81%8D%E5%8E%86"><span class="toc-number">9.4.2.</span> <span class="toc-text">2.遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0"><span class="toc-number">9.4.3.</span> <span class="toc-text">3.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Hash%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.4.</span> <span class="toc-text">4.Hash函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">9.错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8Epanic-%E5%AE%8F"><span class="toc-number">10.1.</span> <span class="toc-text">1.不可恢复的错误与panic!宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Result%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">10.2.</span> <span class="toc-text">2.Result枚举与可恢复的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-unwrap%E4%B8%8Eexpect%E6%9B%BF%E6%8D%A2match"><span class="toc-number">10.3.</span> <span class="toc-text">3.unwrap与expect替换match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%B0%86%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E"><span class="toc-number">10.4.</span> <span class="toc-text">4.通过函数将错误返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9A%E2%80%9D-%E2%80%9D"><span class="toc-number">10.5.</span> <span class="toc-text">5.语法糖：”?”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E2%80%9D-%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">6.main函数中如何使用”?”运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8panic"><span class="toc-number">10.7.</span> <span class="toc-text">7.何时使用panic!</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%B3%9B%E5%9E%8B%EF%BC%8Ctrait%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">10.泛型，trait，生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">1.泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-trait"><span class="toc-number">11.2.</span> <span class="toc-text">2.trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%86trait%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.3.</span> <span class="toc-text">3.将trait作为参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3.生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">11.3.1.</span> <span class="toc-text">1.简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.2.</span> <span class="toc-text">2.函数的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-struct%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.struct的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">11.3.4.</span> <span class="toc-text">4.生命周期省略的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.5.</span> <span class="toc-text">5.静态生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%B5%8B%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">11.测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">1.编写测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">12.2.</span> <span class="toc-text">2.运行测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%AD%E8%A8%80%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">3.断言的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-assert"><span class="toc-number">12.3.1.</span> <span class="toc-text">1.assert!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-assert-eq"><span class="toc-number">12.3.2.</span> <span class="toc-text">2.assert_eq!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-assert-ne"><span class="toc-number">12.3.3.</span> <span class="toc-text">3.assert_ne!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%99%E6%96%AD%E8%A8%80%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF"><span class="toc-number">12.3.4.</span> <span class="toc-text">4.给断言添加自定义消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7should-panic"><span class="toc-number">12.4.</span> <span class="toc-text">4.属性should_panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8Result%E6%9E%9A%E4%B8%BE%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">12.5.</span> <span class="toc-text">5.使用Result枚举来进行测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A1%B9%E7%9B%AE"><span class="toc-number">13.</span> <span class="toc-text">12.命令行项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E6%94%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">1.接收命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">13.2.</span> <span class="toc-text">2.读取文件内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="toc-number">13.3.</span> <span class="toc-text">3.代码重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8TDD%E5%9C%A8lib%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%9F%A5%E9%94%99"><span class="toc-number">13.4.</span> <span class="toc-text">4.使用TDD在lib里进行查错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9"><span class="toc-number">13.5.</span> <span class="toc-text">5.使用环境变量进行选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-number">13.6.</span> <span class="toc-text">6.进行错误信息定向输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%97%AD%E5%8C%85"><span class="toc-number">14.</span> <span class="toc-text">13.迭代器 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85"><span class="toc-number">14.1.</span> <span class="toc-text">1.闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">14.1.1.</span> <span class="toc-text">1 闭包的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%94%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AD%98%E5%82%A8%E9%97%AD%E5%8C%85"><span class="toc-number">14.1.2.</span> <span class="toc-text">2用结构来存储闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">14.1.3.</span> <span class="toc-text">3.使用闭包捕获外部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AD%E5%8C%85%E7%9A%84trait"><span class="toc-number">14.1.4.</span> <span class="toc-text">4.闭包的trait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.</span> <span class="toc-text">2.迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-iterator-trait"><span class="toc-number">14.2.1.</span> <span class="toc-text">1.iterator trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3api"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.几个迭代api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E8%80%97-%E4%BA%A7%E7%94%9F-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.3.</span> <span class="toc-text">3.消耗&#x2F;产生 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E8%80%97%EF%BC%88%E6%B6%88%E8%80%97%E6%80%A7%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89"><span class="toc-number">14.2.3.1.</span> <span class="toc-text">1.消耗（消耗性适配器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89"><span class="toc-number">14.2.3.2.</span> <span class="toc-text">2.产生（迭代器适配器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%97%AD%E5%8C%85-%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83"><span class="toc-number">14.2.3.3.</span> <span class="toc-text">3.迭代器+闭包 捕获环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.3.4.</span> <span class="toc-text">4.构建自定义的迭代器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%8F%91%E5%B8%83"><span class="toc-number">15.</span> <span class="toc-text">14.发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">16.</span> <span class="toc-text">15.智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Box-T"><span class="toc-number">16.1.</span> <span class="toc-text">1.Box&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-deref-trait"><span class="toc-number">16.2.</span> <span class="toc-text">2.deref trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%B3%95"><span class="toc-number">16.2.1.</span> <span class="toc-text">1.用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Deref-trait"><span class="toc-number">16.2.2.</span> <span class="toc-text">2.实现Deref trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-deref-coercion"><span class="toc-number">16.2.3.</span> <span class="toc-text">3.deref coercion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-drop-trait"><span class="toc-number">16.3.</span> <span class="toc-text">3.drop trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Rc-T"><span class="toc-number">16.4.</span> <span class="toc-text">4.Rc&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-RfCell-T"><span class="toc-number">16.5.</span> <span class="toc-text">5.RfCell&lt; T &gt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%B9%B6%E5%8F%91"><span class="toc-number">17.</span> <span class="toc-text">16.并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">1.多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87channel%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">17.2.</span> <span class="toc-text">2.通过channel实现线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Mutex-T-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">17.3.</span> <span class="toc-text">3.Mutex&lt; T &gt;共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Arc-T-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">17.4.</span> <span class="toc-text">4.Arc&lt; T &gt;原子引用计数</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2025
        <span class="footer-info-sep"></span>
        chengyiqiu
      </div>
      
        <div>
          Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          129.6k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          08:55
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">0.基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Clion%E5%BC%80%E5%8F%91Rust"><span class="toc-number">1.1.</span> <span class="toc-text">1.使用Clion开发Rust</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8cargo%E5%88%9B%E5%BB%BA%E5%BA%93%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2.使用cargo创建库项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%89%93%E5%8D%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text">3.打印地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-rust%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">1 rust简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%91%BD%E4%BB%A4%E8%A1%8C-vscode%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 命令行+vscode构建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BC%96%E5%86%99hello-world%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 编写hello world程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-cargo%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 cargo创建工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">2 rust基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%8E%B7%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 获取控制台输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%8C%85rand%EF%BC%88%E4%BF%AE%E6%94%B9toml%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 添加外部依赖包rand（修改toml文件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 使用枚举进行比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 处理异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E5%8F%8A%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">3 变量及控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">3.1变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1 不可变变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2 可变变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%B8%B8%E9%87%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.1.3 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-shadow%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 shadow机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 标量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%95%B4%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.3.1 整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%B5%AE%E7%82%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3.2 浮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3.3 bool类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.3.4 字符类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%85%83%E7%BB%84Tuple"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 元组Tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-Vector"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.5 Vector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-if-else"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-loop"><span class="toc-number">4.7.1.</span> <span class="toc-text">3.7.1 loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-while"><span class="toc-number">4.7.2.</span> <span class="toc-text">3.7.2 while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-for-each"><span class="toc-number">4.7.3.</span> <span class="toc-text">3.7.3 for - each</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">5.</span> <span class="toc-text">4 所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 栈内存与堆内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 所有权规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%88%9D%E8%AF%86String"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 初识String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 函数与所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%BC%95%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%88%87%E7%89%87"><span class="toc-number">5.6.</span> <span class="toc-text">4.5 切片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">5 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 结构定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 结构实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-struct%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 struct方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">7.</span> <span class="toc-text">6 枚举与模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 定义枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Option%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 Option枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-match"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-if-let%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 if-let语法糖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-package-crate-module"><span class="toc-number">8.</span> <span class="toc-text">7  package crate module</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9D%83%E9%99%90"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%BB%93%E6%9E%84%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 结构的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 枚举的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-use%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 use的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use"><span class="toc-number">8.5.1.</span> <span class="toc-text">use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pub-use"><span class="toc-number">8.5.2.</span> <span class="toc-text">pub use</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%89%B9%E6%AE%8A%E7%9A%84use%E4%BD%BF%E7%94%A8"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 特殊的use使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E5%BC%95%E5%85%A5%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84mod"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 引入自己写的mod</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9B%86%E5%90%88"><span class="toc-number">9.</span> <span class="toc-text">8 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Vector"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">2.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B8%85%E7%90%86"><span class="toc-number">9.1.3.</span> <span class="toc-text">3.清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96"><span class="toc-number">9.1.4.</span> <span class="toc-text">4.获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86"><span class="toc-number">9.1.5.</span> <span class="toc-text">5.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-enum-vector"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 enum &amp; vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.3.1.</span> <span class="toc-text">1.创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0-1"><span class="toc-number">9.3.2.</span> <span class="toc-text">2.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BF%E9%97%AE"><span class="toc-number">9.3.3.</span> <span class="toc-text">3.访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">9.3.4.</span> <span class="toc-text">4.内部表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%E7%9A%84%E5%9D%91"><span class="toc-number">9.3.5.</span> <span class="toc-text">5.字符串切片的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%8D%E5%8E%86"><span class="toc-number">9.3.6.</span> <span class="toc-text">6.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-HashMap"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%8F%8A%E6%8F%92%E5%85%A5"><span class="toc-number">9.4.1.</span> <span class="toc-text">1.创建及插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%81%8D%E5%8E%86"><span class="toc-number">9.4.2.</span> <span class="toc-text">2.遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0"><span class="toc-number">9.4.3.</span> <span class="toc-text">3.更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Hash%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.4.</span> <span class="toc-text">4.Hash函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">9.错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8Epanic-%E5%AE%8F"><span class="toc-number">10.1.</span> <span class="toc-text">1.不可恢复的错误与panic!宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Result%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">10.2.</span> <span class="toc-text">2.Result枚举与可恢复的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-unwrap%E4%B8%8Eexpect%E6%9B%BF%E6%8D%A2match"><span class="toc-number">10.3.</span> <span class="toc-text">3.unwrap与expect替换match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%B0%86%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E"><span class="toc-number">10.4.</span> <span class="toc-text">4.通过函数将错误返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9A%E2%80%9D-%E2%80%9D"><span class="toc-number">10.5.</span> <span class="toc-text">5.语法糖：”?”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E2%80%9D-%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">6.main函数中如何使用”?”运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8panic"><span class="toc-number">10.7.</span> <span class="toc-text">7.何时使用panic!</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%B3%9B%E5%9E%8B%EF%BC%8Ctrait%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">10.泛型，trait，生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">1.泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-trait"><span class="toc-number">11.2.</span> <span class="toc-text">2.trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%86trait%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.3.</span> <span class="toc-text">3.将trait作为参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3.生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">11.3.1.</span> <span class="toc-text">1.简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.2.</span> <span class="toc-text">2.函数的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-struct%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.struct的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">11.3.4.</span> <span class="toc-text">4.生命周期省略的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.5.</span> <span class="toc-text">5.静态生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%B5%8B%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">11.测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">1.编写测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">12.2.</span> <span class="toc-text">2.运行测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%AD%E8%A8%80%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">3.断言的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-assert"><span class="toc-number">12.3.1.</span> <span class="toc-text">1.assert!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-assert-eq"><span class="toc-number">12.3.2.</span> <span class="toc-text">2.assert_eq!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-assert-ne"><span class="toc-number">12.3.3.</span> <span class="toc-text">3.assert_ne!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%99%E6%96%AD%E8%A8%80%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF"><span class="toc-number">12.3.4.</span> <span class="toc-text">4.给断言添加自定义消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7should-panic"><span class="toc-number">12.4.</span> <span class="toc-text">4.属性should_panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8Result%E6%9E%9A%E4%B8%BE%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">12.5.</span> <span class="toc-text">5.使用Result枚举来进行测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A1%B9%E7%9B%AE"><span class="toc-number">13.</span> <span class="toc-text">12.命令行项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E6%94%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">1.接收命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">13.2.</span> <span class="toc-text">2.读取文件内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="toc-number">13.3.</span> <span class="toc-text">3.代码重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8TDD%E5%9C%A8lib%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%9F%A5%E9%94%99"><span class="toc-number">13.4.</span> <span class="toc-text">4.使用TDD在lib里进行查错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9"><span class="toc-number">13.5.</span> <span class="toc-text">5.使用环境变量进行选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-number">13.6.</span> <span class="toc-text">6.进行错误信息定向输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%97%AD%E5%8C%85"><span class="toc-number">14.</span> <span class="toc-text">13.迭代器 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85"><span class="toc-number">14.1.</span> <span class="toc-text">1.闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">14.1.1.</span> <span class="toc-text">1 闭包的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%94%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AD%98%E5%82%A8%E9%97%AD%E5%8C%85"><span class="toc-number">14.1.2.</span> <span class="toc-text">2用结构来存储闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">14.1.3.</span> <span class="toc-text">3.使用闭包捕获外部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AD%E5%8C%85%E7%9A%84trait"><span class="toc-number">14.1.4.</span> <span class="toc-text">4.闭包的trait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.</span> <span class="toc-text">2.迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-iterator-trait"><span class="toc-number">14.2.1.</span> <span class="toc-text">1.iterator trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3api"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.几个迭代api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E8%80%97-%E4%BA%A7%E7%94%9F-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.3.</span> <span class="toc-text">3.消耗&#x2F;产生 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E8%80%97%EF%BC%88%E6%B6%88%E8%80%97%E6%80%A7%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89"><span class="toc-number">14.2.3.1.</span> <span class="toc-text">1.消耗（消耗性适配器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89"><span class="toc-number">14.2.3.2.</span> <span class="toc-text">2.产生（迭代器适配器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%97%AD%E5%8C%85-%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83"><span class="toc-number">14.2.3.3.</span> <span class="toc-text">3.迭代器+闭包 捕获环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.3.4.</span> <span class="toc-text">4.构建自定义的迭代器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%8F%91%E5%B8%83"><span class="toc-number">15.</span> <span class="toc-text">14.发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">16.</span> <span class="toc-text">15.智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Box-T"><span class="toc-number">16.1.</span> <span class="toc-text">1.Box&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-deref-trait"><span class="toc-number">16.2.</span> <span class="toc-text">2.deref trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%B3%95"><span class="toc-number">16.2.1.</span> <span class="toc-text">1.用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Deref-trait"><span class="toc-number">16.2.2.</span> <span class="toc-text">2.实现Deref trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-deref-coercion"><span class="toc-number">16.2.3.</span> <span class="toc-text">3.deref coercion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-drop-trait"><span class="toc-number">16.3.</span> <span class="toc-text">3.drop trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Rc-T"><span class="toc-number">16.4.</span> <span class="toc-text">4.Rc&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-RfCell-T"><span class="toc-number">16.5.</span> <span class="toc-text">5.RfCell&lt; T &gt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%B9%B6%E5%8F%91"><span class="toc-number">17.</span> <span class="toc-text">16.并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">1.多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87channel%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">17.2.</span> <span class="toc-text">2.通过channel实现线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Mutex-T-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">17.3.</span> <span class="toc-text">3.Mutex&lt; T &gt;共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Arc-T-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">17.4.</span> <span class="toc-text">4.Arc&lt; T &gt;原子引用计数</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>






<script src="/js/pjax_script.js" data-pjax></script>

















  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.2' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

