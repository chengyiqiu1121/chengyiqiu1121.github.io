
  <!DOCTYPE html>
  <html lang="en"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>
    window.icon_font = '4552607_ikzjpc9jicn';
  </script>
  
  
  <title>
    深度理解Linux内核 |
    
    Hexo
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="ch2 内存地址内存地址程序员可以随意的指定内存地址，就好像直接访问内存单元中的内容一样。但是当处理器是8086系列时，需要讨论一下下面的三种地址：  逻辑地址，包含在机器语言指令中，用来特别制定操作数或者指令的地址。这类地址体现了众所周知的8086分段架构，这种架构能够使得WIndows程序员将他们的程序分成段（segment）。每个逻辑地址由段和偏移组成，偏移代表的是里段首的距离。 线性地址&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="深度理解Linux内核">
<meta property="og:url" content="http://example.com/2025/04/17/ulk3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ch2 内存地址内存地址程序员可以随意的指定内存地址，就好像直接访问内存单元中的内容一样。但是当处理器是8086系列时，需要讨论一下下面的三种地址：  逻辑地址，包含在机器语言指令中，用来特别制定操作数或者指令的地址。这类地址体现了众所周知的8086分段架构，这种架构能够使得WIndows程序员将他们的程序分成段（segment）。每个逻辑地址由段和偏移组成，偏移代表的是里段首的距离。 线性地址&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250417122801055.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250417130027286.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250417132233412.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250417134536116.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250417141006175.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250417141103482.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250417150731539.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250417185939560.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250418121948658.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250418153001849.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250421150444950.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250421190928102.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250421202436126.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250422120641467.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250422124018104.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250422134924869.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250422194845630.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250423142011158.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250423145221042.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250423151317515.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/ulk3//image-20250423152045521.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250423190957875.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250423191825615.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250423192754112.png">
<meta property="og:image" content="http://example.com/2025/04/17/ulk3/image-20250423194246862.png">
<meta property="article:published_time" content="2025-04-17T05:20:12.000Z">
<meta property="article:modified_time" content="2025-04-23T12:43:06.299Z">
<meta property="article:author" content="chengyiqiu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/04/17/ulk3/image-20250417122801055.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 7.2.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">Home</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">Archives</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">About</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">Friend</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/banner.jpg" alt="深度理解Linux内核">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>深度理解Linux内核</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-ulk3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2025/04/17/ulk3/" class="article-date-link">
    <time datetime="2025-04-17T05:20:12.000Z" itemprop="datePublished">2025-04-17</time>
  </a>
</div>

      

    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ch2-内存地址"><a href="#ch2-内存地址" class="headerlink" title="ch2 内存地址"></a>ch2 内存地址</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>程序员可以随意的指定内存地址，就好像直接访问内存单元中的内容一样。但是当处理器是8086系列时，需要讨论一下下面的三种地址：</p>
<ul>
<li>逻辑地址，包含在机器语言指令中，用来特别制定操作数或者指令的地址。这类地址体现了众所周知的8086分段架构，这种架构能够使得WIndows程序员将他们的程序分成段（segment）。每个逻辑地址由段和偏移组成，偏移代表的是里段首的距离。</li>
<li>线性地址&#x2F;虚拟地址，直观的例子，STM32的虚拟地址是4GB。</li>
<li>物理地址，用来访问实际内存芯片中的内存单元。物理地址指的是一类电子信号，能够被发送，从微处理器的地址引脚到内存总线。物理地址表现为32位或者36位的无符号整数。</li>
</ul>
<p>内存管理单元（MMU）能够把逻辑地址转换成线性地址，通过一个被称为分段单元（segment unit）的物理电路。随后，一个二级电路，被称为分页单元（paging unit），将线性地址转为物理地址。</p>
<p><img src="/2025/04/17/ulk3/image-20250417122801055.png" alt="image-20250417122801055"></p>
<p>在多处理器系统，所有的CPU共享同一片内存。这意味着不同的CPU可以同时访问RAM芯片。由于对RAM的读写操作必须被有序的执行，名为内存仲裁器（memory arbiter）的硬件电路，被插入在RAM和总线之间。内存仲裁的作用是：如果内存芯片空闲，批准CPU的访问请求；如果内存芯片忙（被其他CPU占用），则延迟这个请求。</p>
<p>即使是在单处理器系统中，也存在内存仲裁硬件，原因是存在DMA控制器，能够同时和CPU访问RAM。</p>
<p>在多处理器系统中，内存仲裁的设计更加复杂，因为有着更加多的端口。例如，在双核的奔腾处理器中，维护着一个双端口的仲裁器（对于每一个内存单元），确保CPU使用内存前，和另一个CPU交换同步信息，然后再访问RAM CHIP。对于编程而言，仲裁是不可见的，因为这完全交给硬件电路实现。</p>
<p>PS：这里的CPU指的是core</p>
<p>Q：我在看Linux操作系统，告诉我，内存仲裁实际上是怎么样的？是每一根内存条一个memory arbiter，还是每一个字节一个memory arbiter，还是每一个字？</p>
<p>A：仲裁发生在内存控制器层级，一个控制器可以管理多根内存条，多通道系统中的每个通道有独立的仲裁逻辑。现代内存系统以缓存行(通常64字节)为最小传输单位，仲裁器处理的是内存事务，不是单个字节或字。</p>
<h2 id="硬件分段"><a href="#硬件分段" class="headerlink" title="硬件分段"></a>硬件分段</h2><p>从80286模式开始，Intel微处理器开始以两种不同的方式执行地址转换，分别是：实模式（real mode）和保护模式（protected mode）。下一节讲述，当保护模式开启时，地址转换是如何进行的。大多数情况下，启用实模式的原因是为了保证处理器和旧型号的兼容性，同时允许操作系统启动（bootstrap）</p>
<h3 id="段选择符和分段寄存器"><a href="#段选择符和分段寄存器" class="headerlink" title="段选择符和分段寄存器"></a>段选择符和分段寄存器</h3><p>逻辑地址由段标识符和偏移两部分组成。段标识符标识这个地址在哪个段里面，偏移则是告诉相对段首的距离。段标识符是一个16-bit的字段，也被称作段选择符。偏移是一个32-bit的字段。这里只简要介绍，后面会详细介绍的。</p>
<p><img src="/2025/04/17/ulk3/image-20250417130027286.png" alt="image-20250417130027286"></p>
<p>为了便于CPU取回段描述符，处理器一共了分段寄存器，用于暂存段描述符。尽管分段寄存器只有六个（cs, ss, ds, es, fs, gs），程序可以复用这些寄存器，通过将他们原本的内容暂存到内存中（稍后会恢复）。这六个寄存器，有三个有特殊作用：</p>
<ul>
<li>cs，代码分段寄存器，指向的是包含程序指令的分段</li>
<li>ss，堆栈分段寄存器，指向的是含有当前程序堆栈的分段</li>
<li>ds，数据分段寄存器，指向的是含有全局变量和静态数据的分段</li>
</ul>
<p>剩余的三个分段寄存器是通用的，可以指向任意的数据分段。</p>
<p>特别地，cs寄存器有另外的重要的作用：它包含一个2-bit的字段，能够特别指出当前CPU的特权级别（Current Privilege Level，CPL）：</p>
<ul>
<li>CPL&#x3D;0，代表最高级别，Linux中的内核级</li>
<li>CPL&#x3D;3，代表用户界别</li>
</ul>
<p>Linux只用了这两个级别。</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>每一个分段都可以被一个8-byte的段描述符来表示，用来描述分段的属性。（PS：这个按照RTOS里的TCB来理解，用来描述每个Task的属性）。段描述符要么存在全局描述符表（Global Descriptor Table，GDT），或者局部描述符表（Local Descriptor Table，LDT）中。</p>
<p>通常，只定义一个GDT，然而，如果处理器需要创建额外的分段（不同于GDT中的那些段描述符指向的分段），处理器也可以创建他们自己的LDT。GDT在主存储器中的地址和大小被存储在gdtr这个控制寄存器中，同时LDT的地址和大小被存在ldtr控制寄存器中。</p>
<p>关于段描述符，下面有个表格解释了其中不同的字段：</p>
<p><img src="/2025/04/17/ulk3/image-20250417132233412.png" alt="image-20250417132233412"></p>
<p>这里存个档，对后面出现的重要字段进行解释：</p>
<ul>
<li>S标志，如果是空的，代表指向的是系统分段，里面可能存储有重要的数据结构，例如LDT；否则，就是普通的代码或者数据分段</li>
<li>Type字段，描述分段类型，以及其访问权限，</li>
<li>。。。</li>
</ul>
<p>由于有不同的分段（代码分段，数据分段，堆栈分段），因此也有不同的段描述符，如下：</p>
<ul>
<li>代码分段描述符，表示这个分段描述符指向的是一个代码分段；代码分段描述符既可以存在于GDT中，也可以存在于LDT中。这个分段描述符设置了S标志，表示指向的分段不是系统分段。</li>
<li>数据分段描述符，表示指向数据分段；可以被存在于GDT或者LDT中。这个描述符含有S标志。堆栈分段就是通过通用数据分段来实现的。</li>
<li>任务状态分段描述符（TSSD），指向任务状态分段（TSS）。TSS是用来保存处理器的寄存器的（上下文保存）。TSSD只能被存储在GDT中。TSSD的type被设置成11或者9，取决于相应的进程是否正在被处理器执行（A：这样可以避免任务的递归调用）。S标志被设置为0.</li>
<li>LDT描述符（LDTD），指向包含LDT的分段；LDTD只能出现在GDT中。Type字段被设置为2，S标志设置为0。</li>
</ul>
<img src="./ulk3//image-20250417134536116.png" alt="image-20250417134536116" style="zoom:50%;">

<p>下一节会讲一个段描述符是应该被存在GDT还是LDT中。</p>
<h3 id="快速访问段描述符"><a href="#快速访问段描述符" class="headerlink" title="快速访问段描述符"></a>快速访问段描述符</h3><p>回顾一下，读逻辑地址由两部分组成：16-bit的段标识符（选择符）和32-bit的段内偏移。并且，分段寄存器中仅仅只保存了段标识符。</p>
<p>为了加速逻辑地址到线性地址的转换，8086处理器提供了一个额外的不可编程寄存器（不可以被程序员设置的）。对于那六个可编程的分段寄存器（cs，ds，ss…），都各自含有一个不可编程的寄存器（CPU resister）。每个不可编程寄存器包含一个8-byte的段描述符（这个段描述符指向的就是分段寄存器中的段标识符对应的分段，晕@.@）。每次段标识符被加载到分段寄存器中时，相应的段描述符也会被从内存家在到相应的不可编程寄存器。然后，逻辑地址到线性地址的翻译就不需要通过额外一次访存来取出GDT或LDT中的段描述符。CPU可以直接从不可编程寄存器中取出相应的段描述符。当分段寄存器中的内容改变时，才需要重新访存GDT和LDT。</p>
<p>两种取段描述符的方法如下：</p>
<p><img src="/2025/04/17/ulk3/image-20250417141006175.png" alt="image-20250417141006175"></p>
<p>段标识符中有三个字段，如下：</p>
<p><img src="/2025/04/17/ulk3/image-20250417141103482.png" alt="image-20250417141103482"></p>
<p>由于段描述符是8字节，其在GDT或LDT中的相对地址是通过将段标识符的13位索引字段乘以8来获得的。例如，GDT的地址是0X0002,0000（这个地址存储在gdtr里），段标识符里的index是2，那么段描述符的地址就是0X0002,0000+(2 * 8)&#x3D;0X0002,0010。</p>
<p>GDT中的第一个条目始终设置为0。这样可以保证：如果一个逻辑地址的段标识符是NULL，那么这个地址被认定非法，然后导致异常。GDT中能够存储的最大的段描述符的数目为$2^{13}-1$。</p>
<h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>分段单元是用来将逻辑地址转为线性地址的，具体操作如下：</p>
<ul>
<li>检查TI字段，判断是在哪一个描述符表（GDT or LDT）中存放着分段描述符。如果GDT，那么就从gdtr中取出GDT的线性基地址；如果是ldtr，也是如此。</li>
<li>根据段选择符中的index字段，计算段描述符的地址。index字段会乘以8（段描述符的长度8-byte），然后结果会加上gdtr或者ldtr中的基地址。</li>
<li>在段描述符里找到Base字段，然后加上段内偏移offset，这样就得到了线性地址。</li>
</ul>
<img src="./ulk3//image-20250417150731539.png" alt="image-20250417150731539" style="zoom:50%;">

<p>需要注意的是，多亏了不可编程寄存器和分段寄存器关联，只有当分段寄存器不得不改变时，才会执行前两个操作。</p>
<h2 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h2><p>分段机制已经被包括在8086系处理器里，为的是鼓励程序员将他们的应用程序拆分为逻辑上相邻的实体，例如：子程序、全局or局部数据区域。然而，Linux很有限地使用分段机制。事实上，分段和分页机制在某种程度上是冗余的，因为这两者都能够被用来拆分进程的物理地址空间。例如：1. 分段能够分配不同的线性地址空间给每个进程；2. 分页能够将相同的线性地址空间映射到不同的物理地址空间。Linux偏好分页而不是分段，原因如下：</p>
<ul>
<li>当所有进程共享相同的线性地址集合时，内存管理机制变得更加简单</li>
<li>Linux的设计目标之一是尽可能的兼容各种不同的架构。其中，RISC架构对分段的支持特别有限。</li>
</ul>
<p>Linux 2.6版本仅仅在8086架构需要时，才会使用分段。</p>
<p>所有运行在用户级的Linux进程使用相同的分段对（pair of segments）来寻址指令和数据。分别地，这些分段被称作用户代码段（user code segment）和用户数据段（user data segment），下表展示了这四个关键段的分段描述符的字段：</p>
<img src="./ulk3//image-20250417185939560.png" alt="image-20250417185939560" style="zoom:50%;">

<p>分别地，相应的分段选择符被这些macros所定义：<code>__USER_CS, __USER_DS, __KERNEL_CS, __KERNEL_DS</code>。为了对内核代码段进行寻址，例如，内核仅仅将<code>__KERNEL_CS</code> macro产生的值加载到cs分段寄存器中。</p>
<p>需要注意的是，和这些段相关的线性地址都是从0开始的，直到到达地址的限制值$2^{32}-1$。这意味着，无论是用户态还是内核态的进程，可能会使用同一个逻辑地址。</p>
<p>让所有段从0X0000,0000开的的另一个很重要的结果是，逻辑地址和线性地址保持一致。即，逻辑地址和线性地址的偏移量永远保持一致。</p>
<p>如前所述，CPU的当前特权级别表示，处理器是否处于用户态或者内核态。并且，CPL被cs寄存器中的段选择符的RPL字段所指定。无论何时CPL改变，某些段寄存器肯定会更新。例如，当CPL&#x3D;3，表示用户态，ds寄存器一定持有用户数据段的段选择符；然而， 当CPL&#x3D;0时，ds寄存器存放的肯定是内核数据段的数据选择符。</p>
<p>另一个很相似的例子是，对于ss寄存器（堆栈分段寄存器），当CPL&#x3D;3时，指向的一定是用户态堆栈（用用户数据段实现的）；当CPL&#x3D;0时，ss寄存器指向的一定是内核态堆栈（有内核数据段实现）。当处理器从用户态切换到内核态时，Linux始终要确认：ss寄存器持有内核数据段的段选择符。</p>
<p>当保存一个指针到一条指令或者一个数据结构时，内核不需要保存逻辑地址的段选择符，因为ss寄存器中已经包含了当前的段选择符。例如，当内核调用一个函数，内核会执行一个call汇编语言指令，这个指令仅仅指定它逻辑地址的偏移量；段选择符被隐式地选择了，因为cs寄存器中持有的就是段选择符。由于只有一种类型的段，能够在内核态下执行，也就是在<code>__KERNEL_CS</code>中标识的代码段，无论何时CPU切换到内核态，内核都会将<code>__KERNEL_CS</code>加载到cs寄存器。另一个很相似的例子就是，指向内核数据结构的指针（隐式被ds寄存器加载），指向用户数据结构时，内核则会显式使用es寄存器。</p>
<p>除了上面讨论的四种分段，Linux还使用了一些其他特殊的段，将会在下一节讨论。</p>
<h3 id="Linux中的全局描述符表"><a href="#Linux中的全局描述符表" class="headerlink" title="Linux中的全局描述符表"></a>Linux中的全局描述符表</h3><p>在单核系统中，只有一个GDT，而在多核系统中，每个CPU都有一个GDT。所有的GDT都被保存在名为<code>cpu_gdt_table</code>数组里，而这些GDT的地址和大小（被用来初始化gtdr寄存器）被存储在名为<code>cpu_gdt_descr</code>的数组里。如果你越过Linux源代码的索引，你会发现这些符号被定义在名为<code>arch/i386/kernel/head.S</code>放入文件里。这本书里列举的每一个宏、函数、符号，都可在源文件索引里找到。</p>
<p>GDT的布局如下：</p>
<p><img src="/2025/04/17/ulk3/image-20250418121948658.png" alt="image-20250418121948658"></p>
<p>每个GDT包含18个段描述符，14个null、没使用的、或者保留的条目。没使用的条目的作用是：当段描述符被访问时，可以被遗弃保留在32-byte的硬件缓存中。</p>
<p>18个包含在每个GDT中的段描述符指向下面描述的这些段：</p>
<ul>
<li>用户&#x2F;内核 代码&#x2F;数据段</li>
<li>一个任务状态段（TSS），系统中每个处理器的TSS都不同。指向TSS的线性地址空间，是，指向内核数据段线性地址空间，的一个子集（这句话的意思大概是TSS是内核数据段的子集？）。TSS被顺序的存储在<code>init_tss</code>数组里；特别地，第n个CPU的TSS的<code>Base</code>字段，指向的是<code>init_tss</code>的第n个元素（也就是说，有几个CPU，<code>init_tss</code>的长度就是多少）。G字段被清除了（置零），<code>Limit</code>字段被设置为了<code>0xeb</code>（TSS段长236-byte）。<code>Type</code>字段被设置为9或者11，<code>DPL</code>字段被设置为0，因为处于用户态的处理器不被允许去访问TSS段。</li>
<li>包含所有默认局部描述符表（LDT）的段，通常所有处理器共享一个。</li>
<li>三个线程局部存储段（TLS），这个机制允许多线程程序来充分利用至多三个段，来持有每个线程局部的数据（本地数据）。两个系统调用：<code>set_thread-area(), get_thread_area()</code>，分别表示为正在执行的进程创建和释放TLS段。</li>
<li>三个有关高级电源管理（APM）的段，BIOS代码使用这些段，当Linux APM驱动调用BIOS函数来获取或者设置APM驱动的状态。这些段可能会用到常规的代码或者数据分段。</li>
<li>五个和“即插即用”（Plug and Play, PnP）BIOS服务相关的分段。当PnP驱动调用BIOS函数来检测PnP设备使用的资源时，会用到这些段。这些段也是常规的代码或者数据分段。</li>
<li>一个特殊的TSS段（任务状态段），这个段被内核用来捕获异常。（”Double Fault” exceptions）</li>
</ul>
<p>如前面所述。每个处理器都有GDT的一份拷贝。所有GDT的拷贝保存着相同的条目，除了某些少数情况。首先，每个处理器都有它独有的TSS段，因此GDT中相应的条目也会有所不同；更进一步，少数GDT中的条目可能取决于CPU正在运行的进程（例如LDT和TLS段描述符）；最后，在某种情况下，处理器可能会短暂地更改GDT拷贝中的条目，例如，当调用APM BIOS过程时。</p>
<h3 id="Linux中的局部描述符表"><a href="#Linux中的局部描述符表" class="headerlink" title="Linux中的局部描述符表"></a>Linux中的局部描述符表</h3><p>大部分Linux用户态的应用程序不回用到LDT，因此内核定义了一个默认的LDT，在所有进程中共享。默认的LDT被存在名为<code>default_ldt</code>的数组中。这个数组包含五个条目，然而只有两个条目能够被内核高效地使用：a call gate for iBCS executables, and a call gate for Solaris&#x2F;x86 executables。调用门是8086处理器提供的一种机制，当CPU执行预先定义好的函数时，用来改变当前的特签级别。这本书不会过多讨论调用门，详细信息可以在Intel文档里找到。</p>
<p>然而，在某些特殊情况下，进程可能会需要设置他们自己的LDT。例如，当运行<code>Wine</code>时，<code>Wine</code>执行Windows下的面向分段应用程序（意思应该就是使用分段），进程设置自己的LDT就很有用。系统调用<code>modify_ldt()</code>允许进程设置自己的LDT。</p>
<p>任何通过<code>modify_ldt()</code>创建的自定义LDT，也需要它自己独有的分段。当一个处理器开始运行有自定义LDT的进程时，这个处理器对应的GDT拷贝中的LDT条目也会改变。</p>
<p>用户态的应用程序也能够通过<code>modify_ldt()</code>来分配新的分段。然而，内核永远不会使用这些分段，并且，也不回去追踪相应的段描述符，因为他们被包含在进程定制化的LDT中。</p>
<h2 id="硬件分页原理"><a href="#硬件分页原理" class="headerlink" title="硬件分页原理"></a>硬件分页原理</h2><p>分页单元将线性地址转换成物理地址。分页单元的关键任务之一是检查访问类型是否超出了线性地址的访问权限（就是检查权限吧？？）。如果访存是非法的，分页单元会产生一个分页异常（Page Fault exception）。</p>
<p>为了效率，线性地址被划分为组，以固定的长度，称为分页。在一个分页内的连续线性地址，会被同样映射到连续的一块物理地址。通过这种方式，内核可以指定分页的物理地址和访问权限，而不是线性地址。根据这个，我们应该使用分页来代指一束线性地址以及其中包含的数据。</p>
<p>分页单元认为RAM是被分成了定长的页帧（Page Frames，好像也被称为页框，有时候也会指为物理分页Physical Pages）每个页帧包含一个分页，页帧和分页长度保持一致。页框是主存的主要构成成分，因此页框是一块存储区域。对分页和页框进行区分十分重要，前者只是一块数据，可能被存储在任何一个页框内，甚至是磁盘上（swap</p>
<p>将线性地址映射到物理地址的数据结构被称为页表（page table）页表被存储在主存当中，并且，在使用页表之前，必须由Linux内核进行正确的初始化。</p>
<p>从80386开始，所有的8086处理器都支持分页，通过设置控制寄存器<code>cr0</code>的 <code>PG</code>标志，能够开启分页，当设置<code>PG=0</code>时，线性地址将会被直接解释为物理地址（不作任何转换）</p>
<h3 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h3><p>从80386开始，Intel处理器的分页单元处理4KB的分页。</p>
<p>将32-bit的线性地址拆成三部分：</p>
<ul>
<li>目录（Directory），10-bit，是最重要的部分</li>
<li>表（Table），中间的10-bit</li>
<li>偏移（offset），最后的12-bit</li>
</ul>
<p>线性地址的翻译通过两步完成，每一步都包含一种类型的翻译表（translation table）。第一个翻译表是页目录（Page Directory），第二个是页表（Page Table）</p>
<p>二级表的目的是为了减少处理页表所消耗的内存。假如简单使用一级页表来进行翻译，将需要最多$2^{20}$的条目来表示每个进程的页表（一个条目4-byte，一共就是4-MB内存），如果一个进程申请了4GB的虚拟内存，但是其实大部分没用到，那么页表开销依然是4MB。二级页表这样做的好处是，仅仅只有虚拟地址区域确实被使用了，才会建立对应的页表。</p>
<p>任何一个运行的进程一定有页目录。然而，没有必要对进程的所有页表都分配内存（这样和一级页表没有区别），只有当进程确实需要页表的时候，再给对应的页表分配内存，这样更加高效。</p>
<p>PS：Page Directory，页目录，感觉叫页表目录更加合适，因为页目录其实是页表的索引。</p>
<p>正在使用的页目录的物理地址被存储在名为<code>cr3</code>的控制寄存器中。线性地址的<code>Directory</code>字段决定了页目录中的条目，这个条目指向的是正确的页表。更进一步，线性地址的<code>Table</code>字段决定怎么在页表中找到正确的条目，这个条目持有的是包含page的page frame的物理地址。最后，<code>offset</code>字段决定了page frame的的相对偏移。因为offset是12-bit，按byte寻址，那么每一个含有$2^{12}$，也就是4096-byte。</p>
<p><img src="/2025/04/17/ulk3/image-20250418153001849.png" alt="image-20250418153001849"></p>
<p>页目录和页表的长度都是10-bit，因此，最多1024条目。所以虚拟内存的最大值是$1024\times 1024\times 4096B$，也就是4GB，刚好cover所有的memory cell。</p>
<p>页目录和页表中的条目含有相同的结构，每一个条目包含下面的字段：</p>
<ul>
<li>。。。略</li>
</ul>
<h3 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h3><p>从奔腾型号开始，8086位处理器引入了扩展分页，可以将页帧大小从4KB提升到4MB。扩展分页用于将大段连续的线性地址范围转换到相应的物理部分。在这种情况下，内核可以不依赖中间页表来进行地址翻译，更加节省TLB条目的空间（后面会讲）</p>
<img src="./ulk3//image-20250421150444950.png" alt="image-20250421150444950" style="zoom:50%;">

<p>通过设置页目录里的<code>Page Size</code>标志来开启扩展分页。进而，线性地址被划分为两部分：10位的目录和22位的偏移（对应4MB的页帧）</p>
<p>扩展分页的页目录和常规分页的页目录相同，除了下面几点：</p>
<ul>
<li><code>Page Size</code>标志必须被设置</li>
<li>20位的物理地址中，只有前10位是有效的，因为每一个物理地址都是按照4MB的边界对齐的，因此后22位全部是0.</li>
</ul>
<p>扩展分页和常规分页共存。通过设置处理器的<code>cr4</code>寄存器中的<code>PSE</code>标志即可。</p>
<h3 id="硬件保护方案"><a href="#硬件保护方案" class="headerlink" title="硬件保护方案"></a>硬件保护方案</h3><p>分页单元使用了一个和分段单元不同的保护方案。尽管8086处理器允许四种可能的优先级来分段，只有两种特权级别和分页以及页表相关，因为优先级被<code>User/Supervisor</code>标志所控制。当这个标志为0时，相应的页只有在CPL（当前特权级别）小于3时（对Linux而言，也就是内核态下），才能够被访存。当标志为1时，相应的页可以在任何状态下被访存。</p>
<p>此外，不像分段那样有三种访问权限（读，写，执行），分页只有两种访问权限（读和写）。当页目录或者页表项中的<code>Read/Write</code>标志为0时，相对应的页表只有读权限；反之，则拥有读写权限。</p>
<h3 id="常规分页的一个例子"><a href="#常规分页的一个例子" class="headerlink" title="常规分页的一个例子"></a>常规分页的一个例子</h3><p>举个简单的例子，帮助我们理解常规分页是如何工作的。假设，操作系统内核为一个正在运行的进程分配的线性地址空间是<code>0x2000,0000-0x2003,ffff</code>。这块线性地址区域包含了64个分页。在这里，我们并不关心这64个分页对应的物理页帧是什么，事实上，有些页帧可能甚至不在主存中。在这里，我们只对页表项中的保留字段感兴趣。</p>
<p>这篇空间的前十位是相同的，代表的正是页表目录，我们从这里开始。取出前十位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b0010</span> <span class="number">0000</span> <span class="number">00</span>=<span class="number">0b00</span>,<span class="number">1000</span>,<span class="number">0000</span>=<span class="number">0x0b0</span>=<span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>也就是说，这个页表目录，指向的索引是整张页表目录的第129个条目，这个条目中存放的就是这个进程对应的页表的物理地址，如果这个进程没有被分配其他的线性地址，其他1023个条目中存放的就都是0.</p>
<p><img src="/2025/04/17/ulk3/image-20250421190928102.png" alt="image-20250421190928102"></p>
<p>在上述的假设中，页表目录中只有一个条目是有效的，其余全是0，也就是说这个进程只有一张页表。更进一步，操作系统分配的页表是<code>0x000-0x3f</code>，换算成十进制就是0到63。也就是说，这张唯一的页表里，只有前64个条目里存放着物理地址，其余的条目里全是0。这里已经体现出二级页表的好处了，虽然操作系统分配的是64张页表，但其实进程只用到了一张页表，极大地节省了内存空间（维护64张页表-&gt;维护一张页表目录表+一张页表）</p>
<p>假设这个进程需要读取一个字节，对应的线性地址是<code>0x2002,1406</code>。这个地址会被分页单元捕获，然后按照下面步骤进行翻译：</p>
<ul>
<li>首先取出最大的10位，页表目录索引字段，也就是<code>0x80</code>，来找到相应的页表的物理地址</li>
<li>其次，取出中间的十位，也就是<code>0x21</code>，来找到页表中哪一项条目是这个字节的物理地址对应的页帧。</li>
<li>最终，取出最后12位<code>0x406</code>，和取出的页帧concat，得到最终这个页帧中的字节所在的位置。</li>
</ul>
<p>如果页表的第<code>0x21</code>个条目的<code>Present</code>标志被清除，那么就代表这个页表不在主存（页帧）中，在这种情况下，分页单元会报告一个<code>Page Fault</code>异常，当转换这个线性地址时。同样，下面这种情况也会报告异常，当进程尝试去访问超出操作系统分配的线性空间的地址（也就是超出<code>0x2000,0000-0x2003,ffff</code>了），访问没有分配的线性地址，最后得到的页表条目会是0，当然，他们的<code>Present</code>标志也是被清除的。</p>
<h3 id="物理地址扩展分页机制"><a href="#物理地址扩展分页机制" class="headerlink" title="物理地址扩展分页机制"></a>物理地址扩展分页机制</h3><p>处理器能够使用的RAM总量被连接在地址总线上的地址引脚所限制。从旧的80386 Intel处理器奔腾处理器，使用的都是32位的物理地址。理论上，这类系统最多支持4GB的RAM。实际上，由于用户态处理器对线性地址的需求，内核不能直接分配超过1GB的RAM。</p>
<p>然而，有些大型服务器需要同时运行成百上千的线程，需要的RAM超出了4GB，推动了Intel扩展32-bit的8086架构的地址总数。</p>
<p>为了解决内存不够的挑战，Intel将内存引脚数从32提升到36。从奔腾pro处理器开始，所有的Intel处理器能够以36位的方式寻址，寻址空间大小为$2^{36}&#x3D;64GB$。然而，只有引入新的分页机制，将32-bit的线性地址转换成36-bit的物理地址，才能够利用增加的物理地址。</p>
<p>在奔腾pro处理器上，Intel引入了一种被称为物理地址扩展(Physical Address extension, PAE)的机制。</p>
<p>PAE开启的条件是：设置控制寄存器<code>cr4</code>的PAE标志。</p>
<p>PS：36-bit没啥意思，这里直接jump到64-bit了，fxxk intel</p>
<h3 id="64-bit架构的分页机制"><a href="#64-bit架构的分页机制" class="headerlink" title="64-bit架构的分页机制"></a>64-bit架构的分页机制</h3><p>前面讲述了32-bit架构下，使用二级分页能够很好地工作。然而，在64-bit下，这样使用不合适，原因如下：</p>
<p>一般的分页大小是4KB，需要消耗12位地址，因此还剩余52位。如果我们只使用64位中的48位来寻址（寻址空间256TB），有12位分配给页内偏移，36位分配给页目录和页表。平均分的话，页目录和页表都是18位，那么，操作系统中对应的页表目录表和页表有$2^{18}$个条目。</p>
<p>PS：以页表目录表举例，里面存放的是页表的物理地址，64-bit，那么一张页表目录表的大小就是$2^{24}bit&#x3D;16Mbit&#x3D;2MB$。</p>
<p>因此，所有硬件上支持分页的系统，对于64-bit的处理器，都会使用额外的分页级别。具体使用几级分页取决于特定的处理器类型，平台架构。</p>
<p><img src="/2025/04/17/ulk3/image-20250421202436126.png" alt="image-20250421202436126"></p>
<h3 id="硬件缓存"><a href="#硬件缓存" class="headerlink" title="硬件缓存"></a>硬件缓存</h3><p>现代微处理器的时钟率都是以GHz为单位的，而DRAM的访存时间通常在数百时钟周期。这意味着，当执行的指令需要从RAM中取操作数，或者是存结果到RAM中时，CPU会被限制很多，因为数百的时钟周期被用于访存。</p>
<p>硬件缓存引入的目的是减少CPU和RAM速度不匹配的问题。硬件缓存是基于局部性原则，这对于程序和数据都成立。这是由于程序中的循环结构和线性数组中的相近的数据，近期使用最多的地址有很高概率在未来被再次访问。因此，引入一种更快更小的存储空间，来存放这些代码和数据，是有意义的。出于这个目的，一种被称为<code>line</code>的单元被引入到8086架构中。这些单元由几行连续的字节组成，这些字节以突发模式传输，在低速的DRAM中和高速的猜测板载SRAM中（SRAM被用于实现cache）</p>
<p>cache又被划分为了几个子集。在极端情况下，如果主存中的某一行永远被存储在cache中确定的同样的位置，那么cache能够被直接映射(direct mapped)。另一种极端情况下，cache是全关联的(fully associative)，这意味着主存中的任意一行可以被存储在cache中的任意位置。但是，大部分的cache都是N路组关联的（N-way set associative），主存中的任意一行能够被存储在N行缓存中的任意一行。例如，内存中的一行能够被存储在2路组关联中的两个不同行。</p>
<p>缓存单元被插入在分页单元和主存之间。不仅于此，缓存单元包含硬件缓存和缓存控制器。硬件缓存里存放的就是实际的内存行；缓存控制器里存放的是数组，数组中的每一个条目，包含了<code>tag</code>字段和其他用于描述这个缓存行的标志。<code>tag</code>由几个bit组成，缓存控制器通过<code>tag</code>来识别当前缓存行具体映射到内存的哪个位置。另外，物理地址通常被拆分为三部分，首先的就是<code>tag</code>，中间部分是缓存控制器的子集索引（？），最后是行内偏移。</p>
<p><img src="/2025/04/17/ulk3/image-20250422120641467.png" alt="image-20250422120641467"></p>
<p>当CPU访存时，首先从物理地址中提取出子集索引，然后比较子集中的<code>tag</code>，如果tag匹配成功，cache命中；反之，cache miss</p>
<p>当cache hit时，根据访问权限的不同，缓存控制器有两种不同的表现。对于read操作，控制器选择cache line中的数据，然后传输到CPU的寄存器中即可，无需访存，从这里可以看出缓存机制的优势。对于write操作，控制器会执行两种不同的策略：<code>write-through</code>和<code>write-back</code>。对于<code>write-through</code>策略，控制器会对RAM和缓存行同时执行write操作。对于<code>write-back</code>策略，更加高效，只有cache line被更新，而memory line不被更新。当然，最终memory line肯定被被更新的，只有当这些操作出现时：CPU执行了刷新cache entries的操作，或者是硬件刷新信号，通常是在cache miss后发生，cache controller才会将cache line写回RAM的memory line中。</p>
<p>当cache miss时，cache line被写会到内存中，如果有必要的话，正确的memory line会被从RAM加载到cache。</p>
<p>多处理器系统中，每个处理器都有各自的硬件缓存，因此，需要额外的硬件电路来对不同CPU的cache进行同步。每个CPU都有各自的本地缓存，因此缓存更新变得更加费时。无论什么时候，CPU进行缓存更新，他必须要检查相同的数据是否被存放在其他处理器的硬件缓存中。如果有，那么该CPU需要提醒其他CPU相关的cache line进行更新。这种操作通常被称为缓存探测（<em>cache snooping</em>）。幸运的事，缓存探测是硬件级别的操作，内核不需要关心这个怎么实现。</p>
<img src="./ulk3//image-20250422124018104.png" alt="image-20250422124018104" style="zoom:50%;">

<p>缓存技术进步十分快。例如，第一代的奔腾型号包含了单独的板载缓存<code>L1-cache</code>。往后更先进的型号包含了更大，略慢的板载缓存<code>L2-cache, L3-cache</code>等等。不同级别之间的缓存一致性是通过硬件来实现的，Linux忽略了这些硬件细节，并且假定只有一个cache level。</p>
<p><code>cr0</code>寄存器中的<code>CD</code>标志用于开启或者关闭缓存电路。<code>NW</code>标志则是用于指定<code>write-through</code>或<code>write-back</code>策略。</p>
<p>关于奔腾处理器的缓存机制，另一个比较有意思的特性是，它可以让不同的page frame有不同的缓存管理策略。为了达到这个目的，Page Directory和Page Table中的每一个条目包含了两个标志：<code>PCD</code>(Page Cache Disable)，这个标志具体说明了：当访问这个page中的数据时，是否要启用cache；<code>PWT</code>(Page Wtite-Through)，这个标志指明了，当需要对某一页中的数据执行写操作时，用<code>write-through</code>还是<code>write-back</code>策略。Linux清楚了Page Directory和Page Table中的所有<code>PCD</code>和<code>PWT</code>标志，这意味着，cache永远启用，并且对于write操作，永远使用<code>write-back</code>策略。</p>
<h3 id="翻译查找缓冲区（TLB）"><a href="#翻译查找缓冲区（TLB）" class="headerlink" title="翻译查找缓冲区（TLB）"></a>翻译查找缓冲区（TLB）</h3><p>除了通用目的的硬件缓存（memory line -&gt; cache line），8086处理器还包含额外的缓存TLB，来加速线性地址的转录。当首次翻译一个线性地址时，CPU是通过一种很慢的方式（访问内存中的Page Table，Page Directory）来计算，得到物理地址的。这个物理地址随后会被存储在TLB的条目中，方便后续访问同一个线性地址时，能够被快速的访问。</p>
<p>在多处理器系统中，每一个CPU都有它自己的TLB，被称为本地TLB（local TLB）。和硬件缓存相反，TLB中的相应的条目不需要同步，因为正在运行的不同进程，可能是相同的线性地址映射到不同的物理地址。</p>
<p>当<code>cr3</code>的控制寄存器被修改了，硬件会自动将local TLB中的所有条目无效化（置0），因为新的页表正在被使用，TLB中的条目指向的是旧数据。</p>
<h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2><p>Linux采用了一个常规的分页模型，能够同时适配32-bit和64-bit的架构。之前解释过，对于64-bit的架构，需要更高级别的page level。到Linux 2.6.10，Linux分页模型支持三级分页；从Linux 2.6.11开始，采用了四级分页模型。线性地址被分成四份：</p>
<ul>
<li>Page Global Directory</li>
<li>Page Upper Directory</li>
<li>Page Middle Directory</li>
<li>Page Table</li>
</ul>
<p>Page n Directory里存放的是Page n-1 Directories的物理地址。Page Table中每一个实体指向Page Frame。因此，线性地址被拆分为五部分。下图中没有显示每一个部分有多少位，因为这取决于具体的架构。</p>
<p><img src="/2025/04/17/ulk3/image-20250422134924869.png" alt="image-20250422134924869"></p>
<p>对于没有扩展到36-bit的32-bit架构，二级分页已经足够了，因此，Linux通过将Page Upper Directory和Page Middle Directory设置成0来消除这些表。然而，Page Upper Directory和Page Middle Directory的位置（指针序列中）被保留，这样能让相同的代码能够同时工作在32-bit和64-bit的架构上。内核通过将Page Upper Directory和Page Middle Directory的长度设置为1来保留这两个表的位置，并且，确保相应的条目指向正确。</p>
<p>对于使用了物理地址扩展的32-bit架构。。。。。略</p>
<p>最后，对于64-bit架构而言，使用三级还是四级分页，取决于硬件(Paging Unit)，取决于系统架构。</p>
<p>Linux处理进程主要依赖于分页，事实上，线性地址到物理地址的自动翻译使用了下述的设计目标：</p>
<ul>
<li>为每个进程分配不同的物理地址空间，确保足够的保护来防止地址错误</li>
<li>对pages（一组数据）和page frames（主存中的物理地址）进行区分。这允许相同的page被存在page frame中，然后被存储在磁盘上，或者从page frame中重新加载。这是虚拟地址机制的基本组成成分。</li>
</ul>
<p>略，这一节有大量的宏和函数，先略过。。。</p>
<h1 id="ch3-进程"><a href="#ch3-进程" class="headerlink" title="ch3 进程"></a>ch3 进程</h1><p>进程是多任务操作系统中的一个基础的 概念。一个进程通常被这样定义：一个正在执行中程序的实例。在Linux源码中，进程通常也被称为任务或者线程。</p>
<h2 id="进程、轻量化进程、线程"><a href="#进程、轻量化进程、线程" class="headerlink" title="进程、轻量化进程、线程"></a>进程、轻量化进程、线程</h2><p>process这个词有众多不同的意思，在本文中，进程按照通常操作系统书籍中的定义：一个process是正在运行程序的实例。读者可能认为进程是一堆数据结构的集合，这些数据结构用来描述程序执行的进度。</p>
<p>进程像人类一样，可以创造进程，进程有着重要的或者不重要的生活，进程也可以产生一个或者多个子进程，一个不同点是进程没有性别，每个进程只有一个双亲（父进程）</p>
<p>在内核看来，进程的目的就是扮演一个可以分配系统资源（CPU时间，内存等）的实体。</p>
<p>当进程被创建完毕，他和他的父进程几乎没什么区别。子进程接受父进程地址空间的一个拷贝，执行相同的代码，从进程创建的系统调用开始，开始下一条指令的执行。尽管子进程和父进程有着相同的程序代码空间，他们的数据空间是分离的（stack &amp; heap），所以子进程对内存的改变操作对父进程而言是不可见的。</p>
<p>早期的unix内核采用的是简单的模型，现代的unix内核则不是。现代的unix系统支持多线程应用，用户程序可以有许多相关而又独立的程序执行流，共享着同一片程序数据结构（线程）。在这个模型中，一个进程是由多个用户线程组成的，每一个线程代表着进程一部分的执行流，如今，大多数多线程应用是使用库函数中的标准集编写的，也被称为pthread (POSIX thread) libraries.</p>
<p>旧版本的Linux内核并不支持多线程应用，在内核的角度，多线程应用仅仅只是一个普通的进程。在用户态下，多线程应用中的多个执行流被创建，执行，调度，通过满足POSIX pthread库的标准。</p>
<p>然而，这种多线程应用的实现并不是很让人满意。例如，假定一个象棋进程使用了两个线程，一个控制绘制棋盘，另一个负责用户输入下一步棋的移动。当地一个线程等待玩家的移动时，第二个线程应该持续运行，持续运行的时间时玩家思考下一步棋的时间。然而，如果这个象棋程序时单进程的，那么第一个线程不能简单的使用阻塞的系统调用（会阻塞整个进程）来等待用户行动，不然，第二个线程也会被阻塞。取而代之的是，第一个进程应该采用复杂的非阻塞技术来确保进程持续在运行，而不是阻塞。</p>
<p>Linux使用轻量化的进程来为多线程应用提供更好的支持。最基本的，两个轻量化的进程能够共享一些资源，例如地址空间、打开的文件等等。当他们中的一个修改了共享资源，另一个立马可以看到改动。当然，当访问共享资源时，这两个进程必须要进行同步。</p>
<p>为了实现多线程程序，一个简单的方法是为每个线程分配一个轻量化的进程。通过这种方式，线程能访问相同的应用数据结构，通过共享相同的内存地址空间，相同的打开文件等等。同时，每一个线程都能够被内核调度。满足POSIX瞄准的pthread库，并使用了Linux轻量化线程的有：<code>LinuxThreads, Native POSIX Thread Library (NPTL)...</code>。</p>
<p>满足POSIX标准的多线程应用能够完美滴被支持线程组的Linux kernel所处理。在这类Linux系统中，<code>thread group</code>是一组基本的轻量级进程的集合，并且作为一个整体考虑，实现了一些系统调用：<code>getpid(), kill(), _exit()</code>。</p>
<h2 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h2><p>为了管理进程，kernel必须要清楚地知道每一个进程正在做什么。例如，进程的优先级，进程是否上CPU运行，进程是否阻塞等待事件发生，进程的地址空间，进程被分配了哪些文件，等等。进程描述符<code>process descriptor</code>记录这些事情。process descriptor是一个<code>task_struct</code>类型的数据结构，它里面的字段包含着一个进程所有的信息。由于存储着这么多的信息，process descriptor更加复杂一点。除了大量包含进程属性的字段，process descriptor还报刊了一些指向其他数据结构的指针。</p>
<img src="./ulk3//image-20250422194845630.png" alt="image-20250422194845630" style="zoom:50%;">

<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>如名字暗示的那样，process descriptor的<code>state</code>字段描述了当前进程的状态。它包含了一组标志组成的数组，每一个标志都是当下进程可能的状态。在当前的Linux系统中，这些状态是互斥的，因此其实只有一个状态被设置，其他的状态都是被清除的。进程的状态如下：</p>
<ul>
<li><code>TASK_RUNING</code>：进程要么正在被CPU执行，要么等待被执行。</li>
<li><code>TASK_INTERRUPTIBLE</code>：进程被阻塞了（睡眠），直到某些条件满足：唤起硬件中断、发布进程正在等待的系统资源、发布信号量</li>
<li><code>TASK_UNINTERRUPTIBLE</code>：和<code>TASK_INTERRUPTIBLE</code>状态相类似，除了一点：发送信号量到一个sleep的进程，不会改变他的状态。这个进程状态很少被用到。下面是用到这个状态的一个例子：一个进程打开一个驱动文件，相应的设备驱动开始探测相应的硬件设备。设备驱动不能够被打断，直到探测结束，或者是硬件设备以一种不可预测的状态结束。</li>
<li><code>TASK_STOPPED</code>：进程的执行被停止了；通过接收到以下信号<code>SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU</code>，进程进入停止状态。</li>
<li><code>TASK_TRACED</code>：进程的执行被debugger停止了。当进程被其他进程监控时（例如debugger通过系统调用<code>ptrace()</code>来监测测试程序）</li>
</ul>
<p>两个额外的状态，既可以被存储在process descriptor的<code>state</code>字段里，也可以被存储在<code>exit_state</code>字段里。因为这两个状态代表着进程运行的终止。</p>
<ul>
<li><code>EXIT_ZOMBIE</code>：进程的执行被终止了，但是父进程没有发布系统调用<code>wait4() or waitpid()</code>来返回死掉进程的信息。在发布<code>waitxx()</code>系统调用前，kernel不能丢弃死掉进程的process descriptor，因为父进程可能还需要这些信息。</li>
<li><code>EXIT_DEAD</code>：最终状态，进程被kernel移除了，因为父进程提交了<code>waitxx()</code>系统调用。</li>
</ul>
<p><code>state</code>字段可以通过简单的赋值语句进行设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure>

<p>内核也可以通过这两个宏<code>set_task_state</code>和<code>set_current_state</code>来设置状态。前者设置具体进程的状态，后者设置当前正在执行进程的状态。不仅如此，使用这些micro来更改state可以防止编译器或者CPU控制单元混淆某些指令，这可能会导致一些灾难性的后果。</p>
<h3 id="标识一个进程"><a href="#标识一个进程" class="headerlink" title="标识一个进程"></a>标识一个进程</h3><p>众所周知，每个能够被kernel调度的执行上下文（进程、线程）必须有它自己的descriptor。因此，即使是轻量化进程lightweight processes，他们仍然有自己的<code>task_struct</code>结构，即使他们共享了很多的kernel data structures。</p>
<p>process和process descriptor之间一一对应的限制，使得kernel识别processes很方便，原因在于<code>task_struct</code>是32-bit的地址。这些地址被<code>process descriptor pointers</code>所存储。kernel对大部分进程的引用是通过process descriptor pointers来完成的。</p>
<p>另一方面，Unix-like系统允许用户通过PID来标识进程，PID被存储在process descriptor的<code>pid</code>字段中。PIDs在数字上是有序的。新创建进程的PID是创建者进程PID自增1得到的。当然，PID有上限。当内核发现进程PID已经达到上限时，就会环绕到最低的、unused PID。默认情况下，PID的最大值是$2^{15}-1&#x3D;32,7767$（早期的unix使用16位的short来存PID，然后取最大正数，负数用来标识进程组中的所有进程）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill(1234, SIGTERM);    // 杀掉 PID 为 1234 的进程</span><br><span class="line">kill(0, SIGTERM);       // 杀掉当前进程所在进程组的所有进程</span><br><span class="line">kill(-1234, SIGTERM);   // 杀掉进程组号为 1234 的所有进程</span><br><span class="line">kill(-1, SIGTERM);      // 尝试向所有进程发送信号（root 才能成功）</span><br></pre></td></tr></table></figure>

<p>用户可以向*&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max*这个文件里写一个更小的值来修改 MAX PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ cat /proc/sys/kernel/pid_max                               </span><br><span class="line">4194304</span><br></pre></td></tr></table></figure>

<p><em>&#x2F;proc</em>是一个被挂载的特殊的文件系统（CH12中有讲到）。在64-bit系统中，root可以将MAX PID修改为4194303.</p>
<p>当环绕PID时，kernel必须管理<em>pidmap_array</em> bitmap，这个bitmap是用来标识哪些PID已经被分配了，而哪些没有分配。在32-bit系统中，由于一个page frame是32768bits，小于MAX PID，所以bitmap被存储在一个单独的page frame中。而在64-bit架构下，需要更多的page frame来存储bitmap，这些page从来不会被释放。</p>
<p>Linux为不同的进程或者轻量化进程分配不同的PID。这种方法具有最大的灵活性，因为任何被执行的上下文都能够被唯一地标识。</p>
<p>另一方面，unix程序员希望同一组threads具有相同的PID。例如，可能会有这样的场景，指定一个PID，向所有组里的threads发送信号。事实上，POSIX 1003.1c标准规定，在多线程应用中，所有的threads都需要有相同的PID。</p>
<p>为了遵守这个标准，Linux提出了线程组thread groups。所有threads共享一个PID标识符，这个标识符是最开始的lightweight process的，也被称为thread group leader。这个共享的PID被存储在process descriptor的<em>tgid</em>字段中。系统调用<em>getpid()<em>返回当前process的descriptor里的</em>tgid</em>字段，而非<em>pid</em>字段，因此一个group里的所有threads都是反悔的同一个pid标识符。大部分processes都是属于一个由单个member组成的group中，因此他们也作为group leader，他们的<em>pid</em>和<em>tgpid</em>是相同的，因此*getpid()*系统调用也能够正常工作。</p>
<p>随后，会讲解如何高效地从一个PID导出其具体的process descriptor pointer。效率很关键，因为很多系统调用，例如*kill()*使用PID来代指一个进程。</p>
<h4 id="处理进程描述符"><a href="#处理进程描述符" class="headerlink" title="处理进程描述符"></a>处理进程描述符</h4><p>进程是一类动态实体，生命周期从ms到months。因此，内核需要有能力一次处理多个进程。并且，进程描述符被存储在DRAM而不是永久分配给kernel的RAM里。Linux打包了两个不同的数据结构在每个进程单独的内存区域内：一个很小的链接到process descriptor的数据结构，也就是<em>thread_info</em>结构以及内核态进程堆栈（kernel mode process stack）。这片内存区域通常大小为8192字节，也就是两个page frame。出于效率考虑，Linux kernel将这8KB的内存区域存储在两个连续的page frame里，将第一个page fram以8KB（$2^{13}$）对其。然而当启用动态内存时，这可能会导致一个问题：内存可能是高度碎片化的（CH8中会讲到）。因此，在8086架构下，kernel可以在编译时间被配置，使得包含了stack和<em>thread_info</em>结构跨越单独的一个page frame。（maybe不连续？？）</p>
<p>在前面，我们了解到，在内核态下的process访问的stack包含kernel data segment，这不同于用户态下的process访问的stack。因为内核控制路径很少使用堆栈，因此仅仅需要几KB的内核堆栈。因此，对于stack和<em>thread_info</em>而言，8KB是一份充足的空间。然而，当stack和<em>thread_info</em>被包含在同一个page frame中，kernel使用了一些额外的堆栈来避免因为中断或者异常嵌套过深导致的overflow。</p>
<p>下图展示了stack和<em>thread_info</em>在两个page frame中是如何组织的。<em>thread_info</em>处于内存开始的区域，而stack是从最高位地址开始向下增长。下图也展示了这两页和process descriptor是如何相连的。</p>
<p><img src="/2025/04/17/ulk3/image-20250423142011158.png" alt="image-20250423142011158"></p>
<p><em>esp</em>寄存器代表CPU的栈顶指针，用于寻址栈顶。在8086系统中，栈顶从最后开始，向下生长到内存区域最开始的地方。在进程刚刚从用户态切换到内核态时，kernel stack是空的，因此esp指向堆栈最上面的字节。</p>
<p>当数据被push到kernel stack中后，esp会递减，并且，由于<em>thread_info</em>的大小事52 bytes，因此kernel stack最多只能到8140 bytes</p>
<p>在C语言中，stack和<em>thread_info</em>能够被很方便的组织在一起，通过union数据结构：</p>
<img src="./ulk3//image-20250423145221042.png" alt="image-20250423145221042" style="zoom:33%;">

<p>kernel通过<em>alloc_thread_info</em>和<em>free_thread_info</em>这两个micro来分配和释放存储在<em>thread_info</em>和stack中的内存。</p>
<h4 id="标识当前进程"><a href="#标识当前进程" class="headerlink" title="标识当前进程"></a>标识当前进程</h4><p><em>thread_info</em>和kernel mode stack的紧密联系，对效率有提升：内核可以很容易地获得当前运行进程的<em>thread_info</em>的地址，通过访问<em>esp</em>寄存器。事实上，假设<em>thread_union</em>的大小是8KB，kernel只需要mask低13位即可得到<em>thread_info</em>的基地址。另一方面，如果<em>thread_union</em>大小是4KB，那么只需要mask掉12位即可。这歌过程是通过*current-thread_info()*函数来完成的，通过汇编语言实现：</p>
<img src="./ulk3//image-20250423151317515.png" alt="image-20250423151317515" style="zoom: 33%;">

<p>在执行完这三条指令后，<em>p</em>中就包含了当前正在CPU上运行的process的<em>thread_info</em>地址（指针）。</p>
<p>通常而言，kernel需要的是process descriptor的地址，而非<em>thread_info</em>的地址。为了达到这个目的，kernel利用<em>current</em>这个micro，和<em>current_thread_info()-&gt;task</em>是等价的，汇编上是这样实现：</p>
<img src="./ulk3//image-20250423152045521.png" alt="image-20250423152045521" style="zoom:33%;">

<p>因为<em>task</em>字段是在<em>thread_info</em>的0号索引处，在执行这三条汇编之后，<em>p</em>中就包含了当前CPU运行进程的<em>process descriptor</em>的地址。</p>
<p><em>current</em> micro经常作为字段的前缀出现在kernel code里，例如：<em>current-&gt;pid</em>返回的就是当前进程的PID。</p>
<p>另一个把<em>thread_info</em>和<em>stack</em>存放在一起的优点是，在多处理器系统中：通过上面的方法（<em>current</em> micro），可以直接找到不同CPU上运行的不同process。早期的Linux系统并没有这样做，取而代之的是，Linux强行引入了一个全聚德静态变量<em>current</em>来标识正在运行进程的<em>process descriptor</em>，若是在多处理器系统中，就需要定义一个全局静态数组，来标识每个进程的<em>process descriptor</em>。</p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>在讨论内核如何跟踪系统中的不同进程前，县重点讨论一下双链表，这在许多特殊的数据结构里起作用。</p>
<p>对于每一个链表，一组原始操作需要被实现：初始化双链表、插入和删除元素、扫描列表等等。如果对于每个list，程序员都去实现这些原始操作，这是比较费时费力，浪费内存。</p>
<p>因此，Linux kernel定义了<em>list_head</em>这个数据结构，仅仅有两个字段<em>next</em>和<em>prev</em>，代表着forward pointer和back pointer，这些pointers指向的都是双链表的元素。然而，需要强调的是，<em>list_head</em>的字段里存着的是其他<em>list_head</em>的地址，而不是整个数据结构（整条链表）的地址。这里应该是为了和数组进行区分。</p>
<p>通过<em>LIST_HEAD(lisy_name)<em>这个micro来创建一个新的链表。这个micro声明了一个名为</em>list_name</em>类型为<em>list_type</em>的新变量。这是一个占位符，作为这个链表的表头占位符（里面可以不存放任何数据，只代表head），初始化两个指针<em>next</em>和<em>prev</em>，指向自身。</p>
<p><img src="/2025/04/17/ulk3/image-20250423190957875.png" alt="image-20250423190957875"></p>
<p>一些函数和micro已经被实现了，如下：</p>
<p><img src="/2025/04/17/ulk3/image-20250423191825615.png" alt="image-20250423191825615"></p>
<p>2.6版本的Linux kernel也支持另一种双链表，和<em>list_head</em>的主要区别在于<em>list_head</em>不是环绕的；这主要用于哈希表中（存储空间十分重要），以常数级别的时间复杂度找到最后一个元素。表头存储在<em>hlist_head</em>中。这个数据结构仅仅只是一个指针，指向第一个元素，若第一个元素不存在，那么指向NULL。链表中的每一个元素则是用<em>hlist_node</em>数据结构来表示，这个数据结构同样包含两个指针<em>next</em>和<em>pprev</em>。由于链表不是环绕的，第一个元素的<em>pprev</em>和最后一个元素的<em>next</em>都是指向NULL。这个数据结构也可以被一些micro和函数所处理，例如：</p>
<p><img src="/2025/04/17/ulk3/image-20250423192754112.png" alt="image-20250423192754112"></p>
<h4 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h4><p>我们要讨论的第一个双链表的例子是<em>process list</em>，进程列表，里面存放的是所有存在进程的<em>process descriptor</em>。每一个<em>task_struct</em>结构包含一个<em>task</em>字段，这个<em>task</em>字段的类型是<em>list_head</em>，其<em>next</em>和<em>prev</em>指向的是下一个或者前一个<em>task_struct</em>。</p>
<p>进程列表的表头是<em>init_task</em>的<em>task_struct</em>描述符。这是0号进程的process descriptor（process 0也被称为<em>swapper</em>）。<em>init_task</em>的<em>task-&gt;prev</em>指向的是最后一个process descriptor。</p>
<p><em>SET_LINKS</em>和<em>REMOVE_LINKS</em>这两个micro被用作插入或者移除process descriptor。这些micro也会关心进程的父子关系。</p>
<p>另一个比较有用的micro是<em>for_each_process</em>，用来扫描进程列表：</p>
<p><img src="/2025/04/17/ulk3/image-20250423194246862.png" alt="image-20250423194246862"></p>
<p>这个micro是一个循环，由内核程序员提供。需要重点关注<em>init_task</em>进程描述符作为表头的作用。这个micro从<em>init_task</em>开始，当再次访问到<em>init_task</em>结束，从这里可以看出，循环列表的环绕效果起了作用。在每一轮迭代，micro作为参数传递的变量包含当前process descriptor的地址，通过*list_entry()*提供。</p>
<h4 id="TASK-RUNNING进程列表"><a href="#TASK-RUNNING进程列表" class="headerlink" title="TASK_RUNNING进程列表"></a><em>TASK_RUNNING</em>进程列表</h4><p>当kernel寻找新的进程上CPU运行时，内核只能考虑可运行的进程，也就是状态为<em>TASK_RUNNING</em>的。</p>
<p>早期的Linux版本中，将所有可运行的进程放到一个名为<em>runqueue</em>的列表里。因为保持这个列表有序（按照进程优先级）十分费时间，早起的schedulers被强迫去扫描整个list，以便找到最优的runnable process。</p>
<p>Linux 2.6以不同的形式实现了<em>runqueue</em>，目的是让scheduler以常数时间来选择最优的runnable process。关于<em>runqueue</em>，在CH7中会有更详细的讲述，这里只提供基本信息。</p>
<p>（核心思想和UCOSiii里的TCB很类似）加速调度器的技巧是将runqueue拆分为很多list，每个list一个优先级。每个<em>task_struct</em> descriptor包含一个<em>run_list</em>字段，类型为<em>list_head</em>。如果进程的优先级是k（在0到139之间），<em>run_list</em>字段连接process descriptor到第k个runnable processes list里。此外，在多处理器系统中，每个CPU有其单独的runqueue。这是一个很经典的例子，让数据结构更加复杂来换取性能：为了让scheduler操作更加高效，runqueue被拆分成140个不同的列表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/17/ulk3/" data-id="cm9txd3m7005nf9nnbexmh2u2" data-title="深度理解Linux内核" class="article-share-link">Share</a>
      
      
      
      
      
      

    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/covers/IMG_2583 2.PNG" data-sizes="auto" alt="frequency-backdoor-attack" class="lazyload">
        
      
      <a href="/2024/09/12/frequency-backdoor-attack/"></a>
      <div class="article-nav-caption">Older</div>
      <h3 class="article-nav-title">
        
          frequency-backdoor-attack
        
      </h3>
    </div>
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch2-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">ch2 内存地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text">内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%86%E6%AE%B5"><span class="toc-number">1.2.</span> <span class="toc-text">硬件分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6%E5%92%8C%E5%88%86%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">段选择符和分段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">快速访问段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%8D%95%E5%85%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">分段单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">Linux中的分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">Linux中的全局描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">Linux中的局部描述符表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">硬件分页原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">常规分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%88%86%E9%A1%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">扩展分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">硬件保护方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.4.</span> <span class="toc-text">常规分页的一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.5.</span> <span class="toc-text">物理地址扩展分页机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-bit%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">64-bit架构的分页机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.7.</span> <span class="toc-text">硬件缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E6%9F%A5%E6%89%BE%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88TLB%EF%BC%89"><span class="toc-number">1.4.8.</span> <span class="toc-text">翻译查找缓冲区（TLB）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">1.5.</span> <span class="toc-text">Linux中的分页</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch3-%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">ch3 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BD%BB%E9%87%8F%E5%8C%96%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程、轻量化进程、线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">进程描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">标识一个进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">处理进程描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">标识当前进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">进程列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TASK-RUNNING%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">TASK_RUNNING进程列表</span></a></li></ol></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2025
        <span class="footer-info-sep"></span>
        chengyiqiu
      </div>
      
        <div>
          Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          141.6k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          09:38
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch2-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">ch2 内存地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text">内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%86%E6%AE%B5"><span class="toc-number">1.2.</span> <span class="toc-text">硬件分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6%E5%92%8C%E5%88%86%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">段选择符和分段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">快速访问段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%8D%95%E5%85%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">分段单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">Linux中的分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">Linux中的全局描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">Linux中的局部描述符表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">硬件分页原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">常规分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%88%86%E9%A1%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">扩展分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">硬件保护方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.4.</span> <span class="toc-text">常规分页的一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.5.</span> <span class="toc-text">物理地址扩展分页机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-bit%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">64-bit架构的分页机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.7.</span> <span class="toc-text">硬件缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E6%9F%A5%E6%89%BE%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88TLB%EF%BC%89"><span class="toc-number">1.4.8.</span> <span class="toc-text">翻译查找缓冲区（TLB）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">1.5.</span> <span class="toc-text">Linux中的分页</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch3-%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">ch3 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BD%BB%E9%87%8F%E5%8C%96%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程、轻量化进程、线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">进程描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">标识一个进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">处理进程描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">标识当前进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">进程列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TASK-RUNNING%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">TASK_RUNNING进程列表</span></a></li></ol></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/rabbit_1.jpg" data-sizes="auto" alt="chengyiqiu" class="lazyload">
  <div class="sidebar-author-name">chengyiqiu</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div>
    <div class="sidebar-state-number">65</div>
  </div>
  <div class="sidebar-state-category">
    <div>Categories</div>
    <div class="sidebar-state-number">13</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tags</div>
    <div class="sidebar-state-number">17</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="Home"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Home</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="Archives"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Archives</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="About"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">About</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="Friend"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">Friend</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>






<script src="/js/pjax_script.js" data-pjax></script>

















  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.2' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

